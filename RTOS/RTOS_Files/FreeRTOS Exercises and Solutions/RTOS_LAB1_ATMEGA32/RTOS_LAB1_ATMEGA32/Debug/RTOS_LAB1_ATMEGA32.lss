
RTOS_LAB1_ATMEGA32.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00001b2a  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         0000002c  00800060  00001b2a  00001bbe  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          000002e6  0080008c  0080008c  00001bea  2**0
                  ALLOC
  3 .stab         00000888  00000000  00000000  00001bec  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      000001ac  00000000  00000000  00002474  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_aranges 00000160  00000000  00000000  00002620  2**3
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00002560  00000000  00000000  00002780  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00000bdb  00000000  00000000  00004ce0  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00000e30  00000000  00000000  000058bb  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  000007c4  00000000  00000000  000066ec  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00000f2f  00000000  00000000  00006eb0  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00002116  00000000  00000000  00007ddf  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000090  00000000  00000000  00009ef5  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 2a 00 	jmp	0x54	; 0x54 <__ctors_end>
       4:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
       8:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
       c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      10:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      14:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      18:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      1c:	0c 94 4b 05 	jmp	0xa96	; 0xa96 <__vector_7>
      20:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      24:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      28:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      2c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      30:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      34:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      38:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      3c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      40:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      44:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      48:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      4c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      50:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>

00000054 <__ctors_end>:
      54:	11 24       	eor	r1, r1
      56:	1f be       	out	0x3f, r1	; 63
      58:	cf e5       	ldi	r28, 0x5F	; 95
      5a:	d8 e0       	ldi	r29, 0x08	; 8
      5c:	de bf       	out	0x3e, r29	; 62
      5e:	cd bf       	out	0x3d, r28	; 61

00000060 <__do_copy_data>:
      60:	10 e0       	ldi	r17, 0x00	; 0
      62:	a0 e6       	ldi	r26, 0x60	; 96
      64:	b0 e0       	ldi	r27, 0x00	; 0
      66:	ea e2       	ldi	r30, 0x2A	; 42
      68:	fb e1       	ldi	r31, 0x1B	; 27
      6a:	02 c0       	rjmp	.+4      	; 0x70 <__do_copy_data+0x10>
      6c:	05 90       	lpm	r0, Z+
      6e:	0d 92       	st	X+, r0
      70:	ac 38       	cpi	r26, 0x8C	; 140
      72:	b1 07       	cpc	r27, r17
      74:	d9 f7       	brne	.-10     	; 0x6c <__do_copy_data+0xc>

00000076 <__do_clear_bss>:
      76:	13 e0       	ldi	r17, 0x03	; 3
      78:	ac e8       	ldi	r26, 0x8C	; 140
      7a:	b0 e0       	ldi	r27, 0x00	; 0
      7c:	01 c0       	rjmp	.+2      	; 0x80 <.do_clear_bss_start>

0000007e <.do_clear_bss_loop>:
      7e:	1d 92       	st	X+, r1

00000080 <.do_clear_bss_start>:
      80:	a2 37       	cpi	r26, 0x72	; 114
      82:	b1 07       	cpc	r27, r17
      84:	e1 f7       	brne	.-8      	; 0x7e <.do_clear_bss_loop>
      86:	0e 94 6c 08 	call	0x10d8	; 0x10d8 <main>
      8a:	0c 94 93 0d 	jmp	0x1b26	; 0x1b26 <_exit>

0000008e <__bad_interrupt>:
      8e:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000092 <xCoRoutineCreate>:
static void prvCheckDelayedList( void );

/*-----------------------------------------------------------*/

signed portBASE_TYPE xCoRoutineCreate( crCOROUTINE_CODE pxCoRoutineCode, unsigned portBASE_TYPE uxPriority, unsigned portBASE_TYPE uxIndex )
{
      92:	af 92       	push	r10
      94:	bf 92       	push	r11
      96:	cf 92       	push	r12
      98:	df 92       	push	r13
      9a:	ef 92       	push	r14
      9c:	ff 92       	push	r15
      9e:	0f 93       	push	r16
      a0:	1f 93       	push	r17
      a2:	cf 93       	push	r28
      a4:	df 93       	push	r29
      a6:	6c 01       	movw	r12, r24
      a8:	e6 2e       	mov	r14, r22
      aa:	f4 2e       	mov	r15, r20
signed portBASE_TYPE xReturn;
corCRCB *pxCoRoutine;

	/* Allocate the memory that will store the co-routine control block. */
	pxCoRoutine = ( corCRCB * ) pvPortMalloc( sizeof( corCRCB ) );
      ac:	8a e1       	ldi	r24, 0x1A	; 26
      ae:	90 e0       	ldi	r25, 0x00	; 0
      b0:	0e 94 6e 02 	call	0x4dc	; 0x4dc <pvPortMalloc>
      b4:	8c 01       	movw	r16, r24
	if( pxCoRoutine )
      b6:	00 97       	sbiw	r24, 0x00	; 0
      b8:	09 f4       	brne	.+2      	; 0xbc <xCoRoutineCreate+0x2a>
      ba:	62 c0       	rjmp	.+196    	; 0x180 <xCoRoutineCreate+0xee>
	{
		/* If pxCurrentCoRoutine is NULL then this is the first co-routine to
		be created and the co-routine data structures need initialising. */
		if( pxCurrentCoRoutine == NULL )
      bc:	80 91 8c 00 	lds	r24, 0x008C
      c0:	90 91 8d 00 	lds	r25, 0x008D
      c4:	00 97       	sbiw	r24, 0x00	; 0
      c6:	39 f5       	brne	.+78     	; 0x116 <xCoRoutineCreate+0x84>
		{
			pxCurrentCoRoutine = pxCoRoutine;
      c8:	10 93 8d 00 	sts	0x008D, r17
      cc:	00 93 8c 00 	sts	0x008C, r16
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = 0; uxPriority < configMAX_CO_ROUTINE_PRIORITIES; uxPriority++ )
	{
		vListInitialise( ( xList * ) &( pxReadyCoRoutineLists[ uxPriority ] ) );
      d0:	cf e8       	ldi	r28, 0x8F	; 143
      d2:	d0 e0       	ldi	r29, 0x00	; 0
      d4:	ce 01       	movw	r24, r28
      d6:	0e 94 33 03 	call	0x666	; 0x666 <vListInitialise>
      da:	ce 01       	movw	r24, r28
      dc:	09 96       	adiw	r24, 0x09	; 9
      de:	0e 94 33 03 	call	0x666	; 0x666 <vListInitialise>
	}

	vListInitialise( ( xList * ) &xDelayedCoRoutineList1 );
      e2:	c1 ea       	ldi	r28, 0xA1	; 161
      e4:	d0 e0       	ldi	r29, 0x00	; 0
      e6:	ce 01       	movw	r24, r28
      e8:	0e 94 33 03 	call	0x666	; 0x666 <vListInitialise>
	vListInitialise( ( xList * ) &xDelayedCoRoutineList2 );
      ec:	0f 2e       	mov	r0, r31
      ee:	fa ea       	ldi	r31, 0xAA	; 170
      f0:	af 2e       	mov	r10, r31
      f2:	f0 e0       	ldi	r31, 0x00	; 0
      f4:	bf 2e       	mov	r11, r31
      f6:	f0 2d       	mov	r31, r0
      f8:	c5 01       	movw	r24, r10
      fa:	0e 94 33 03 	call	0x666	; 0x666 <vListInitialise>
	vListInitialise( ( xList * ) &xPendingReadyCoRoutineList );
      fe:	83 eb       	ldi	r24, 0xB3	; 179
     100:	90 e0       	ldi	r25, 0x00	; 0
     102:	0e 94 33 03 	call	0x666	; 0x666 <vListInitialise>

	/* Start with pxDelayedCoRoutineList using list1 and the
	pxOverflowDelayedCoRoutineList using list2. */
	pxDelayedCoRoutineList = &xDelayedCoRoutineList1;
     106:	d0 93 bd 00 	sts	0x00BD, r29
     10a:	c0 93 bc 00 	sts	0x00BC, r28
	pxOverflowDelayedCoRoutineList = &xDelayedCoRoutineList2;
     10e:	b0 92 bf 00 	sts	0x00BF, r11
     112:	a0 92 be 00 	sts	0x00BE, r10
     116:	ce 2d       	mov	r28, r14
     118:	e1 10       	cpse	r14, r1
     11a:	c1 e0       	ldi	r28, 0x01	; 1
		{
			uxPriority = configMAX_CO_ROUTINE_PRIORITIES - 1;
		}

		/* Fill out the co-routine control block from the function parameters. */
		pxCoRoutine->uxState = corINITIAL_STATE;
     11c:	f8 01       	movw	r30, r16
     11e:	11 8e       	std	Z+25, r1	; 0x19
     120:	10 8e       	std	Z+24, r1	; 0x18
		pxCoRoutine->uxPriority = uxPriority;
     122:	c6 8b       	std	Z+22, r28	; 0x16
		pxCoRoutine->uxIndex = uxIndex;
     124:	f7 8a       	std	Z+23, r15	; 0x17
		pxCoRoutine->pxCoRoutineFunction = pxCoRoutineCode;
     126:	c1 92       	st	Z+, r12
     128:	d1 92       	st	Z+, r13
     12a:	7f 01       	movw	r14, r30

		/* Initialise all the other co-routine control block parameters. */
		vListInitialiseItem( &( pxCoRoutine->xGenericListItem ) );
     12c:	cf 01       	movw	r24, r30
     12e:	0e 94 41 03 	call	0x682	; 0x682 <vListInitialiseItem>
		vListInitialiseItem( &( pxCoRoutine->xEventListItem ) );
     132:	c8 01       	movw	r24, r16
     134:	0c 96       	adiw	r24, 0x0c	; 12
     136:	0e 94 41 03 	call	0x682	; 0x682 <vListInitialiseItem>

		/* Set the co-routine control block as a link back from the xListItem.
		This is so we can get back to the containing CRCB from a generic item
		in a list. */
		listSET_LIST_ITEM_OWNER( &( pxCoRoutine->xGenericListItem ), pxCoRoutine );
     13a:	f8 01       	movw	r30, r16
     13c:	11 87       	std	Z+9, r17	; 0x09
     13e:	00 87       	std	Z+8, r16	; 0x08
		listSET_LIST_ITEM_OWNER( &( pxCoRoutine->xEventListItem ), pxCoRoutine );
     140:	13 8b       	std	Z+19, r17	; 0x13
     142:	02 8b       	std	Z+18, r16	; 0x12
	
		/* Event lists are always in priority order. */
		listSET_LIST_ITEM_VALUE( &( pxCoRoutine->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) uxPriority );
     144:	83 e0       	ldi	r24, 0x03	; 3
     146:	90 e0       	ldi	r25, 0x00	; 0
     148:	8c 1b       	sub	r24, r28
     14a:	91 09       	sbc	r25, r1
     14c:	95 87       	std	Z+13, r25	; 0x0d
     14e:	84 87       	std	Z+12, r24	; 0x0c
		
		/* Now the co-routine has been initialised it can be added to the ready
		list at the correct priority. */
		prvAddCoRoutineToReadyQueue( pxCoRoutine );
     150:	86 89       	ldd	r24, Z+22	; 0x16
     152:	90 91 8e 00 	lds	r25, 0x008E
     156:	98 17       	cp	r25, r24
     158:	10 f4       	brcc	.+4      	; 0x15e <xCoRoutineCreate+0xcc>
     15a:	80 93 8e 00 	sts	0x008E, r24
     15e:	90 e0       	ldi	r25, 0x00	; 0
     160:	9c 01       	movw	r18, r24
     162:	22 0f       	add	r18, r18
     164:	33 1f       	adc	r19, r19
     166:	22 0f       	add	r18, r18
     168:	33 1f       	adc	r19, r19
     16a:	22 0f       	add	r18, r18
     16c:	33 1f       	adc	r19, r19
     16e:	82 0f       	add	r24, r18
     170:	93 1f       	adc	r25, r19
     172:	81 57       	subi	r24, 0x71	; 113
     174:	9f 4f       	sbci	r25, 0xFF	; 255
     176:	b7 01       	movw	r22, r14
     178:	0e 94 45 03 	call	0x68a	; 0x68a <vListInsertEnd>

		xReturn = pdPASS;
     17c:	81 e0       	ldi	r24, 0x01	; 1
     17e:	01 c0       	rjmp	.+2      	; 0x182 <xCoRoutineCreate+0xf0>
	}
	else
	{		
		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
     180:	8f ef       	ldi	r24, 0xFF	; 255
	}
	
	return xReturn;	
}
     182:	df 91       	pop	r29
     184:	cf 91       	pop	r28
     186:	1f 91       	pop	r17
     188:	0f 91       	pop	r16
     18a:	ff 90       	pop	r15
     18c:	ef 90       	pop	r14
     18e:	df 90       	pop	r13
     190:	cf 90       	pop	r12
     192:	bf 90       	pop	r11
     194:	af 90       	pop	r10
     196:	08 95       	ret

00000198 <vCoRoutineAddToDelayedList>:
/*-----------------------------------------------------------*/

void vCoRoutineAddToDelayedList( portTickType xTicksToDelay, xList *pxEventList )
{
     198:	0f 93       	push	r16
     19a:	1f 93       	push	r17
     19c:	cf 93       	push	r28
     19e:	df 93       	push	r29
     1a0:	8b 01       	movw	r16, r22
portTickType xTimeToWake;

	/* Calculate the time to wake - this may overflow but this is
	not a problem. */
	xTimeToWake = xCoRoutineTickCount + xTicksToDelay;
     1a2:	c0 91 c0 00 	lds	r28, 0x00C0
     1a6:	d0 91 c1 00 	lds	r29, 0x00C1
     1aa:	c8 0f       	add	r28, r24
     1ac:	d9 1f       	adc	r29, r25

	/* We must remove ourselves from the ready list before adding
	ourselves to the blocked list as the same list item is used for
	both lists. */
	vListRemove( ( xListItem * ) &( pxCurrentCoRoutine->xGenericListItem ) );
     1ae:	80 91 8c 00 	lds	r24, 0x008C
     1b2:	90 91 8d 00 	lds	r25, 0x008D
     1b6:	02 96       	adiw	r24, 0x02	; 2
     1b8:	0e 94 ab 03 	call	0x756	; 0x756 <vListRemove>

	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentCoRoutine->xGenericListItem ), xTimeToWake );
     1bc:	e0 91 8c 00 	lds	r30, 0x008C
     1c0:	f0 91 8d 00 	lds	r31, 0x008D
     1c4:	d3 83       	std	Z+3, r29	; 0x03
     1c6:	c2 83       	std	Z+2, r28	; 0x02

	if( xTimeToWake < xCoRoutineTickCount )
     1c8:	80 91 c0 00 	lds	r24, 0x00C0
     1cc:	90 91 c1 00 	lds	r25, 0x00C1
     1d0:	c8 17       	cp	r28, r24
     1d2:	d9 07       	cpc	r29, r25
     1d4:	50 f4       	brcc	.+20     	; 0x1ea <vCoRoutineAddToDelayedList+0x52>
	{
		/* Wake time has overflowed.  Place this item in the
		overflow list. */
		vListInsert( ( xList * ) pxOverflowDelayedCoRoutineList, ( xListItem * ) &( pxCurrentCoRoutine->xGenericListItem ) );
     1d6:	bf 01       	movw	r22, r30
     1d8:	6e 5f       	subi	r22, 0xFE	; 254
     1da:	7f 4f       	sbci	r23, 0xFF	; 255
     1dc:	80 91 be 00 	lds	r24, 0x00BE
     1e0:	90 91 bf 00 	lds	r25, 0x00BF
     1e4:	0e 94 6e 03 	call	0x6dc	; 0x6dc <vListInsert>
     1e8:	09 c0       	rjmp	.+18     	; 0x1fc <vCoRoutineAddToDelayedList+0x64>
	}
	else
	{
		/* The wake time has not overflowed, so we can use the
		current block list. */
		vListInsert( ( xList * ) pxDelayedCoRoutineList, ( xListItem * ) &( pxCurrentCoRoutine->xGenericListItem ) );
     1ea:	bf 01       	movw	r22, r30
     1ec:	6e 5f       	subi	r22, 0xFE	; 254
     1ee:	7f 4f       	sbci	r23, 0xFF	; 255
     1f0:	80 91 bc 00 	lds	r24, 0x00BC
     1f4:	90 91 bd 00 	lds	r25, 0x00BD
     1f8:	0e 94 6e 03 	call	0x6dc	; 0x6dc <vListInsert>
	}

	if( pxEventList )
     1fc:	01 15       	cp	r16, r1
     1fe:	11 05       	cpc	r17, r1
     200:	49 f0       	breq	.+18     	; 0x214 <vCoRoutineAddToDelayedList+0x7c>
	{
		/* Also add the co-routine to an event list.  If this is done then the
		function must be called with interrupts disabled. */
		vListInsert( pxEventList, &( pxCurrentCoRoutine->xEventListItem ) );
     202:	60 91 8c 00 	lds	r22, 0x008C
     206:	70 91 8d 00 	lds	r23, 0x008D
     20a:	64 5f       	subi	r22, 0xF4	; 244
     20c:	7f 4f       	sbci	r23, 0xFF	; 255
     20e:	c8 01       	movw	r24, r16
     210:	0e 94 6e 03 	call	0x6dc	; 0x6dc <vListInsert>
	}
}
     214:	df 91       	pop	r29
     216:	cf 91       	pop	r28
     218:	1f 91       	pop	r17
     21a:	0f 91       	pop	r16
     21c:	08 95       	ret

0000021e <vCoRoutineSchedule>:
	xLastTickCount = xCoRoutineTickCount;
}
/*-----------------------------------------------------------*/

void vCoRoutineSchedule( void )
{
     21e:	cf 92       	push	r12
     220:	df 92       	push	r13
     222:	ef 92       	push	r14
     224:	ff 92       	push	r15
     226:	0f 93       	push	r16
     228:	1f 93       	push	r17
     22a:	cf 93       	push	r28
     22c:	df 93       	push	r29
static void prvCheckPendingReadyList( void )
{
	/* Are there any co-routines waiting to get moved to the ready list?  These
	are co-routines that have been readied by an ISR.  The ISR cannot access
	the	ready lists itself. */
	while( listLIST_IS_EMPTY( &xPendingReadyCoRoutineList ) == pdFALSE )
     22e:	80 91 b3 00 	lds	r24, 0x00B3
     232:	88 23       	and	r24, r24
     234:	b9 f1       	breq	.+110    	; 0x2a4 <vCoRoutineSchedule+0x86>
		corCRCB *pxUnblockedCRCB;

		/* The pending ready list can be accessed by an ISR. */
		portDISABLE_INTERRUPTS();
		{	
			pxUnblockedCRCB = ( corCRCB * ) listGET_OWNER_OF_HEAD_ENTRY( (&xPendingReadyCoRoutineList) );			
     236:	0f 2e       	mov	r0, r31
     238:	f8 eb       	ldi	r31, 0xB8	; 184
     23a:	ef 2e       	mov	r14, r31
     23c:	f0 e0       	ldi	r31, 0x00	; 0
     23e:	ff 2e       	mov	r15, r31
     240:	f0 2d       	mov	r31, r0
static void prvCheckPendingReadyList( void )
{
	/* Are there any co-routines waiting to get moved to the ready list?  These
	are co-routines that have been readied by an ISR.  The ISR cannot access
	the	ready lists itself. */
	while( listLIST_IS_EMPTY( &xPendingReadyCoRoutineList ) == pdFALSE )
     242:	0f 2e       	mov	r0, r31
     244:	f3 eb       	ldi	r31, 0xB3	; 179
     246:	cf 2e       	mov	r12, r31
     248:	f0 e0       	ldi	r31, 0x00	; 0
     24a:	df 2e       	mov	r13, r31
     24c:	f0 2d       	mov	r31, r0
	{
		corCRCB *pxUnblockedCRCB;

		/* The pending ready list can be accessed by an ISR. */
		portDISABLE_INTERRUPTS();
     24e:	f8 94       	cli
		{	
			pxUnblockedCRCB = ( corCRCB * ) listGET_OWNER_OF_HEAD_ENTRY( (&xPendingReadyCoRoutineList) );			
     250:	d7 01       	movw	r26, r14
     252:	ed 91       	ld	r30, X+
     254:	fc 91       	ld	r31, X
     256:	c6 81       	ldd	r28, Z+6	; 0x06
     258:	d7 81       	ldd	r29, Z+7	; 0x07
			vListRemove( &( pxUnblockedCRCB->xEventListItem ) );
     25a:	ce 01       	movw	r24, r28
     25c:	0c 96       	adiw	r24, 0x0c	; 12
     25e:	0e 94 ab 03 	call	0x756	; 0x756 <vListRemove>
		}
		portENABLE_INTERRUPTS();
     262:	78 94       	sei

		vListRemove( &( pxUnblockedCRCB->xGenericListItem ) );
     264:	8e 01       	movw	r16, r28
     266:	0e 5f       	subi	r16, 0xFE	; 254
     268:	1f 4f       	sbci	r17, 0xFF	; 255
     26a:	c8 01       	movw	r24, r16
     26c:	0e 94 ab 03 	call	0x756	; 0x756 <vListRemove>
		prvAddCoRoutineToReadyQueue( pxUnblockedCRCB );	
     270:	8e 89       	ldd	r24, Y+22	; 0x16
     272:	90 91 8e 00 	lds	r25, 0x008E
     276:	98 17       	cp	r25, r24
     278:	10 f4       	brcc	.+4      	; 0x27e <vCoRoutineSchedule+0x60>
     27a:	80 93 8e 00 	sts	0x008E, r24
     27e:	90 e0       	ldi	r25, 0x00	; 0
     280:	9c 01       	movw	r18, r24
     282:	22 0f       	add	r18, r18
     284:	33 1f       	adc	r19, r19
     286:	22 0f       	add	r18, r18
     288:	33 1f       	adc	r19, r19
     28a:	22 0f       	add	r18, r18
     28c:	33 1f       	adc	r19, r19
     28e:	82 0f       	add	r24, r18
     290:	93 1f       	adc	r25, r19
     292:	81 57       	subi	r24, 0x71	; 113
     294:	9f 4f       	sbci	r25, 0xFF	; 255
     296:	b8 01       	movw	r22, r16
     298:	0e 94 45 03 	call	0x68a	; 0x68a <vListInsertEnd>
static void prvCheckPendingReadyList( void )
{
	/* Are there any co-routines waiting to get moved to the ready list?  These
	are co-routines that have been readied by an ISR.  The ISR cannot access
	the	ready lists itself. */
	while( listLIST_IS_EMPTY( &xPendingReadyCoRoutineList ) == pdFALSE )
     29c:	f6 01       	movw	r30, r12
     29e:	80 81       	ld	r24, Z
     2a0:	88 23       	and	r24, r24
     2a2:	a9 f6       	brne	.-86     	; 0x24e <vCoRoutineSchedule+0x30>

static void prvCheckDelayedList( void )
{
corCRCB *pxCRCB;

	xPassedTicks = xTaskGetTickCount() - xLastTickCount;
     2a4:	0e 94 67 0a 	call	0x14ce	; 0x14ce <xTaskGetTickCount>
     2a8:	20 91 c2 00 	lds	r18, 0x00C2
     2ac:	30 91 c3 00 	lds	r19, 0x00C3
     2b0:	82 1b       	sub	r24, r18
     2b2:	93 0b       	sbc	r25, r19
     2b4:	90 93 c5 00 	sts	0x00C5, r25
     2b8:	80 93 c4 00 	sts	0x00C4, r24
     2bc:	74 c0       	rjmp	.+232    	; 0x3a6 <vCoRoutineSchedule+0x188>
	while( xPassedTicks )
	{
		xCoRoutineTickCount++;
     2be:	20 91 c0 00 	lds	r18, 0x00C0
     2c2:	30 91 c1 00 	lds	r19, 0x00C1
     2c6:	2f 5f       	subi	r18, 0xFF	; 255
     2c8:	3f 4f       	sbci	r19, 0xFF	; 255
     2ca:	30 93 c1 00 	sts	0x00C1, r19
     2ce:	20 93 c0 00 	sts	0x00C0, r18
		xPassedTicks--;
     2d2:	01 97       	sbiw	r24, 0x01	; 1
     2d4:	90 93 c5 00 	sts	0x00C5, r25
     2d8:	80 93 c4 00 	sts	0x00C4, r24

		/* If the tick count has overflowed we need to swap the ready lists. */
		if( xCoRoutineTickCount == 0 )
     2dc:	21 15       	cp	r18, r1
     2de:	31 05       	cpc	r19, r1
     2e0:	81 f4       	brne	.+32     	; 0x302 <vCoRoutineSchedule+0xe4>
		{
			xList * pxTemp;

			/* Tick count has overflowed so we need to swap the delay lists.  If there are
			any items in pxDelayedCoRoutineList here then there is an error! */
			pxTemp = pxDelayedCoRoutineList;
     2e2:	80 91 bc 00 	lds	r24, 0x00BC
     2e6:	90 91 bd 00 	lds	r25, 0x00BD
			pxDelayedCoRoutineList = pxOverflowDelayedCoRoutineList;
     2ea:	20 91 be 00 	lds	r18, 0x00BE
     2ee:	30 91 bf 00 	lds	r19, 0x00BF
     2f2:	30 93 bd 00 	sts	0x00BD, r19
     2f6:	20 93 bc 00 	sts	0x00BC, r18
			pxOverflowDelayedCoRoutineList = pxTemp;
     2fa:	90 93 bf 00 	sts	0x00BF, r25
     2fe:	80 93 be 00 	sts	0x00BE, r24
		}

		/* See if this tick has made a timeout expire. */
		while( listLIST_IS_EMPTY( pxDelayedCoRoutineList ) == pdFALSE )
     302:	e0 91 bc 00 	lds	r30, 0x00BC
     306:	f0 91 bd 00 	lds	r31, 0x00BD
     30a:	80 81       	ld	r24, Z
     30c:	88 23       	and	r24, r24
     30e:	09 f4       	brne	.+2      	; 0x312 <vCoRoutineSchedule+0xf4>
     310:	4a c0       	rjmp	.+148    	; 0x3a6 <vCoRoutineSchedule+0x188>
		{
			pxCRCB = ( corCRCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedCoRoutineList );
     312:	05 80       	ldd	r0, Z+5	; 0x05
     314:	f6 81       	ldd	r31, Z+6	; 0x06
     316:	e0 2d       	mov	r30, r0
     318:	c6 81       	ldd	r28, Z+6	; 0x06
     31a:	d7 81       	ldd	r29, Z+7	; 0x07

			if( xCoRoutineTickCount < listGET_LIST_ITEM_VALUE( &( pxCRCB->xGenericListItem ) ) )				
     31c:	2a 81       	ldd	r18, Y+2	; 0x02
     31e:	3b 81       	ldd	r19, Y+3	; 0x03
     320:	80 91 c0 00 	lds	r24, 0x00C0
     324:	90 91 c1 00 	lds	r25, 0x00C1
     328:	82 17       	cp	r24, r18
     32a:	93 07       	cpc	r25, r19
     32c:	78 f4       	brcc	.+30     	; 0x34c <vCoRoutineSchedule+0x12e>
     32e:	3b c0       	rjmp	.+118    	; 0x3a6 <vCoRoutineSchedule+0x188>
		}

		/* See if this tick has made a timeout expire. */
		while( listLIST_IS_EMPTY( pxDelayedCoRoutineList ) == pdFALSE )
		{
			pxCRCB = ( corCRCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedCoRoutineList );
     330:	05 80       	ldd	r0, Z+5	; 0x05
     332:	f6 81       	ldd	r31, Z+6	; 0x06
     334:	e0 2d       	mov	r30, r0
     336:	c6 81       	ldd	r28, Z+6	; 0x06
     338:	d7 81       	ldd	r29, Z+7	; 0x07

			if( xCoRoutineTickCount < listGET_LIST_ITEM_VALUE( &( pxCRCB->xGenericListItem ) ) )				
     33a:	2a 81       	ldd	r18, Y+2	; 0x02
     33c:	3b 81       	ldd	r19, Y+3	; 0x03
     33e:	80 91 c0 00 	lds	r24, 0x00C0
     342:	90 91 c1 00 	lds	r25, 0x00C1
     346:	82 17       	cp	r24, r18
     348:	93 07       	cpc	r25, r19
     34a:	68 f1       	brcs	.+90     	; 0x3a6 <vCoRoutineSchedule+0x188>
			{			
				/* Timeout not yet expired. */																			
				break;																				
			}																						

			portDISABLE_INTERRUPTS();
     34c:	f8 94       	cli
				/* The event could have occurred just before this critical
				section.  If this is the case then the generic list item will
				have been moved to the pending ready list and the following
				line is still valid.  Also the pvContainer parameter will have
				been set to NULL so the following lines are also valid. */
				vListRemove( &( pxCRCB->xGenericListItem ) );											
     34e:	8e 01       	movw	r16, r28
     350:	0e 5f       	subi	r16, 0xFE	; 254
     352:	1f 4f       	sbci	r17, 0xFF	; 255
     354:	c8 01       	movw	r24, r16
     356:	0e 94 ab 03 	call	0x756	; 0x756 <vListRemove>

				/* Is the co-routine waiting on an event also? */												
				if( pxCRCB->xEventListItem.pvContainer )													
     35a:	8c 89       	ldd	r24, Y+20	; 0x14
     35c:	9d 89       	ldd	r25, Y+21	; 0x15
     35e:	00 97       	sbiw	r24, 0x00	; 0
     360:	21 f0       	breq	.+8      	; 0x36a <vCoRoutineSchedule+0x14c>
				{															
					vListRemove( &( pxCRCB->xEventListItem ) );											
     362:	ce 01       	movw	r24, r28
     364:	0c 96       	adiw	r24, 0x0c	; 12
     366:	0e 94 ab 03 	call	0x756	; 0x756 <vListRemove>
				}
			}
			portENABLE_INTERRUPTS();
     36a:	78 94       	sei

			prvAddCoRoutineToReadyQueue( pxCRCB );													
     36c:	8e 89       	ldd	r24, Y+22	; 0x16
     36e:	90 91 8e 00 	lds	r25, 0x008E
     372:	98 17       	cp	r25, r24
     374:	10 f4       	brcc	.+4      	; 0x37a <vCoRoutineSchedule+0x15c>
     376:	80 93 8e 00 	sts	0x008E, r24
     37a:	90 e0       	ldi	r25, 0x00	; 0
     37c:	9c 01       	movw	r18, r24
     37e:	22 0f       	add	r18, r18
     380:	33 1f       	adc	r19, r19
     382:	22 0f       	add	r18, r18
     384:	33 1f       	adc	r19, r19
     386:	22 0f       	add	r18, r18
     388:	33 1f       	adc	r19, r19
     38a:	82 0f       	add	r24, r18
     38c:	93 1f       	adc	r25, r19
     38e:	81 57       	subi	r24, 0x71	; 113
     390:	9f 4f       	sbci	r25, 0xFF	; 255
     392:	b8 01       	movw	r22, r16
     394:	0e 94 45 03 	call	0x68a	; 0x68a <vListInsertEnd>
			pxDelayedCoRoutineList = pxOverflowDelayedCoRoutineList;
			pxOverflowDelayedCoRoutineList = pxTemp;
		}

		/* See if this tick has made a timeout expire. */
		while( listLIST_IS_EMPTY( pxDelayedCoRoutineList ) == pdFALSE )
     398:	e0 91 bc 00 	lds	r30, 0x00BC
     39c:	f0 91 bd 00 	lds	r31, 0x00BD
     3a0:	80 81       	ld	r24, Z
     3a2:	88 23       	and	r24, r24
     3a4:	29 f6       	brne	.-118    	; 0x330 <vCoRoutineSchedule+0x112>
static void prvCheckDelayedList( void )
{
corCRCB *pxCRCB;

	xPassedTicks = xTaskGetTickCount() - xLastTickCount;
	while( xPassedTicks )
     3a6:	80 91 c4 00 	lds	r24, 0x00C4
     3aa:	90 91 c5 00 	lds	r25, 0x00C5
     3ae:	00 97       	sbiw	r24, 0x00	; 0
     3b0:	09 f0       	breq	.+2      	; 0x3b4 <vCoRoutineSchedule+0x196>
     3b2:	85 cf       	rjmp	.-246    	; 0x2be <vCoRoutineSchedule+0xa0>

			prvAddCoRoutineToReadyQueue( pxCRCB );													
		}																									
	}

	xLastTickCount = xCoRoutineTickCount;
     3b4:	80 91 c0 00 	lds	r24, 0x00C0
     3b8:	90 91 c1 00 	lds	r25, 0x00C1
     3bc:	90 93 c3 00 	sts	0x00C3, r25
     3c0:	80 93 c2 00 	sts	0x00C2, r24

	/* See if any delayed co-routines have timed out. */
	prvCheckDelayedList();

	/* Find the highest priority queue that contains ready co-routines. */
	while( listLIST_IS_EMPTY( &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) ) )
     3c4:	20 91 8e 00 	lds	r18, 0x008E
     3c8:	82 2f       	mov	r24, r18
     3ca:	90 e0       	ldi	r25, 0x00	; 0
     3cc:	fc 01       	movw	r30, r24
     3ce:	ee 0f       	add	r30, r30
     3d0:	ff 1f       	adc	r31, r31
     3d2:	ee 0f       	add	r30, r30
     3d4:	ff 1f       	adc	r31, r31
     3d6:	ee 0f       	add	r30, r30
     3d8:	ff 1f       	adc	r31, r31
     3da:	e8 0f       	add	r30, r24
     3dc:	f9 1f       	adc	r31, r25
     3de:	e1 57       	subi	r30, 0x71	; 113
     3e0:	ff 4f       	sbci	r31, 0xFF	; 255
     3e2:	30 81       	ld	r19, Z
     3e4:	33 23       	and	r19, r19
     3e6:	d9 f4       	brne	.+54     	; 0x41e <vCoRoutineSchedule+0x200>
	{
		if( uxTopCoRoutineReadyPriority == 0 )
     3e8:	22 23       	and	r18, r18
     3ea:	31 f4       	brne	.+12     	; 0x3f8 <vCoRoutineSchedule+0x1da>
     3ec:	47 c0       	rjmp	.+142    	; 0x47c <vCoRoutineSchedule+0x25e>
     3ee:	22 23       	and	r18, r18
     3f0:	19 f4       	brne	.+6      	; 0x3f8 <vCoRoutineSchedule+0x1da>
     3f2:	20 93 8e 00 	sts	0x008E, r18
     3f6:	42 c0       	rjmp	.+132    	; 0x47c <vCoRoutineSchedule+0x25e>
		{
			/* No more co-routines to check. */
			return;
		}
		--uxTopCoRoutineReadyPriority;
     3f8:	21 50       	subi	r18, 0x01	; 1

	/* See if any delayed co-routines have timed out. */
	prvCheckDelayedList();

	/* Find the highest priority queue that contains ready co-routines. */
	while( listLIST_IS_EMPTY( &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) ) )
     3fa:	82 2f       	mov	r24, r18
     3fc:	90 e0       	ldi	r25, 0x00	; 0
     3fe:	fc 01       	movw	r30, r24
     400:	ee 0f       	add	r30, r30
     402:	ff 1f       	adc	r31, r31
     404:	ee 0f       	add	r30, r30
     406:	ff 1f       	adc	r31, r31
     408:	ee 0f       	add	r30, r30
     40a:	ff 1f       	adc	r31, r31
     40c:	e8 0f       	add	r30, r24
     40e:	f9 1f       	adc	r31, r25
     410:	e1 57       	subi	r30, 0x71	; 113
     412:	ff 4f       	sbci	r31, 0xFF	; 255
     414:	30 81       	ld	r19, Z
     416:	33 23       	and	r19, r19
     418:	51 f3       	breq	.-44     	; 0x3ee <vCoRoutineSchedule+0x1d0>
     41a:	20 93 8e 00 	sts	0x008E, r18
		--uxTopCoRoutineReadyPriority;
	}

	/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the co-routines
	 of the	same priority get an equal share of the processor time. */
	listGET_OWNER_OF_NEXT_ENTRY( pxCurrentCoRoutine, &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) );
     41e:	fc 01       	movw	r30, r24
     420:	ee 0f       	add	r30, r30
     422:	ff 1f       	adc	r31, r31
     424:	ee 0f       	add	r30, r30
     426:	ff 1f       	adc	r31, r31
     428:	ee 0f       	add	r30, r30
     42a:	ff 1f       	adc	r31, r31
     42c:	8e 0f       	add	r24, r30
     42e:	9f 1f       	adc	r25, r31
     430:	fc 01       	movw	r30, r24
     432:	e1 57       	subi	r30, 0x71	; 113
     434:	ff 4f       	sbci	r31, 0xFF	; 255
     436:	a1 81       	ldd	r26, Z+1	; 0x01
     438:	b2 81       	ldd	r27, Z+2	; 0x02
     43a:	12 96       	adiw	r26, 0x02	; 2
     43c:	0d 90       	ld	r0, X+
     43e:	bc 91       	ld	r27, X
     440:	a0 2d       	mov	r26, r0
     442:	b2 83       	std	Z+2, r27	; 0x02
     444:	a1 83       	std	Z+1, r26	; 0x01
     446:	cf 01       	movw	r24, r30
     448:	03 96       	adiw	r24, 0x03	; 3
     44a:	a8 17       	cp	r26, r24
     44c:	b9 07       	cpc	r27, r25
     44e:	31 f4       	brne	.+12     	; 0x45c <vCoRoutineSchedule+0x23e>
     450:	12 96       	adiw	r26, 0x02	; 2
     452:	8d 91       	ld	r24, X+
     454:	9c 91       	ld	r25, X
     456:	13 97       	sbiw	r26, 0x03	; 3
     458:	92 83       	std	Z+2, r25	; 0x02
     45a:	81 83       	std	Z+1, r24	; 0x01
     45c:	01 80       	ldd	r0, Z+1	; 0x01
     45e:	f2 81       	ldd	r31, Z+2	; 0x02
     460:	e0 2d       	mov	r30, r0
     462:	a6 81       	ldd	r26, Z+6	; 0x06
     464:	b7 81       	ldd	r27, Z+7	; 0x07
     466:	b0 93 8d 00 	sts	0x008D, r27
     46a:	a0 93 8c 00 	sts	0x008C, r26

	/* Call the co-routine. */
	( pxCurrentCoRoutine->pxCoRoutineFunction )( pxCurrentCoRoutine, pxCurrentCoRoutine->uxIndex );
     46e:	ed 91       	ld	r30, X+
     470:	fc 91       	ld	r31, X
     472:	11 97       	sbiw	r26, 0x01	; 1
     474:	cd 01       	movw	r24, r26
     476:	57 96       	adiw	r26, 0x17	; 23
     478:	6c 91       	ld	r22, X
     47a:	09 95       	icall

	return;
}
     47c:	df 91       	pop	r29
     47e:	cf 91       	pop	r28
     480:	1f 91       	pop	r17
     482:	0f 91       	pop	r16
     484:	ff 90       	pop	r15
     486:	ef 90       	pop	r14
     488:	df 90       	pop	r13
     48a:	cf 90       	pop	r12
     48c:	08 95       	ret

0000048e <xCoRoutineRemoveFromEventList>:
	pxOverflowDelayedCoRoutineList = &xDelayedCoRoutineList2;
}
/*-----------------------------------------------------------*/

signed portBASE_TYPE xCoRoutineRemoveFromEventList( const xList *pxEventList )
{
     48e:	0f 93       	push	r16
     490:	1f 93       	push	r17
     492:	cf 93       	push	r28
     494:	df 93       	push	r29
signed portBASE_TYPE xReturn;

	/* This function is called from within an interrupt.  It can only access
	event lists and the pending ready list.  This function assumes that a
	check has already been made to ensure pxEventList is not empty. */
	pxUnblockedCRCB = ( corCRCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
     496:	dc 01       	movw	r26, r24
     498:	15 96       	adiw	r26, 0x05	; 5
     49a:	ed 91       	ld	r30, X+
     49c:	fc 91       	ld	r31, X
     49e:	16 97       	sbiw	r26, 0x06	; 6
     4a0:	06 81       	ldd	r16, Z+6	; 0x06
     4a2:	17 81       	ldd	r17, Z+7	; 0x07
	vListRemove( &( pxUnblockedCRCB->xEventListItem ) );
     4a4:	e8 01       	movw	r28, r16
     4a6:	2c 96       	adiw	r28, 0x0c	; 12
     4a8:	ce 01       	movw	r24, r28
     4aa:	0e 94 ab 03 	call	0x756	; 0x756 <vListRemove>
	vListInsertEnd( ( xList * ) &( xPendingReadyCoRoutineList ), &( pxUnblockedCRCB->xEventListItem ) );
     4ae:	83 eb       	ldi	r24, 0xB3	; 179
     4b0:	90 e0       	ldi	r25, 0x00	; 0
     4b2:	be 01       	movw	r22, r28
     4b4:	0e 94 45 03 	call	0x68a	; 0x68a <vListInsertEnd>

	if( pxUnblockedCRCB->uxPriority >= pxCurrentCoRoutine->uxPriority )
     4b8:	e0 91 8c 00 	lds	r30, 0x008C
     4bc:	f0 91 8d 00 	lds	r31, 0x008D
	{
		xReturn = pdTRUE;
     4c0:	81 e0       	ldi	r24, 0x01	; 1
     4c2:	d8 01       	movw	r26, r16
     4c4:	56 96       	adiw	r26, 0x16	; 22
     4c6:	2c 91       	ld	r18, X
     4c8:	56 97       	sbiw	r26, 0x16	; 22
     4ca:	96 89       	ldd	r25, Z+22	; 0x16
     4cc:	29 17       	cp	r18, r25
     4ce:	08 f4       	brcc	.+2      	; 0x4d2 <xCoRoutineRemoveFromEventList+0x44>
     4d0:	80 e0       	ldi	r24, 0x00	; 0
	{
		xReturn = pdFALSE;
	}

	return xReturn;
}
     4d2:	df 91       	pop	r29
     4d4:	cf 91       	pop	r28
     4d6:	1f 91       	pop	r17
     4d8:	0f 91       	pop	r16
     4da:	08 95       	ret

000004dc <pvPortMalloc>:

static size_t xNextFreeByte = ( size_t ) 0;
/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
     4dc:	0f 93       	push	r16
     4de:	1f 93       	push	r17
     4e0:	cf 93       	push	r28
     4e2:	df 93       	push	r29
     4e4:	ec 01       	movw	r28, r24
			/* Byte alignment required. */
			xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
		}
	#endif

	vTaskSuspendAll();
     4e6:	0e 94 61 0a 	call	0x14c2	; 0x14c2 <vTaskSuspendAll>
	{
		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configTOTAL_HEAP_SIZE ) &&
     4ea:	00 91 c6 00 	lds	r16, 0x00C6
     4ee:	10 91 c7 00 	lds	r17, 0x00C7
     4f2:	c0 0f       	add	r28, r16
     4f4:	d1 1f       	adc	r29, r17
     4f6:	82 e0       	ldi	r24, 0x02	; 2
     4f8:	c8 35       	cpi	r28, 0x58	; 88
     4fa:	d8 07       	cpc	r29, r24
     4fc:	50 f4       	brcc	.+20     	; 0x512 <pvPortMalloc+0x36>
     4fe:	0c 17       	cp	r16, r28
     500:	1d 07       	cpc	r17, r29
     502:	50 f4       	brcc	.+20     	; 0x518 <pvPortMalloc+0x3c>
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
		{
			/* Return the next free byte then increment the index past this
			block. */
			pvReturn = &( xHeap.ucHeap[ xNextFreeByte ] );
     504:	08 53       	subi	r16, 0x38	; 56
     506:	1f 4f       	sbci	r17, 0xFF	; 255
			xNextFreeByte += xWantedSize;			
     508:	d0 93 c7 00 	sts	0x00C7, r29
     50c:	c0 93 c6 00 	sts	0x00C6, r28
     510:	05 c0       	rjmp	.+10     	; 0x51c <pvPortMalloc+0x40>
static size_t xNextFreeByte = ( size_t ) 0;
/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
void *pvReturn = NULL; 
     512:	00 e0       	ldi	r16, 0x00	; 0
     514:	10 e0       	ldi	r17, 0x00	; 0
     516:	02 c0       	rjmp	.+4      	; 0x51c <pvPortMalloc+0x40>
     518:	00 e0       	ldi	r16, 0x00	; 0
     51a:	10 e0       	ldi	r17, 0x00	; 0
			block. */
			pvReturn = &( xHeap.ucHeap[ xNextFreeByte ] );
			xNextFreeByte += xWantedSize;			
		}	
	}
	xTaskResumeAll();
     51c:	0e 94 3f 0b 	call	0x167e	; 0x167e <xTaskResumeAll>
		}
	}
	#endif	

	return pvReturn;
}
     520:	80 2f       	mov	r24, r16
     522:	91 2f       	mov	r25, r17
     524:	df 91       	pop	r29
     526:	cf 91       	pop	r28
     528:	1f 91       	pop	r17
     52a:	0f 91       	pop	r16
     52c:	08 95       	ret

0000052e <vPortFree>:
{
	/* Memory cannot be freed using this scheme.  See heap_2.c and heap_3.c 
	for alternative implementations, and the memory management pages of 
	http://www.FreeRTOS.org for more information. */
	( void ) pv;
}
     52e:	08 95       	ret

00000530 <vPortInitialiseBlocks>:
/*-----------------------------------------------------------*/

void vPortInitialiseBlocks( void )
{
	/* Only required when static memory is not cleared. */
	xNextFreeByte = ( size_t ) 0;
     530:	10 92 c7 00 	sts	0x00C7, r1
     534:	10 92 c6 00 	sts	0x00C6, r1
}
     538:	08 95       	ret

0000053a <xPortGetFreeHeapSize>:
/*-----------------------------------------------------------*/

size_t xPortGetFreeHeapSize( void )
{
	return ( configTOTAL_HEAP_SIZE - xNextFreeByte );
     53a:	20 91 c6 00 	lds	r18, 0x00C6
     53e:	30 91 c7 00 	lds	r19, 0x00C7
     542:	88 e5       	ldi	r24, 0x58	; 88
     544:	92 e0       	ldi	r25, 0x02	; 2
     546:	82 1b       	sub	r24, r18
     548:	93 0b       	sbc	r25, r19
}
     54a:	08 95       	ret

0000054c <enableTrigger>:
//   data changes.
////////////////////////////////////////////////////////////////////
void enableTrigger(void)
{

	CLR_BIT(PORTB,2);
     54c:	c2 98       	cbi	0x18, 2	; 24
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
     54e:	89 ef       	ldi	r24, 0xF9	; 249
     550:	90 e0       	ldi	r25, 0x00	; 0
     552:	01 97       	sbiw	r24, 0x01	; 1
     554:	f1 f7       	brne	.-4      	; 0x552 <enableTrigger+0x6>
     556:	00 c0       	rjmp	.+0      	; 0x558 <enableTrigger+0xc>
     558:	00 00       	nop
	
	_delay_ms(1);

	SET_BIT(PORTB,2);
     55a:	c2 9a       	sbi	0x18, 2	; 24
     55c:	8b ed       	ldi	r24, 0xDB	; 219
     55e:	95 e0       	ldi	r25, 0x05	; 5
     560:	01 97       	sbiw	r24, 0x01	; 1
     562:	f1 f7       	brne	.-4      	; 0x560 <enableTrigger+0x14>
     564:	00 c0       	rjmp	.+0      	; 0x566 <enableTrigger+0x1a>
     566:	00 00       	nop
	_delay_ms(6);


}
     568:	08 95       	ret

0000056a <lcd_sendCommand>:
		
}


void lcd_sendCommand(unsigned char cmd)
{
     56a:	cf 93       	push	r28
     56c:	c8 2f       	mov	r28, r24
	unsigned char high_nibble , low_nibble ; 		
	
	HIGH_NIBBLE(high_nibble,cmd);
	LOW_NIBBLE(low_nibble,cmd);

	CLR_BIT(PORTB,0); // to enable command mode 
     56e:	c0 98       	cbi	0x18, 0	; 24
	CLR_BIT(PORTB,1); // write signal to lcd 
     570:	c1 98       	cbi	0x18, 1	; 24

	PORTB &=0x0f;
     572:	88 b3       	in	r24, 0x18	; 24
     574:	8f 70       	andi	r24, 0x0F	; 15
     576:	88 bb       	out	0x18, r24	; 24
	PORTB |=high_nibble;// to send high nibble command  
     578:	88 b3       	in	r24, 0x18	; 24
void lcd_sendCommand(unsigned char cmd)
{

	unsigned char high_nibble , low_nibble ; 		
	
	HIGH_NIBBLE(high_nibble,cmd);
     57a:	9c 2f       	mov	r25, r28
     57c:	90 7f       	andi	r25, 0xF0	; 240

	CLR_BIT(PORTB,0); // to enable command mode 
	CLR_BIT(PORTB,1); // write signal to lcd 

	PORTB &=0x0f;
	PORTB |=high_nibble;// to send high nibble command  
     57e:	89 2b       	or	r24, r25
     580:	88 bb       	out	0x18, r24	; 24
	enableTrigger(); // triggre lcd enable 
     582:	0e 94 a6 02 	call	0x54c	; 0x54c <enableTrigger>

	PORTB &=0x0f;
     586:	88 b3       	in	r24, 0x18	; 24
     588:	8f 70       	andi	r24, 0x0F	; 15
     58a:	88 bb       	out	0x18, r24	; 24
	PORTB |=low_nibble; // to send low nibble command 
     58c:	88 b3       	in	r24, 0x18	; 24
{

	unsigned char high_nibble , low_nibble ; 		
	
	HIGH_NIBBLE(high_nibble,cmd);
	LOW_NIBBLE(low_nibble,cmd);
     58e:	c2 95       	swap	r28
     590:	c0 7f       	andi	r28, 0xF0	; 240
	PORTB &=0x0f;
	PORTB |=high_nibble;// to send high nibble command  
	enableTrigger(); // triggre lcd enable 

	PORTB &=0x0f;
	PORTB |=low_nibble; // to send low nibble command 
     592:	c8 2b       	or	r28, r24
     594:	c8 bb       	out	0x18, r28	; 24
	enableTrigger();
     596:	0e 94 a6 02 	call	0x54c	; 0x54c <enableTrigger>

}
     59a:	cf 91       	pop	r28
     59c:	08 95       	ret

0000059e <lcd_init>:
//							 and pinB.0 to pinB.2 o/p for control pins 
//////////////////////////////////////////////////////////////////////////////////////
void lcd_init(void)
{

	DDRB=0xff; // init port B as O/P port 
     59e:	8f ef       	ldi	r24, 0xFF	; 255
     5a0:	87 bb       	out	0x17, r24	; 23
	PORTB=0x04; // activate LCD enable 
     5a2:	84 e0       	ldi	r24, 0x04	; 4
     5a4:	88 bb       	out	0x18, r24	; 24

	lcd_sendCommand(0x33); // 4-bit mode 
     5a6:	83 e3       	ldi	r24, 0x33	; 51
     5a8:	0e 94 b5 02 	call	0x56a	; 0x56a <lcd_sendCommand>
	lcd_sendCommand (0x32);
     5ac:	82 e3       	ldi	r24, 0x32	; 50
     5ae:	0e 94 b5 02 	call	0x56a	; 0x56a <lcd_sendCommand>
	lcd_sendCommand (0x28);
     5b2:	88 e2       	ldi	r24, 0x28	; 40
     5b4:	0e 94 b5 02 	call	0x56a	; 0x56a <lcd_sendCommand>



	lcd_sendCommand(0x0c); // turn on lcd 
     5b8:	8c e0       	ldi	r24, 0x0C	; 12
     5ba:	0e 94 b5 02 	call	0x56a	; 0x56a <lcd_sendCommand>

		
}
     5be:	08 95       	ret

000005c0 <lcd_displayChar>:
	enableTrigger();

}

void lcd_displayChar (unsigned char data)
{
     5c0:	cf 93       	push	r28
     5c2:	c8 2f       	mov	r28, r24

	unsigned char high_nibble , low_nibble ;

	SET_BIT(PORTB,0); //  enable data mode 
     5c4:	c0 9a       	sbi	0x18, 0	; 24
	CLR_BIT(PORTB,1); // activate lcd write 
     5c6:	c1 98       	cbi	0x18, 1	; 24

	HIGH_NIBBLE(high_nibble,data); // get high nibble data 
	LOW_NIBBLE(low_nibble,data); // get low nibble data 
	
	PORTB &= 0x0f;
     5c8:	88 b3       	in	r24, 0x18	; 24
     5ca:	8f 70       	andi	r24, 0x0F	; 15
     5cc:	88 bb       	out	0x18, r24	; 24
	PORTB |=high_nibble;// to send high nibble data  
     5ce:	88 b3       	in	r24, 0x18	; 24
	unsigned char high_nibble , low_nibble ;

	SET_BIT(PORTB,0); //  enable data mode 
	CLR_BIT(PORTB,1); // activate lcd write 

	HIGH_NIBBLE(high_nibble,data); // get high nibble data 
     5d0:	9c 2f       	mov	r25, r28
     5d2:	90 7f       	andi	r25, 0xF0	; 240
	LOW_NIBBLE(low_nibble,data); // get low nibble data 
	
	PORTB &= 0x0f;
	PORTB |=high_nibble;// to send high nibble data  
     5d4:	89 2b       	or	r24, r25
     5d6:	88 bb       	out	0x18, r24	; 24
	enableTrigger(); // triggre lcd enable 
     5d8:	0e 94 a6 02 	call	0x54c	; 0x54c <enableTrigger>
	
	PORTB &=0x0f;
     5dc:	88 b3       	in	r24, 0x18	; 24
     5de:	8f 70       	andi	r24, 0x0F	; 15
     5e0:	88 bb       	out	0x18, r24	; 24
	PORTB |=low_nibble; // to send low nibble data 
     5e2:	88 b3       	in	r24, 0x18	; 24

	SET_BIT(PORTB,0); //  enable data mode 
	CLR_BIT(PORTB,1); // activate lcd write 

	HIGH_NIBBLE(high_nibble,data); // get high nibble data 
	LOW_NIBBLE(low_nibble,data); // get low nibble data 
     5e4:	c2 95       	swap	r28
     5e6:	c0 7f       	andi	r28, 0xF0	; 240
	PORTB &= 0x0f;
	PORTB |=high_nibble;// to send high nibble data  
	enableTrigger(); // triggre lcd enable 
	
	PORTB &=0x0f;
	PORTB |=low_nibble; // to send low nibble data 
     5e8:	c8 2b       	or	r28, r24
     5ea:	c8 bb       	out	0x18, r28	; 24
	enableTrigger();
     5ec:	0e 94 a6 02 	call	0x54c	; 0x54c <enableTrigger>
	

}
     5f0:	cf 91       	pop	r28
     5f2:	08 95       	ret

000005f4 <lcd_gotoxy>:

void lcd_gotoxy(unsigned char y , unsigned char x )
{
	unsigned char position = 0x80;
	 
	switch(y)
     5f4:	81 30       	cpi	r24, 0x01	; 1
     5f6:	51 f0       	breq	.+20     	; 0x60c <lcd_gotoxy+0x18>
     5f8:	81 30       	cpi	r24, 0x01	; 1
     5fa:	28 f0       	brcs	.+10     	; 0x606 <lcd_gotoxy+0x12>
     5fc:	82 30       	cpi	r24, 0x02	; 2
     5fe:	49 f0       	breq	.+18     	; 0x612 <lcd_gotoxy+0x1e>
     600:	83 30       	cpi	r24, 0x03	; 3
     602:	69 f4       	brne	.+26     	; 0x61e <lcd_gotoxy+0x2a>
     604:	09 c0       	rjmp	.+18     	; 0x618 <lcd_gotoxy+0x24>
	{
		case 0:

			position=position+x;
     606:	86 2f       	mov	r24, r22
     608:	80 58       	subi	r24, 0x80	; 128
					
		break;
     60a:	0a c0       	rjmp	.+20     	; 0x620 <lcd_gotoxy+0x2c>

		case 1:

			position=0xc0;
			position=position+x;
     60c:	86 2f       	mov	r24, r22
     60e:	80 54       	subi	r24, 0x40	; 64

		break;
     610:	07 c0       	rjmp	.+14     	; 0x620 <lcd_gotoxy+0x2c>

		case 2:

			position=position+x;
     612:	86 2f       	mov	r24, r22
     614:	80 58       	subi	r24, 0x80	; 128

		break;
     616:	04 c0       	rjmp	.+8      	; 0x620 <lcd_gotoxy+0x2c>

		case 3:
			position=position+x;
     618:	86 2f       	mov	r24, r22
     61a:	80 58       	subi	r24, 0x80	; 128
		break;
     61c:	01 c0       	rjmp	.+2      	; 0x620 <lcd_gotoxy+0x2c>
}


void lcd_gotoxy(unsigned char y , unsigned char x )
{
	unsigned char position = 0x80;
     61e:	80 e8       	ldi	r24, 0x80	; 128
		break;
	
	
	}
	
	lcd_sendCommand(position); 	
     620:	0e 94 b5 02 	call	0x56a	; 0x56a <lcd_sendCommand>


}
     624:	08 95       	ret

00000626 <lcd_clrScreen>:


void lcd_clrScreen(void)
{

	lcd_sendCommand(0x01);
     626:	81 e0       	ldi	r24, 0x01	; 1
     628:	0e 94 b5 02 	call	0x56a	; 0x56a <lcd_sendCommand>


}
     62c:	08 95       	ret

0000062e <lcd_dispString>:


void lcd_dispString(char * ptr)
{
     62e:	cf 93       	push	r28
     630:	df 93       	push	r29
     632:	ec 01       	movw	r28, r24

	while(* ptr!= '\0')
     634:	88 81       	ld	r24, Y
     636:	88 23       	and	r24, r24
     638:	31 f0       	breq	.+12     	; 0x646 <lcd_dispString+0x18>


}


void lcd_dispString(char * ptr)
     63a:	21 96       	adiw	r28, 0x01	; 1
{

	while(* ptr!= '\0')
	{
		lcd_displayChar(* ptr);
     63c:	0e 94 e0 02 	call	0x5c0	; 0x5c0 <lcd_displayChar>


void lcd_dispString(char * ptr)
{

	while(* ptr!= '\0')
     640:	89 91       	ld	r24, Y+
     642:	88 23       	and	r24, r24
     644:	d9 f7       	brne	.-10     	; 0x63c <lcd_dispString+0xe>
	
	}



}
     646:	df 91       	pop	r29
     648:	cf 91       	pop	r28
     64a:	08 95       	ret

0000064c <lcd_disp_string_xy>:

void lcd_disp_string_xy(char * ptr , int y , int x)
{
     64c:	cf 93       	push	r28
     64e:	df 93       	push	r29
     650:	ec 01       	movw	r28, r24
     652:	86 2f       	mov	r24, r22

	lcd_gotoxy(y,x);
     654:	64 2f       	mov	r22, r20
     656:	0e 94 fa 02 	call	0x5f4	; 0x5f4 <lcd_gotoxy>
	lcd_dispString(ptr);
     65a:	ce 01       	movw	r24, r28
     65c:	0e 94 17 03 	call	0x62e	; 0x62e <lcd_dispString>

	


}
     660:	df 91       	pop	r29
     662:	cf 91       	pop	r28
     664:	08 95       	ret

00000666 <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( xList *pxList )
{
     666:	fc 01       	movw	r30, r24
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( xListItem * ) &( pxList->xListEnd );
     668:	03 96       	adiw	r24, 0x03	; 3
     66a:	92 83       	std	Z+2, r25	; 0x02
     66c:	81 83       	std	Z+1, r24	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
     66e:	2f ef       	ldi	r18, 0xFF	; 255
     670:	3f ef       	ldi	r19, 0xFF	; 255
     672:	34 83       	std	Z+4, r19	; 0x04
     674:	23 83       	std	Z+3, r18	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( xListItem * ) &( pxList->xListEnd );
     676:	96 83       	std	Z+6, r25	; 0x06
     678:	85 83       	std	Z+5, r24	; 0x05
	pxList->xListEnd.pxPrevious = ( xListItem * ) &( pxList->xListEnd );
     67a:	90 87       	std	Z+8, r25	; 0x08
     67c:	87 83       	std	Z+7, r24	; 0x07

	pxList->uxNumberOfItems = ( unsigned portBASE_TYPE ) 0U;
     67e:	10 82       	st	Z, r1
}
     680:	08 95       	ret

00000682 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( xListItem *pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
     682:	fc 01       	movw	r30, r24
     684:	11 86       	std	Z+9, r1	; 0x09
     686:	10 86       	std	Z+8, r1	; 0x08
}
     688:	08 95       	ret

0000068a <vListInsertEnd>:
/*-----------------------------------------------------------*/

void vListInsertEnd( xList *pxList, xListItem *pxNewListItem )
{
     68a:	cf 93       	push	r28
     68c:	df 93       	push	r29
     68e:	ec 01       	movw	r28, r24
     690:	fb 01       	movw	r30, r22

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	pvListGetOwnerOfNextEntry.  This means it has to be the item pointed to by
	the pxIndex member. */
	pxIndex = pxList->pxIndex;
     692:	89 81       	ldd	r24, Y+1	; 0x01
     694:	9a 81       	ldd	r25, Y+2	; 0x02

	pxNewListItem->pxNext = pxIndex->pxNext;
     696:	dc 01       	movw	r26, r24
     698:	12 96       	adiw	r26, 0x02	; 2
     69a:	2d 91       	ld	r18, X+
     69c:	3c 91       	ld	r19, X
     69e:	13 97       	sbiw	r26, 0x03	; 3
     6a0:	33 83       	std	Z+3, r19	; 0x03
     6a2:	22 83       	std	Z+2, r18	; 0x02
	pxNewListItem->pxPrevious = pxList->pxIndex;
     6a4:	29 81       	ldd	r18, Y+1	; 0x01
     6a6:	3a 81       	ldd	r19, Y+2	; 0x02
     6a8:	35 83       	std	Z+5, r19	; 0x05
     6aa:	24 83       	std	Z+4, r18	; 0x04
	pxIndex->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
     6ac:	12 96       	adiw	r26, 0x02	; 2
     6ae:	2d 91       	ld	r18, X+
     6b0:	3c 91       	ld	r19, X
     6b2:	13 97       	sbiw	r26, 0x03	; 3
     6b4:	d9 01       	movw	r26, r18
     6b6:	15 96       	adiw	r26, 0x05	; 5
     6b8:	7c 93       	st	X, r23
     6ba:	6e 93       	st	-X, r22
     6bc:	14 97       	sbiw	r26, 0x04	; 4
	pxIndex->pxNext = ( volatile xListItem * ) pxNewListItem;
     6be:	dc 01       	movw	r26, r24
     6c0:	13 96       	adiw	r26, 0x03	; 3
     6c2:	7c 93       	st	X, r23
     6c4:	6e 93       	st	-X, r22
     6c6:	12 97       	sbiw	r26, 0x02	; 2
	pxList->pxIndex = ( volatile xListItem * ) pxNewListItem;
     6c8:	7a 83       	std	Y+2, r23	; 0x02
     6ca:	69 83       	std	Y+1, r22	; 0x01

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     6cc:	d1 87       	std	Z+9, r29	; 0x09
     6ce:	c0 87       	std	Z+8, r28	; 0x08

	( pxList->uxNumberOfItems )++;
     6d0:	88 81       	ld	r24, Y
     6d2:	8f 5f       	subi	r24, 0xFF	; 255
     6d4:	88 83       	st	Y, r24
}
     6d6:	df 91       	pop	r29
     6d8:	cf 91       	pop	r28
     6da:	08 95       	ret

000006dc <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( xList *pxList, xListItem *pxNewListItem )
{
     6dc:	cf 93       	push	r28
     6de:	df 93       	push	r29
     6e0:	ac 01       	movw	r20, r24
     6e2:	eb 01       	movw	r28, r22
volatile xListItem *pxIterator;
portTickType xValueOfInsertion;

	/* Insert the new list item into the list, sorted in ulListItem order. */
	xValueOfInsertion = pxNewListItem->xItemValue;
     6e4:	28 81       	ld	r18, Y
     6e6:	39 81       	ldd	r19, Y+1	; 0x01
	are stored in ready lists (all of which have the same ulListItem value)
	get an equal share of the CPU.  However, if the xItemValue is the same as
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
     6e8:	8f ef       	ldi	r24, 0xFF	; 255
     6ea:	2f 3f       	cpi	r18, 0xFF	; 255
     6ec:	38 07       	cpc	r19, r24
     6ee:	21 f4       	brne	.+8      	; 0x6f8 <vListInsert+0x1c>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
     6f0:	fa 01       	movw	r30, r20
     6f2:	a7 81       	ldd	r26, Z+7	; 0x07
     6f4:	b0 85       	ldd	r27, Z+8	; 0x08
     6f6:	18 c0       	rjmp	.+48     	; 0x728 <vListInsert+0x4c>
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		See http://www.freertos.org/FAQHelp.html for more tips.
		**********************************************************************/
		
		for( pxIterator = ( xListItem * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext )
     6f8:	da 01       	movw	r26, r20
     6fa:	13 96       	adiw	r26, 0x03	; 3
     6fc:	fa 01       	movw	r30, r20
     6fe:	85 81       	ldd	r24, Z+5	; 0x05
     700:	96 81       	ldd	r25, Z+6	; 0x06
     702:	fc 01       	movw	r30, r24
     704:	80 81       	ld	r24, Z
     706:	91 81       	ldd	r25, Z+1	; 0x01
     708:	28 17       	cp	r18, r24
     70a:	39 07       	cpc	r19, r25
     70c:	68 f0       	brcs	.+26     	; 0x728 <vListInsert+0x4c>
     70e:	12 96       	adiw	r26, 0x02	; 2
     710:	0d 90       	ld	r0, X+
     712:	bc 91       	ld	r27, X
     714:	a0 2d       	mov	r26, r0
     716:	12 96       	adiw	r26, 0x02	; 2
     718:	ed 91       	ld	r30, X+
     71a:	fc 91       	ld	r31, X
     71c:	13 97       	sbiw	r26, 0x03	; 3
     71e:	80 81       	ld	r24, Z
     720:	91 81       	ldd	r25, Z+1	; 0x01
     722:	28 17       	cp	r18, r24
     724:	39 07       	cpc	r19, r25
     726:	98 f7       	brcc	.-26     	; 0x70e <vListInsert+0x32>
			/* There is nothing to do here, we are just iterating to the
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
     728:	12 96       	adiw	r26, 0x02	; 2
     72a:	ed 91       	ld	r30, X+
     72c:	fc 91       	ld	r31, X
     72e:	13 97       	sbiw	r26, 0x03	; 3
     730:	fb 83       	std	Y+3, r31	; 0x03
     732:	ea 83       	std	Y+2, r30	; 0x02
	pxNewListItem->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
     734:	d5 83       	std	Z+5, r29	; 0x05
     736:	c4 83       	std	Z+4, r28	; 0x04
	pxNewListItem->pxPrevious = pxIterator;
     738:	bd 83       	std	Y+5, r27	; 0x05
     73a:	ac 83       	std	Y+4, r26	; 0x04
	pxIterator->pxNext = ( volatile xListItem * ) pxNewListItem;
     73c:	13 96       	adiw	r26, 0x03	; 3
     73e:	dc 93       	st	X, r29
     740:	ce 93       	st	-X, r28
     742:	12 97       	sbiw	r26, 0x02	; 2

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     744:	59 87       	std	Y+9, r21	; 0x09
     746:	48 87       	std	Y+8, r20	; 0x08

	( pxList->uxNumberOfItems )++;
     748:	fa 01       	movw	r30, r20
     74a:	80 81       	ld	r24, Z
     74c:	8f 5f       	subi	r24, 0xFF	; 255
     74e:	80 83       	st	Z, r24
}
     750:	df 91       	pop	r29
     752:	cf 91       	pop	r28
     754:	08 95       	ret

00000756 <vListRemove>:
/*-----------------------------------------------------------*/

void vListRemove( xListItem *pxItemToRemove )
{
     756:	fc 01       	movw	r30, r24
xList * pxList;

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
     758:	a2 81       	ldd	r26, Z+2	; 0x02
     75a:	b3 81       	ldd	r27, Z+3	; 0x03
     75c:	84 81       	ldd	r24, Z+4	; 0x04
     75e:	95 81       	ldd	r25, Z+5	; 0x05
     760:	15 96       	adiw	r26, 0x05	; 5
     762:	9c 93       	st	X, r25
     764:	8e 93       	st	-X, r24
     766:	14 97       	sbiw	r26, 0x04	; 4
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
     768:	a4 81       	ldd	r26, Z+4	; 0x04
     76a:	b5 81       	ldd	r27, Z+5	; 0x05
     76c:	82 81       	ldd	r24, Z+2	; 0x02
     76e:	93 81       	ldd	r25, Z+3	; 0x03
     770:	13 96       	adiw	r26, 0x03	; 3
     772:	9c 93       	st	X, r25
     774:	8e 93       	st	-X, r24
     776:	12 97       	sbiw	r26, 0x02	; 2
	
	/* The list item knows which list it is in.  Obtain the list from the list
	item. */
	pxList = ( xList * ) pxItemToRemove->pvContainer;
     778:	a0 85       	ldd	r26, Z+8	; 0x08
     77a:	b1 85       	ldd	r27, Z+9	; 0x09

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
     77c:	11 96       	adiw	r26, 0x01	; 1
     77e:	8d 91       	ld	r24, X+
     780:	9c 91       	ld	r25, X
     782:	12 97       	sbiw	r26, 0x02	; 2
     784:	8e 17       	cp	r24, r30
     786:	9f 07       	cpc	r25, r31
     788:	31 f4       	brne	.+12     	; 0x796 <vListRemove+0x40>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
     78a:	84 81       	ldd	r24, Z+4	; 0x04
     78c:	95 81       	ldd	r25, Z+5	; 0x05
     78e:	12 96       	adiw	r26, 0x02	; 2
     790:	9c 93       	st	X, r25
     792:	8e 93       	st	-X, r24
     794:	11 97       	sbiw	r26, 0x01	; 1
	}

	pxItemToRemove->pvContainer = NULL;
     796:	11 86       	std	Z+9, r1	; 0x09
     798:	10 86       	std	Z+8, r1	; 0x08
	( pxList->uxNumberOfItems )--;
     79a:	8c 91       	ld	r24, X
     79c:	81 50       	subi	r24, 0x01	; 1
     79e:	8c 93       	st	X, r24
}
     7a0:	08 95       	ret

000007a2 <pxPortInitialiseStack>:
unsigned short usAddress;

	/* Place a few bytes of known values on the bottom of the stack. 
	This is just useful for debugging. */

	*pxTopOfStack = 0x11;
     7a2:	21 e1       	ldi	r18, 0x11	; 17
     7a4:	fc 01       	movw	r30, r24
     7a6:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = 0x22;
     7a8:	31 97       	sbiw	r30, 0x01	; 1
     7aa:	32 e2       	ldi	r19, 0x22	; 34
     7ac:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = 0x33;
     7ae:	fc 01       	movw	r30, r24
     7b0:	32 97       	sbiw	r30, 0x02	; 2
     7b2:	a3 e3       	ldi	r26, 0x33	; 51
     7b4:	a0 83       	st	Z, r26
	/*lint -e950 -e611 -e923 Lint doesn't like this much - but nothing I can do about it. */

	/* The start of the task code will be popped off the stack last, so place
	it on first. */
	usAddress = ( unsigned short ) pxCode;
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned short ) 0x00ff );
     7b6:	fc 01       	movw	r30, r24
     7b8:	33 97       	sbiw	r30, 0x03	; 3
     7ba:	60 83       	st	Z, r22
	pxTopOfStack--;

	usAddress >>= 8;
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned short ) 0x00ff );
     7bc:	fc 01       	movw	r30, r24
     7be:	34 97       	sbiw	r30, 0x04	; 4
     7c0:	70 83       	st	Z, r23

	/* Next simulate the stack as if after a call to portSAVE_CONTEXT().  
	portSAVE_CONTEXT places the flags on the stack immediately after r0
	to ensure the interrupts get disabled as soon as possible, and so ensuring
	the stack use is minimal should a context switch interrupt occur. */
	*pxTopOfStack = ( portSTACK_TYPE ) 0x00;	/* R0 */
     7c2:	fc 01       	movw	r30, r24
     7c4:	35 97       	sbiw	r30, 0x05	; 5
     7c6:	10 82       	st	Z, r1
	pxTopOfStack--;
	*pxTopOfStack = portFLAGS_INT_ENABLED;
     7c8:	fc 01       	movw	r30, r24
     7ca:	36 97       	sbiw	r30, 0x06	; 6
     7cc:	60 e8       	ldi	r22, 0x80	; 128
     7ce:	60 83       	st	Z, r22
	pxTopOfStack--;


	/* Now the remaining registers.   The compiler expects R1 to be 0. */
	*pxTopOfStack = ( portSTACK_TYPE ) 0x00;	/* R1 */
     7d0:	fc 01       	movw	r30, r24
     7d2:	37 97       	sbiw	r30, 0x07	; 7
     7d4:	10 82       	st	Z, r1
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x02;	/* R2 */
     7d6:	fc 01       	movw	r30, r24
     7d8:	38 97       	sbiw	r30, 0x08	; 8
     7da:	62 e0       	ldi	r22, 0x02	; 2
     7dc:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x03;	/* R3 */
     7de:	fc 01       	movw	r30, r24
     7e0:	39 97       	sbiw	r30, 0x09	; 9
     7e2:	63 e0       	ldi	r22, 0x03	; 3
     7e4:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x04;	/* R4 */
     7e6:	fc 01       	movw	r30, r24
     7e8:	3a 97       	sbiw	r30, 0x0a	; 10
     7ea:	64 e0       	ldi	r22, 0x04	; 4
     7ec:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x05;	/* R5 */
     7ee:	fc 01       	movw	r30, r24
     7f0:	3b 97       	sbiw	r30, 0x0b	; 11
     7f2:	65 e0       	ldi	r22, 0x05	; 5
     7f4:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x06;	/* R6 */
     7f6:	fc 01       	movw	r30, r24
     7f8:	3c 97       	sbiw	r30, 0x0c	; 12
     7fa:	66 e0       	ldi	r22, 0x06	; 6
     7fc:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x07;	/* R7 */
     7fe:	fc 01       	movw	r30, r24
     800:	3d 97       	sbiw	r30, 0x0d	; 13
     802:	67 e0       	ldi	r22, 0x07	; 7
     804:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x08;	/* R8 */
     806:	fc 01       	movw	r30, r24
     808:	3e 97       	sbiw	r30, 0x0e	; 14
     80a:	68 e0       	ldi	r22, 0x08	; 8
     80c:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x09;	/* R9 */
     80e:	fc 01       	movw	r30, r24
     810:	3f 97       	sbiw	r30, 0x0f	; 15
     812:	69 e0       	ldi	r22, 0x09	; 9
     814:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x10;	/* R10 */
     816:	fc 01       	movw	r30, r24
     818:	70 97       	sbiw	r30, 0x10	; 16
     81a:	60 e1       	ldi	r22, 0x10	; 16
     81c:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x11;	/* R11 */
     81e:	fc 01       	movw	r30, r24
     820:	71 97       	sbiw	r30, 0x11	; 17
     822:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x12;	/* R12 */
     824:	fc 01       	movw	r30, r24
     826:	72 97       	sbiw	r30, 0x12	; 18
     828:	22 e1       	ldi	r18, 0x12	; 18
     82a:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x13;	/* R13 */
     82c:	fc 01       	movw	r30, r24
     82e:	73 97       	sbiw	r30, 0x13	; 19
     830:	23 e1       	ldi	r18, 0x13	; 19
     832:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x14;	/* R14 */
     834:	fc 01       	movw	r30, r24
     836:	74 97       	sbiw	r30, 0x14	; 20
     838:	24 e1       	ldi	r18, 0x14	; 20
     83a:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x15;	/* R15 */
     83c:	fc 01       	movw	r30, r24
     83e:	75 97       	sbiw	r30, 0x15	; 21
     840:	25 e1       	ldi	r18, 0x15	; 21
     842:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x16;	/* R16 */
     844:	fc 01       	movw	r30, r24
     846:	76 97       	sbiw	r30, 0x16	; 22
     848:	26 e1       	ldi	r18, 0x16	; 22
     84a:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x17;	/* R17 */
     84c:	fc 01       	movw	r30, r24
     84e:	77 97       	sbiw	r30, 0x17	; 23
     850:	27 e1       	ldi	r18, 0x17	; 23
     852:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x18;	/* R18 */
     854:	fc 01       	movw	r30, r24
     856:	78 97       	sbiw	r30, 0x18	; 24
     858:	28 e1       	ldi	r18, 0x18	; 24
     85a:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x19;	/* R19 */
     85c:	fc 01       	movw	r30, r24
     85e:	79 97       	sbiw	r30, 0x19	; 25
     860:	29 e1       	ldi	r18, 0x19	; 25
     862:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x20;	/* R20 */
     864:	fc 01       	movw	r30, r24
     866:	7a 97       	sbiw	r30, 0x1a	; 26
     868:	20 e2       	ldi	r18, 0x20	; 32
     86a:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x21;	/* R21 */
     86c:	fc 01       	movw	r30, r24
     86e:	7b 97       	sbiw	r30, 0x1b	; 27
     870:	21 e2       	ldi	r18, 0x21	; 33
     872:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x22;	/* R22 */
     874:	fc 01       	movw	r30, r24
     876:	7c 97       	sbiw	r30, 0x1c	; 28
     878:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x23;	/* R23 */
     87a:	fc 01       	movw	r30, r24
     87c:	7d 97       	sbiw	r30, 0x1d	; 29
     87e:	23 e2       	ldi	r18, 0x23	; 35
     880:	20 83       	st	Z, r18
	pxTopOfStack--;

	/* Place the parameter on the stack in the expected location. */
	usAddress = ( unsigned short ) pvParameters;
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned short ) 0x00ff );
     882:	fc 01       	movw	r30, r24
     884:	7e 97       	sbiw	r30, 0x1e	; 30
     886:	40 83       	st	Z, r20
	pxTopOfStack--;

	usAddress >>= 8;
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned short ) 0x00ff );
     888:	fc 01       	movw	r30, r24
     88a:	7f 97       	sbiw	r30, 0x1f	; 31
     88c:	50 83       	st	Z, r21
	pxTopOfStack--;

	*pxTopOfStack = ( portSTACK_TYPE ) 0x26;	/* R26 X */
     88e:	fc 01       	movw	r30, r24
     890:	b0 97       	sbiw	r30, 0x20	; 32
     892:	26 e2       	ldi	r18, 0x26	; 38
     894:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x27;	/* R27 */
     896:	fc 01       	movw	r30, r24
     898:	b1 97       	sbiw	r30, 0x21	; 33
     89a:	27 e2       	ldi	r18, 0x27	; 39
     89c:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x28;	/* R28 Y */
     89e:	fc 01       	movw	r30, r24
     8a0:	b2 97       	sbiw	r30, 0x22	; 34
     8a2:	28 e2       	ldi	r18, 0x28	; 40
     8a4:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x29;	/* R29 */
     8a6:	fc 01       	movw	r30, r24
     8a8:	b3 97       	sbiw	r30, 0x23	; 35
     8aa:	29 e2       	ldi	r18, 0x29	; 41
     8ac:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x30;	/* R30 Z */
     8ae:	fc 01       	movw	r30, r24
     8b0:	b4 97       	sbiw	r30, 0x24	; 36
     8b2:	20 e3       	ldi	r18, 0x30	; 48
     8b4:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x031;	/* R31 */
     8b6:	fc 01       	movw	r30, r24
     8b8:	b5 97       	sbiw	r30, 0x25	; 37
     8ba:	21 e3       	ldi	r18, 0x31	; 49
     8bc:	20 83       	st	Z, r18
	pxTopOfStack--;

	/*lint +e950 +e611 +e923 */

	return pxTopOfStack;
     8be:	86 97       	sbiw	r24, 0x26	; 38
}
     8c0:	08 95       	ret

000008c2 <xPortStartScheduler>:
	/* Setup compare match value for compare match A.  Interrupts are disabled 
	before this is called so we need not worry here. */
	ucLowByte = ( unsigned char ) ( ulCompareMatch & ( unsigned long ) 0xff );
	ulCompareMatch >>= 8;
	ucHighByte = ( unsigned char ) ( ulCompareMatch & ( unsigned long ) 0xff );
	OCR1AH = ucHighByte;
     8c2:	1b bc       	out	0x2b, r1	; 43
	OCR1AL = ucLowByte;
     8c4:	8c e7       	ldi	r24, 0x7C	; 124
     8c6:	8a bd       	out	0x2a, r24	; 42

	/* Setup clock source and compare match behaviour. */
	ucLowByte = portCLEAR_COUNTER_ON_MATCH | portPRESCALE_64;
	TCCR1B = ucLowByte;
     8c8:	8b e0       	ldi	r24, 0x0B	; 11
     8ca:	8e bd       	out	0x2e, r24	; 46

	/* Enable the interrupt - this is okay as interrupt are currently globally
	disabled. */
	ucLowByte = TIMSK;
     8cc:	89 b7       	in	r24, 0x39	; 57
	ucLowByte |= portCOMPARE_MATCH_A_INTERRUPT_ENABLE;
     8ce:	80 61       	ori	r24, 0x10	; 16
	TIMSK = ucLowByte;
     8d0:	89 bf       	out	0x39, r24	; 57
{
	/* Setup the hardware to generate the tick. */
	prvSetupTimerInterrupt();

	/* Restore the context of the first task that is going to run. */
	portRESTORE_CONTEXT();
     8d2:	a0 91 21 03 	lds	r26, 0x0321
     8d6:	b0 91 22 03 	lds	r27, 0x0322
     8da:	cd 91       	ld	r28, X+
     8dc:	cd bf       	out	0x3d, r28	; 61
     8de:	dd 91       	ld	r29, X+
     8e0:	de bf       	out	0x3e, r29	; 62
     8e2:	ff 91       	pop	r31
     8e4:	ef 91       	pop	r30
     8e6:	df 91       	pop	r29
     8e8:	cf 91       	pop	r28
     8ea:	bf 91       	pop	r27
     8ec:	af 91       	pop	r26
     8ee:	9f 91       	pop	r25
     8f0:	8f 91       	pop	r24
     8f2:	7f 91       	pop	r23
     8f4:	6f 91       	pop	r22
     8f6:	5f 91       	pop	r21
     8f8:	4f 91       	pop	r20
     8fa:	3f 91       	pop	r19
     8fc:	2f 91       	pop	r18
     8fe:	1f 91       	pop	r17
     900:	0f 91       	pop	r16
     902:	ff 90       	pop	r15
     904:	ef 90       	pop	r14
     906:	df 90       	pop	r13
     908:	cf 90       	pop	r12
     90a:	bf 90       	pop	r11
     90c:	af 90       	pop	r10
     90e:	9f 90       	pop	r9
     910:	8f 90       	pop	r8
     912:	7f 90       	pop	r7
     914:	6f 90       	pop	r6
     916:	5f 90       	pop	r5
     918:	4f 90       	pop	r4
     91a:	3f 90       	pop	r3
     91c:	2f 90       	pop	r2
     91e:	1f 90       	pop	r1
     920:	0f 90       	pop	r0
     922:	0f be       	out	0x3f, r0	; 63
     924:	0f 90       	pop	r0

	/* Simulate a function call end as generated by the compiler.  We will now
	jump to the start of the task the context of which we have just restored. */
	asm volatile ( "ret" );
     926:	08 95       	ret

	/* Should not get here. */
	return pdTRUE;
}
     928:	81 e0       	ldi	r24, 0x01	; 1
     92a:	08 95       	ret

0000092c <vPortEndScheduler>:

void vPortEndScheduler( void )
{
	/* It is unlikely that the AVR port will get stopped.  If required simply
	disable the tick interrupt here. */
}
     92c:	08 95       	ret

0000092e <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
     92e:	0f 92       	push	r0
     930:	0f b6       	in	r0, 0x3f	; 63
     932:	f8 94       	cli
     934:	0f 92       	push	r0
     936:	1f 92       	push	r1
     938:	11 24       	eor	r1, r1
     93a:	2f 92       	push	r2
     93c:	3f 92       	push	r3
     93e:	4f 92       	push	r4
     940:	5f 92       	push	r5
     942:	6f 92       	push	r6
     944:	7f 92       	push	r7
     946:	8f 92       	push	r8
     948:	9f 92       	push	r9
     94a:	af 92       	push	r10
     94c:	bf 92       	push	r11
     94e:	cf 92       	push	r12
     950:	df 92       	push	r13
     952:	ef 92       	push	r14
     954:	ff 92       	push	r15
     956:	0f 93       	push	r16
     958:	1f 93       	push	r17
     95a:	2f 93       	push	r18
     95c:	3f 93       	push	r19
     95e:	4f 93       	push	r20
     960:	5f 93       	push	r21
     962:	6f 93       	push	r22
     964:	7f 93       	push	r23
     966:	8f 93       	push	r24
     968:	9f 93       	push	r25
     96a:	af 93       	push	r26
     96c:	bf 93       	push	r27
     96e:	cf 93       	push	r28
     970:	df 93       	push	r29
     972:	ef 93       	push	r30
     974:	ff 93       	push	r31
     976:	a0 91 21 03 	lds	r26, 0x0321
     97a:	b0 91 22 03 	lds	r27, 0x0322
     97e:	0d b6       	in	r0, 0x3d	; 61
     980:	0d 92       	st	X+, r0
     982:	0e b6       	in	r0, 0x3e	; 62
     984:	0d 92       	st	X+, r0
	vTaskSwitchContext();
     986:	0e 94 6d 0c 	call	0x18da	; 0x18da <vTaskSwitchContext>
	portRESTORE_CONTEXT();
     98a:	a0 91 21 03 	lds	r26, 0x0321
     98e:	b0 91 22 03 	lds	r27, 0x0322
     992:	cd 91       	ld	r28, X+
     994:	cd bf       	out	0x3d, r28	; 61
     996:	dd 91       	ld	r29, X+
     998:	de bf       	out	0x3e, r29	; 62
     99a:	ff 91       	pop	r31
     99c:	ef 91       	pop	r30
     99e:	df 91       	pop	r29
     9a0:	cf 91       	pop	r28
     9a2:	bf 91       	pop	r27
     9a4:	af 91       	pop	r26
     9a6:	9f 91       	pop	r25
     9a8:	8f 91       	pop	r24
     9aa:	7f 91       	pop	r23
     9ac:	6f 91       	pop	r22
     9ae:	5f 91       	pop	r21
     9b0:	4f 91       	pop	r20
     9b2:	3f 91       	pop	r19
     9b4:	2f 91       	pop	r18
     9b6:	1f 91       	pop	r17
     9b8:	0f 91       	pop	r16
     9ba:	ff 90       	pop	r15
     9bc:	ef 90       	pop	r14
     9be:	df 90       	pop	r13
     9c0:	cf 90       	pop	r12
     9c2:	bf 90       	pop	r11
     9c4:	af 90       	pop	r10
     9c6:	9f 90       	pop	r9
     9c8:	8f 90       	pop	r8
     9ca:	7f 90       	pop	r7
     9cc:	6f 90       	pop	r6
     9ce:	5f 90       	pop	r5
     9d0:	4f 90       	pop	r4
     9d2:	3f 90       	pop	r3
     9d4:	2f 90       	pop	r2
     9d6:	1f 90       	pop	r1
     9d8:	0f 90       	pop	r0
     9da:	0f be       	out	0x3f, r0	; 63
     9dc:	0f 90       	pop	r0

	asm volatile ( "ret" );
     9de:	08 95       	ret

000009e0 <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
     9e0:	0f 92       	push	r0
     9e2:	0f b6       	in	r0, 0x3f	; 63
     9e4:	f8 94       	cli
     9e6:	0f 92       	push	r0
     9e8:	1f 92       	push	r1
     9ea:	11 24       	eor	r1, r1
     9ec:	2f 92       	push	r2
     9ee:	3f 92       	push	r3
     9f0:	4f 92       	push	r4
     9f2:	5f 92       	push	r5
     9f4:	6f 92       	push	r6
     9f6:	7f 92       	push	r7
     9f8:	8f 92       	push	r8
     9fa:	9f 92       	push	r9
     9fc:	af 92       	push	r10
     9fe:	bf 92       	push	r11
     a00:	cf 92       	push	r12
     a02:	df 92       	push	r13
     a04:	ef 92       	push	r14
     a06:	ff 92       	push	r15
     a08:	0f 93       	push	r16
     a0a:	1f 93       	push	r17
     a0c:	2f 93       	push	r18
     a0e:	3f 93       	push	r19
     a10:	4f 93       	push	r20
     a12:	5f 93       	push	r21
     a14:	6f 93       	push	r22
     a16:	7f 93       	push	r23
     a18:	8f 93       	push	r24
     a1a:	9f 93       	push	r25
     a1c:	af 93       	push	r26
     a1e:	bf 93       	push	r27
     a20:	cf 93       	push	r28
     a22:	df 93       	push	r29
     a24:	ef 93       	push	r30
     a26:	ff 93       	push	r31
     a28:	a0 91 21 03 	lds	r26, 0x0321
     a2c:	b0 91 22 03 	lds	r27, 0x0322
     a30:	0d b6       	in	r0, 0x3d	; 61
     a32:	0d 92       	st	X+, r0
     a34:	0e b6       	in	r0, 0x3e	; 62
     a36:	0d 92       	st	X+, r0
	vTaskIncrementTick();
     a38:	0e 94 79 0a 	call	0x14f2	; 0x14f2 <vTaskIncrementTick>
	vTaskSwitchContext();
     a3c:	0e 94 6d 0c 	call	0x18da	; 0x18da <vTaskSwitchContext>
	portRESTORE_CONTEXT();
     a40:	a0 91 21 03 	lds	r26, 0x0321
     a44:	b0 91 22 03 	lds	r27, 0x0322
     a48:	cd 91       	ld	r28, X+
     a4a:	cd bf       	out	0x3d, r28	; 61
     a4c:	dd 91       	ld	r29, X+
     a4e:	de bf       	out	0x3e, r29	; 62
     a50:	ff 91       	pop	r31
     a52:	ef 91       	pop	r30
     a54:	df 91       	pop	r29
     a56:	cf 91       	pop	r28
     a58:	bf 91       	pop	r27
     a5a:	af 91       	pop	r26
     a5c:	9f 91       	pop	r25
     a5e:	8f 91       	pop	r24
     a60:	7f 91       	pop	r23
     a62:	6f 91       	pop	r22
     a64:	5f 91       	pop	r21
     a66:	4f 91       	pop	r20
     a68:	3f 91       	pop	r19
     a6a:	2f 91       	pop	r18
     a6c:	1f 91       	pop	r17
     a6e:	0f 91       	pop	r16
     a70:	ff 90       	pop	r15
     a72:	ef 90       	pop	r14
     a74:	df 90       	pop	r13
     a76:	cf 90       	pop	r12
     a78:	bf 90       	pop	r11
     a7a:	af 90       	pop	r10
     a7c:	9f 90       	pop	r9
     a7e:	8f 90       	pop	r8
     a80:	7f 90       	pop	r7
     a82:	6f 90       	pop	r6
     a84:	5f 90       	pop	r5
     a86:	4f 90       	pop	r4
     a88:	3f 90       	pop	r3
     a8a:	2f 90       	pop	r2
     a8c:	1f 90       	pop	r1
     a8e:	0f 90       	pop	r0
     a90:	0f be       	out	0x3f, r0	; 63
     a92:	0f 90       	pop	r0

	asm volatile ( "ret" );
     a94:	08 95       	ret

00000a96 <__vector_7>:
	 * count is incremented after the context is saved.
	 */
	void SIG_OUTPUT_COMPARE1A( void ) __attribute__ ( ( signal, naked ) );
	void SIG_OUTPUT_COMPARE1A( void )
	{
		vPortYieldFromTick();
     a96:	0e 94 f0 04 	call	0x9e0	; 0x9e0 <vPortYieldFromTick>
		asm volatile ( "reti" );
     a9a:	18 95       	reti

00000a9c <prvCopyDataFromQueue>:
	++( pxQueue->uxMessagesWaiting );
}
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( xQUEUE * const pxQueue, const void *pvBuffer )
{
     a9c:	cf 93       	push	r28
     a9e:	df 93       	push	r29
     aa0:	dc 01       	movw	r26, r24
	if( pxQueue->uxQueueType != queueQUEUE_IS_MUTEX )
     aa2:	cd 91       	ld	r28, X+
     aa4:	dc 91       	ld	r29, X
     aa6:	11 97       	sbiw	r26, 0x01	; 1
     aa8:	20 97       	sbiw	r28, 0x00	; 0
     aaa:	21 f1       	breq	.+72     	; 0xaf4 <prvCopyDataFromQueue+0x58>
	{
		pxQueue->pcReadFrom += pxQueue->uxItemSize;
     aac:	5c 96       	adiw	r26, 0x1c	; 28
     aae:	4c 91       	ld	r20, X
     ab0:	5c 97       	sbiw	r26, 0x1c	; 28
     ab2:	16 96       	adiw	r26, 0x06	; 6
     ab4:	2d 91       	ld	r18, X+
     ab6:	3c 91       	ld	r19, X
     ab8:	17 97       	sbiw	r26, 0x07	; 7
     aba:	24 0f       	add	r18, r20
     abc:	31 1d       	adc	r19, r1
     abe:	17 96       	adiw	r26, 0x07	; 7
     ac0:	3c 93       	st	X, r19
     ac2:	2e 93       	st	-X, r18
     ac4:	16 97       	sbiw	r26, 0x06	; 6
		if( pxQueue->pcReadFrom >= pxQueue->pcTail )
     ac6:	12 96       	adiw	r26, 0x02	; 2
     ac8:	ed 91       	ld	r30, X+
     aca:	fc 91       	ld	r31, X
     acc:	13 97       	sbiw	r26, 0x03	; 3
     ace:	2e 17       	cp	r18, r30
     ad0:	3f 07       	cpc	r19, r31
     ad2:	20 f0       	brcs	.+8      	; 0xadc <prvCopyDataFromQueue+0x40>
		{
			pxQueue->pcReadFrom = pxQueue->pcHead;
     ad4:	17 96       	adiw	r26, 0x07	; 7
     ad6:	dc 93       	st	X, r29
     ad8:	ce 93       	st	-X, r28
     ada:	16 97       	sbiw	r26, 0x06	; 6
		}
		memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
     adc:	16 96       	adiw	r26, 0x06	; 6
     ade:	3c 91       	ld	r19, X
     ae0:	16 97       	sbiw	r26, 0x06	; 6
     ae2:	17 96       	adiw	r26, 0x07	; 7
     ae4:	2c 91       	ld	r18, X
     ae6:	86 2f       	mov	r24, r22
     ae8:	97 2f       	mov	r25, r23
     aea:	63 2f       	mov	r22, r19
     aec:	72 2f       	mov	r23, r18
     aee:	50 e0       	ldi	r21, 0x00	; 0
     af0:	0e 94 74 0d 	call	0x1ae8	; 0x1ae8 <memcpy>
	}
}
     af4:	df 91       	pop	r29
     af6:	cf 91       	pop	r28
     af8:	08 95       	ret

00000afa <prvCopyDataToQueue>:
	vPortFree( pxQueue );
}
/*-----------------------------------------------------------*/

static void prvCopyDataToQueue( xQUEUE *pxQueue, const void *pvItemToQueue, portBASE_TYPE xPosition )
{
     afa:	cf 93       	push	r28
     afc:	df 93       	push	r29
     afe:	ec 01       	movw	r28, r24
	if( pxQueue->uxItemSize == ( unsigned portBASE_TYPE ) 0 )
     b00:	2c 8d       	ldd	r18, Y+28	; 0x1c
     b02:	22 23       	and	r18, r18
     b04:	a9 f1       	breq	.+106    	; 0xb70 <prvCopyDataToQueue+0x76>
				pxQueue->pxMutexHolder = NULL;
			}
		}
		#endif
	}
	else if( xPosition == queueSEND_TO_BACK )
     b06:	44 23       	and	r20, r20
     b08:	b9 f4       	brne	.+46     	; 0xb38 <prvCopyDataToQueue+0x3e>
	{
		memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
     b0a:	8c 81       	ldd	r24, Y+4	; 0x04
     b0c:	9d 81       	ldd	r25, Y+5	; 0x05
     b0e:	42 2f       	mov	r20, r18
     b10:	50 e0       	ldi	r21, 0x00	; 0
     b12:	0e 94 74 0d 	call	0x1ae8	; 0x1ae8 <memcpy>
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
     b16:	2c 8d       	ldd	r18, Y+28	; 0x1c
     b18:	8c 81       	ldd	r24, Y+4	; 0x04
     b1a:	9d 81       	ldd	r25, Y+5	; 0x05
     b1c:	82 0f       	add	r24, r18
     b1e:	91 1d       	adc	r25, r1
     b20:	9d 83       	std	Y+5, r25	; 0x05
     b22:	8c 83       	std	Y+4, r24	; 0x04
		if( pxQueue->pcWriteTo >= pxQueue->pcTail )
     b24:	2a 81       	ldd	r18, Y+2	; 0x02
     b26:	3b 81       	ldd	r19, Y+3	; 0x03
     b28:	82 17       	cp	r24, r18
     b2a:	93 07       	cpc	r25, r19
     b2c:	08 f1       	brcs	.+66     	; 0xb70 <prvCopyDataToQueue+0x76>
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
     b2e:	88 81       	ld	r24, Y
     b30:	99 81       	ldd	r25, Y+1	; 0x01
     b32:	9d 83       	std	Y+5, r25	; 0x05
     b34:	8c 83       	std	Y+4, r24	; 0x04
     b36:	1c c0       	rjmp	.+56     	; 0xb70 <prvCopyDataToQueue+0x76>
		}
	}
	else
	{
		memcpy( ( void * ) pxQueue->pcReadFrom, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
     b38:	8e 81       	ldd	r24, Y+6	; 0x06
     b3a:	9f 81       	ldd	r25, Y+7	; 0x07
     b3c:	42 2f       	mov	r20, r18
     b3e:	50 e0       	ldi	r21, 0x00	; 0
     b40:	0e 94 74 0d 	call	0x1ae8	; 0x1ae8 <memcpy>
		pxQueue->pcReadFrom -= pxQueue->uxItemSize;
     b44:	4c 8d       	ldd	r20, Y+28	; 0x1c
     b46:	50 e0       	ldi	r21, 0x00	; 0
     b48:	50 95       	com	r21
     b4a:	41 95       	neg	r20
     b4c:	5f 4f       	sbci	r21, 0xFF	; 255
     b4e:	8e 81       	ldd	r24, Y+6	; 0x06
     b50:	9f 81       	ldd	r25, Y+7	; 0x07
     b52:	84 0f       	add	r24, r20
     b54:	95 1f       	adc	r25, r21
     b56:	9f 83       	std	Y+7, r25	; 0x07
     b58:	8e 83       	std	Y+6, r24	; 0x06
		if( pxQueue->pcReadFrom < pxQueue->pcHead )
     b5a:	28 81       	ld	r18, Y
     b5c:	39 81       	ldd	r19, Y+1	; 0x01
     b5e:	82 17       	cp	r24, r18
     b60:	93 07       	cpc	r25, r19
     b62:	30 f4       	brcc	.+12     	; 0xb70 <prvCopyDataToQueue+0x76>
		{
			pxQueue->pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
     b64:	8a 81       	ldd	r24, Y+2	; 0x02
     b66:	9b 81       	ldd	r25, Y+3	; 0x03
     b68:	48 0f       	add	r20, r24
     b6a:	59 1f       	adc	r21, r25
     b6c:	5f 83       	std	Y+7, r21	; 0x07
     b6e:	4e 83       	std	Y+6, r20	; 0x06
		}
	}

	++( pxQueue->uxMessagesWaiting );
     b70:	8a 8d       	ldd	r24, Y+26	; 0x1a
     b72:	8f 5f       	subi	r24, 0xFF	; 255
     b74:	8a 8f       	std	Y+26, r24	; 0x1a
}
     b76:	df 91       	pop	r29
     b78:	cf 91       	pop	r28
     b7a:	08 95       	ret

00000b7c <prvUnlockQueue>:
	}
}
/*-----------------------------------------------------------*/

static void prvUnlockQueue( xQueueHandle pxQueue )
{
     b7c:	0f 93       	push	r16
     b7e:	1f 93       	push	r17
     b80:	cf 93       	push	r28
     b82:	df 93       	push	r29
     b84:	ec 01       	movw	r28, r24

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
     b86:	0f b6       	in	r0, 0x3f	; 63
     b88:	f8 94       	cli
     b8a:	0f 92       	push	r0
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
     b8c:	8e 8d       	ldd	r24, Y+30	; 0x1e
     b8e:	18 16       	cp	r1, r24
     b90:	bc f4       	brge	.+46     	; 0xbc0 <prvUnlockQueue+0x44>
		{
			/* Data was posted while the queue was locked.  Are any tasks
			blocked waiting for data to become available? */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
     b92:	89 89       	ldd	r24, Y+17	; 0x11
     b94:	88 23       	and	r24, r24
     b96:	29 f4       	brne	.+10     	; 0xba2 <prvUnlockQueue+0x26>
     b98:	13 c0       	rjmp	.+38     	; 0xbc0 <prvUnlockQueue+0x44>
     b9a:	89 89       	ldd	r24, Y+17	; 0x11
     b9c:	88 23       	and	r24, r24
     b9e:	21 f4       	brne	.+8      	; 0xba8 <prvUnlockQueue+0x2c>
     ba0:	0f c0       	rjmp	.+30     	; 0xbc0 <prvUnlockQueue+0x44>
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
     ba2:	8e 01       	movw	r16, r28
     ba4:	0f 5e       	subi	r16, 0xEF	; 239
     ba6:	1f 4f       	sbci	r17, 0xFF	; 255
     ba8:	c8 01       	movw	r24, r16
     baa:	0e 94 e7 0c 	call	0x19ce	; 0x19ce <xTaskRemoveFromEventList>
     bae:	88 23       	and	r24, r24
     bb0:	11 f0       	breq	.+4      	; 0xbb6 <prvUnlockQueue+0x3a>
				{
					/* The task waiting has a higher priority so record that a
					context	switch is required. */
					vTaskMissedYield();
     bb2:	0e 94 70 0d 	call	0x1ae0	; 0x1ae0 <vTaskMissedYield>
				}

				--( pxQueue->xTxLock );
     bb6:	8e 8d       	ldd	r24, Y+30	; 0x1e
     bb8:	81 50       	subi	r24, 0x01	; 1
     bba:	8e 8f       	std	Y+30, r24	; 0x1e
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
     bbc:	18 16       	cp	r1, r24
     bbe:	6c f3       	brlt	.-38     	; 0xb9a <prvUnlockQueue+0x1e>
			{
				break;
			}
		}

		pxQueue->xTxLock = queueUNLOCKED;
     bc0:	8f ef       	ldi	r24, 0xFF	; 255
     bc2:	8e 8f       	std	Y+30, r24	; 0x1e
	}
	taskEXIT_CRITICAL();
     bc4:	0f 90       	pop	r0
     bc6:	0f be       	out	0x3f, r0	; 63

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
     bc8:	0f b6       	in	r0, 0x3f	; 63
     bca:	f8 94       	cli
     bcc:	0f 92       	push	r0
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
     bce:	8d 8d       	ldd	r24, Y+29	; 0x1d
     bd0:	18 16       	cp	r1, r24
     bd2:	bc f4       	brge	.+46     	; 0xc02 <prvUnlockQueue+0x86>
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
     bd4:	88 85       	ldd	r24, Y+8	; 0x08
     bd6:	88 23       	and	r24, r24
     bd8:	29 f4       	brne	.+10     	; 0xbe4 <prvUnlockQueue+0x68>
     bda:	13 c0       	rjmp	.+38     	; 0xc02 <prvUnlockQueue+0x86>
     bdc:	88 85       	ldd	r24, Y+8	; 0x08
     bde:	88 23       	and	r24, r24
     be0:	21 f4       	brne	.+8      	; 0xbea <prvUnlockQueue+0x6e>
     be2:	0f c0       	rjmp	.+30     	; 0xc02 <prvUnlockQueue+0x86>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
     be4:	8e 01       	movw	r16, r28
     be6:	08 5f       	subi	r16, 0xF8	; 248
     be8:	1f 4f       	sbci	r17, 0xFF	; 255
     bea:	c8 01       	movw	r24, r16
     bec:	0e 94 e7 0c 	call	0x19ce	; 0x19ce <xTaskRemoveFromEventList>
     bf0:	88 23       	and	r24, r24
     bf2:	11 f0       	breq	.+4      	; 0xbf8 <prvUnlockQueue+0x7c>
				{
					vTaskMissedYield();
     bf4:	0e 94 70 0d 	call	0x1ae0	; 0x1ae0 <vTaskMissedYield>
				}

				--( pxQueue->xRxLock );
     bf8:	8d 8d       	ldd	r24, Y+29	; 0x1d
     bfa:	81 50       	subi	r24, 0x01	; 1
     bfc:	8d 8f       	std	Y+29, r24	; 0x1d
	taskEXIT_CRITICAL();

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
     bfe:	18 16       	cp	r1, r24
     c00:	6c f3       	brlt	.-38     	; 0xbdc <prvUnlockQueue+0x60>
			{
				break;
			}
		}

		pxQueue->xRxLock = queueUNLOCKED;
     c02:	8f ef       	ldi	r24, 0xFF	; 255
     c04:	8d 8f       	std	Y+29, r24	; 0x1d
	}
	taskEXIT_CRITICAL();
     c06:	0f 90       	pop	r0
     c08:	0f be       	out	0x3f, r0	; 63
}
     c0a:	df 91       	pop	r29
     c0c:	cf 91       	pop	r28
     c0e:	1f 91       	pop	r17
     c10:	0f 91       	pop	r16
     c12:	08 95       	ret

00000c14 <xQueueCreate>:
/*-----------------------------------------------------------
 * PUBLIC QUEUE MANAGEMENT API documented in queue.h
 *----------------------------------------------------------*/

xQueueHandle xQueueCreate( unsigned portBASE_TYPE uxQueueLength, unsigned portBASE_TYPE uxItemSize )
{
     c14:	af 92       	push	r10
     c16:	bf 92       	push	r11
     c18:	cf 92       	push	r12
     c1a:	df 92       	push	r13
     c1c:	ef 92       	push	r14
     c1e:	ff 92       	push	r15
     c20:	0f 93       	push	r16
     c22:	1f 93       	push	r17
     c24:	cf 93       	push	r28
     c26:	df 93       	push	r29
     c28:	f8 2e       	mov	r15, r24
     c2a:	e6 2e       	mov	r14, r22
xQUEUE *pxNewQueue;
size_t xQueueSizeInBytes;
xQueueHandle xReturn = NULL;

	/* Allocate the new queue structure. */
	if( uxQueueLength > ( unsigned portBASE_TYPE ) 0 )
     c2c:	88 23       	and	r24, r24
     c2e:	09 f4       	brne	.+2      	; 0xc32 <xQueueCreate+0x1e>
     c30:	46 c0       	rjmp	.+140    	; 0xcbe <xQueueCreate+0xaa>
	{
		pxNewQueue = ( xQUEUE * ) pvPortMalloc( sizeof( xQUEUE ) );
     c32:	8f e1       	ldi	r24, 0x1F	; 31
     c34:	90 e0       	ldi	r25, 0x00	; 0
     c36:	0e 94 6e 02 	call	0x4dc	; 0x4dc <pvPortMalloc>
     c3a:	8c 01       	movw	r16, r24
		if( pxNewQueue != NULL )
     c3c:	00 97       	sbiw	r24, 0x00	; 0
     c3e:	09 f4       	brne	.+2      	; 0xc42 <xQueueCreate+0x2e>
     c40:	41 c0       	rjmp	.+130    	; 0xcc4 <xQueueCreate+0xb0>
		{
			/* Create the list of pointers to queue items.  The queue is one byte
			longer than asked for to make wrap checking easier/faster. */
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ) + ( size_t ) 1;
     c42:	cf 2c       	mov	r12, r15
     c44:	dd 24       	eor	r13, r13
     c46:	ae 2c       	mov	r10, r14
     c48:	bb 24       	eor	r11, r11
     c4a:	ca 9c       	mul	r12, r10
     c4c:	e0 01       	movw	r28, r0
     c4e:	cb 9c       	mul	r12, r11
     c50:	d0 0d       	add	r29, r0
     c52:	da 9c       	mul	r13, r10
     c54:	d0 0d       	add	r29, r0
     c56:	11 24       	eor	r1, r1

			pxNewQueue->pcHead = ( signed char * ) pvPortMalloc( xQueueSizeInBytes );
     c58:	ce 01       	movw	r24, r28
     c5a:	01 96       	adiw	r24, 0x01	; 1
     c5c:	0e 94 6e 02 	call	0x4dc	; 0x4dc <pvPortMalloc>
     c60:	ac 01       	movw	r20, r24
     c62:	f8 01       	movw	r30, r16
     c64:	91 83       	std	Z+1, r25	; 0x01
     c66:	80 83       	st	Z, r24
			if( pxNewQueue->pcHead != NULL )
     c68:	00 97       	sbiw	r24, 0x00	; 0
     c6a:	19 f1       	breq	.+70     	; 0xcb2 <xQueueCreate+0x9e>
			{
				/* Initialise the queue members as described above where the
				queue type is defined. */
				pxNewQueue->pcTail = pxNewQueue->pcHead + ( uxQueueLength * uxItemSize );
     c6c:	c8 0f       	add	r28, r24
     c6e:	d9 1f       	adc	r29, r25
     c70:	d3 83       	std	Z+3, r29	; 0x03
     c72:	c2 83       	std	Z+2, r28	; 0x02
				pxNewQueue->uxMessagesWaiting = ( unsigned portBASE_TYPE ) 0U;
     c74:	12 8e       	std	Z+26, r1	; 0x1a
				pxNewQueue->pcWriteTo = pxNewQueue->pcHead;
     c76:	95 83       	std	Z+5, r25	; 0x05
     c78:	84 83       	std	Z+4, r24	; 0x04
				pxNewQueue->pcReadFrom = pxNewQueue->pcHead + ( ( uxQueueLength - ( unsigned portBASE_TYPE ) 1U ) * uxItemSize );
     c7a:	c6 01       	movw	r24, r12
     c7c:	01 97       	sbiw	r24, 0x01	; 1
     c7e:	a8 9e       	mul	r10, r24
     c80:	90 01       	movw	r18, r0
     c82:	a9 9e       	mul	r10, r25
     c84:	30 0d       	add	r19, r0
     c86:	b8 9e       	mul	r11, r24
     c88:	30 0d       	add	r19, r0
     c8a:	11 24       	eor	r1, r1
     c8c:	24 0f       	add	r18, r20
     c8e:	35 1f       	adc	r19, r21
     c90:	37 83       	std	Z+7, r19	; 0x07
     c92:	26 83       	std	Z+6, r18	; 0x06
				pxNewQueue->uxLength = uxQueueLength;
     c94:	f3 8e       	std	Z+27, r15	; 0x1b
				pxNewQueue->uxItemSize = uxItemSize;
     c96:	e4 8e       	std	Z+28, r14	; 0x1c
				pxNewQueue->xRxLock = queueUNLOCKED;
     c98:	8f ef       	ldi	r24, 0xFF	; 255
     c9a:	85 8f       	std	Z+29, r24	; 0x1d
				pxNewQueue->xTxLock = queueUNLOCKED;
     c9c:	86 8f       	std	Z+30, r24	; 0x1e

				/* Likewise ensure the event queues start with the correct state. */
				vListInitialise( &( pxNewQueue->xTasksWaitingToSend ) );
     c9e:	c8 01       	movw	r24, r16
     ca0:	08 96       	adiw	r24, 0x08	; 8
     ca2:	0e 94 33 03 	call	0x666	; 0x666 <vListInitialise>
				vListInitialise( &( pxNewQueue->xTasksWaitingToReceive ) );
     ca6:	c8 01       	movw	r24, r16
     ca8:	41 96       	adiw	r24, 0x11	; 17
     caa:	0e 94 33 03 	call	0x666	; 0x666 <vListInitialise>

				traceQUEUE_CREATE( pxNewQueue );
				xReturn = pxNewQueue;
     cae:	c8 01       	movw	r24, r16
     cb0:	0b c0       	rjmp	.+22     	; 0xcc8 <xQueueCreate+0xb4>
			}
			else
			{
				traceQUEUE_CREATE_FAILED();
				vPortFree( pxNewQueue );
     cb2:	c8 01       	movw	r24, r16
     cb4:	0e 94 97 02 	call	0x52e	; 0x52e <vPortFree>

xQueueHandle xQueueCreate( unsigned portBASE_TYPE uxQueueLength, unsigned portBASE_TYPE uxItemSize )
{
xQUEUE *pxNewQueue;
size_t xQueueSizeInBytes;
xQueueHandle xReturn = NULL;
     cb8:	80 e0       	ldi	r24, 0x00	; 0
     cba:	90 e0       	ldi	r25, 0x00	; 0
     cbc:	05 c0       	rjmp	.+10     	; 0xcc8 <xQueueCreate+0xb4>
     cbe:	80 e0       	ldi	r24, 0x00	; 0
     cc0:	90 e0       	ldi	r25, 0x00	; 0
     cc2:	02 c0       	rjmp	.+4      	; 0xcc8 <xQueueCreate+0xb4>
     cc4:	80 e0       	ldi	r24, 0x00	; 0
     cc6:	90 e0       	ldi	r25, 0x00	; 0
	}

	configASSERT( xReturn );

	return xReturn;
}
     cc8:	df 91       	pop	r29
     cca:	cf 91       	pop	r28
     ccc:	1f 91       	pop	r17
     cce:	0f 91       	pop	r16
     cd0:	ff 90       	pop	r15
     cd2:	ef 90       	pop	r14
     cd4:	df 90       	pop	r13
     cd6:	cf 90       	pop	r12
     cd8:	bf 90       	pop	r11
     cda:	af 90       	pop	r10
     cdc:	08 95       	ret

00000cde <xQueueGenericSend>:

#endif /* configUSE_COUNTING_SEMAPHORES */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSend( xQueueHandle pxQueue, const void * const pvItemToQueue, portTickType xTicksToWait, portBASE_TYPE xCopyPosition )
{
     cde:	8f 92       	push	r8
     ce0:	9f 92       	push	r9
     ce2:	bf 92       	push	r11
     ce4:	cf 92       	push	r12
     ce6:	df 92       	push	r13
     ce8:	ef 92       	push	r14
     cea:	ff 92       	push	r15
     cec:	0f 93       	push	r16
     cee:	1f 93       	push	r17
     cf0:	cf 93       	push	r28
     cf2:	df 93       	push	r29
     cf4:	00 d0       	rcall	.+0      	; 0xcf6 <xQueueGenericSend+0x18>
     cf6:	00 d0       	rcall	.+0      	; 0xcf8 <xQueueGenericSend+0x1a>
     cf8:	0f 92       	push	r0
     cfa:	cd b7       	in	r28, 0x3d	; 61
     cfc:	de b7       	in	r29, 0x3e	; 62
     cfe:	8c 01       	movw	r16, r24
     d00:	4b 01       	movw	r8, r22
     d02:	5d 83       	std	Y+5, r21	; 0x05
     d04:	4c 83       	std	Y+4, r20	; 0x04
     d06:	b2 2e       	mov	r11, r18
signed portBASE_TYPE xEntryTimeSet = pdFALSE;
     d08:	ff 24       	eor	r15, r15
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
					xEntryTimeSet = pdTRUE;
     d0a:	ee 24       	eor	r14, r14
     d0c:	e3 94       	inc	r14
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
     d0e:	cc 24       	eor	r12, r12
     d10:	dd 24       	eor	r13, r13
     d12:	68 94       	set
     d14:	c3 f8       	bld	r12, 3
     d16:	c8 0e       	add	r12, r24
     d18:	d9 1e       	adc	r13, r25
	/* This function relaxes the coding standard somewhat to allow return
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
     d1a:	0f b6       	in	r0, 0x3f	; 63
     d1c:	f8 94       	cli
     d1e:	0f 92       	push	r0
		{
			/* Is there room on the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
     d20:	f8 01       	movw	r30, r16
     d22:	92 8d       	ldd	r25, Z+26	; 0x1a
     d24:	83 8d       	ldd	r24, Z+27	; 0x1b
     d26:	98 17       	cp	r25, r24
     d28:	a8 f4       	brcc	.+42     	; 0xd54 <xQueueGenericSend+0x76>
			{
				traceQUEUE_SEND( pxQueue );
				prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
     d2a:	c8 01       	movw	r24, r16
     d2c:	b4 01       	movw	r22, r8
     d2e:	4b 2d       	mov	r20, r11
     d30:	0e 94 7d 05 	call	0xafa	; 0xafa <prvCopyDataToQueue>

				/* If there was a task waiting for data to arrive on the
				queue then unblock it now. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
     d34:	f8 01       	movw	r30, r16
     d36:	81 89       	ldd	r24, Z+17	; 0x11
     d38:	88 23       	and	r24, r24
     d3a:	41 f0       	breq	.+16     	; 0xd4c <xQueueGenericSend+0x6e>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) == pdTRUE )
     d3c:	c8 01       	movw	r24, r16
     d3e:	41 96       	adiw	r24, 0x11	; 17
     d40:	0e 94 e7 0c 	call	0x19ce	; 0x19ce <xTaskRemoveFromEventList>
     d44:	81 30       	cpi	r24, 0x01	; 1
     d46:	11 f4       	brne	.+4      	; 0xd4c <xQueueGenericSend+0x6e>
					{
						/* The unblocked task has a priority higher than
						our own so yield immediately.  Yes it is ok to do
						this from within the critical section - the kernel
						takes care of that. */
						portYIELD_WITHIN_API();
     d48:	0e 94 97 04 	call	0x92e	; 0x92e <vPortYield>
					}
				}

				taskEXIT_CRITICAL();
     d4c:	0f 90       	pop	r0
     d4e:	0f be       	out	0x3f, r0	; 63

				/* Return to the original privilege level before exiting the
				function. */
				return pdPASS;
     d50:	81 e0       	ldi	r24, 0x01	; 1
     d52:	52 c0       	rjmp	.+164    	; 0xdf8 <xQueueGenericSend+0x11a>
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
     d54:	8c 81       	ldd	r24, Y+4	; 0x04
     d56:	9d 81       	ldd	r25, Y+5	; 0x05
     d58:	00 97       	sbiw	r24, 0x00	; 0
     d5a:	21 f4       	brne	.+8      	; 0xd64 <xQueueGenericSend+0x86>
				{
					/* The queue was full and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
     d5c:	0f 90       	pop	r0
     d5e:	0f be       	out	0x3f, r0	; 63

					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED( pxQueue );
					return errQUEUE_FULL;
     d60:	80 e0       	ldi	r24, 0x00	; 0
     d62:	4a c0       	rjmp	.+148    	; 0xdf8 <xQueueGenericSend+0x11a>
				}
				else if( xEntryTimeSet == pdFALSE )
     d64:	ff 20       	and	r15, r15
     d66:	29 f4       	brne	.+10     	; 0xd72 <xQueueGenericSend+0x94>
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
     d68:	ce 01       	movw	r24, r28
     d6a:	01 96       	adiw	r24, 0x01	; 1
     d6c:	0e 94 2f 0d 	call	0x1a5e	; 0x1a5e <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
     d70:	fe 2c       	mov	r15, r14
				}
			}
		}
		taskEXIT_CRITICAL();
     d72:	0f 90       	pop	r0
     d74:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
     d76:	0e 94 61 0a 	call	0x14c2	; 0x14c2 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
     d7a:	0f b6       	in	r0, 0x3f	; 63
     d7c:	f8 94       	cli
     d7e:	0f 92       	push	r0
     d80:	f8 01       	movw	r30, r16
     d82:	85 8d       	ldd	r24, Z+29	; 0x1d
     d84:	8f 3f       	cpi	r24, 0xFF	; 255
     d86:	09 f4       	brne	.+2      	; 0xd8a <xQueueGenericSend+0xac>
     d88:	15 8e       	std	Z+29, r1	; 0x1d
     d8a:	f8 01       	movw	r30, r16
     d8c:	86 8d       	ldd	r24, Z+30	; 0x1e
     d8e:	8f 3f       	cpi	r24, 0xFF	; 255
     d90:	09 f4       	brne	.+2      	; 0xd94 <xQueueGenericSend+0xb6>
     d92:	16 8e       	std	Z+30, r1	; 0x1e
     d94:	0f 90       	pop	r0
     d96:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
     d98:	ce 01       	movw	r24, r28
     d9a:	01 96       	adiw	r24, 0x01	; 1
     d9c:	be 01       	movw	r22, r28
     d9e:	6c 5f       	subi	r22, 0xFC	; 252
     da0:	7f 4f       	sbci	r23, 0xFF	; 255
     da2:	0e 94 3a 0d 	call	0x1a74	; 0x1a74 <xTaskCheckForTimeOut>
     da6:	88 23       	and	r24, r24
     da8:	09 f5       	brne	.+66     	; 0xdec <xQueueGenericSend+0x10e>

static signed portBASE_TYPE prvIsQueueFull( const xQueueHandle pxQueue )
{
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
     daa:	0f b6       	in	r0, 0x3f	; 63
     dac:	f8 94       	cli
     dae:	0f 92       	push	r0
		xReturn = ( pxQueue->uxMessagesWaiting == pxQueue->uxLength );
     db0:	f8 01       	movw	r30, r16
     db2:	92 8d       	ldd	r25, Z+26	; 0x1a
	taskEXIT_CRITICAL();
     db4:	0f 90       	pop	r0
     db6:	0f be       	out	0x3f, r0	; 63
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
     db8:	f8 01       	movw	r30, r16
     dba:	83 8d       	ldd	r24, Z+27	; 0x1b
     dbc:	98 17       	cp	r25, r24
     dbe:	81 f4       	brne	.+32     	; 0xde0 <xQueueGenericSend+0x102>
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
     dc0:	6c 81       	ldd	r22, Y+4	; 0x04
     dc2:	7d 81       	ldd	r23, Y+5	; 0x05
     dc4:	c6 01       	movw	r24, r12
     dc6:	0e 94 ca 0c 	call	0x1994	; 0x1994 <vTaskPlaceOnEventList>
				/* Unlocking the queue means queue events can effect the
				event list.  It is possible	that interrupts occurring now
				remove this task from the event	list again - but as the
				scheduler is suspended the task will go onto the pending
				ready last instead of the actual ready list. */
				prvUnlockQueue( pxQueue );
     dca:	c8 01       	movw	r24, r16
     dcc:	0e 94 be 05 	call	0xb7c	; 0xb7c <prvUnlockQueue>
				/* Resuming the scheduler will move tasks from the pending
				ready list into the ready list - so it is feasible that this
				task is already in a ready list before it yields - in which
				case the yield will not cause a context switch unless there
				is also a higher priority task in the pending ready list. */
				if( xTaskResumeAll() == pdFALSE )
     dd0:	0e 94 3f 0b 	call	0x167e	; 0x167e <xTaskResumeAll>
     dd4:	88 23       	and	r24, r24
     dd6:	09 f0       	breq	.+2      	; 0xdda <xQueueGenericSend+0xfc>
     dd8:	a0 cf       	rjmp	.-192    	; 0xd1a <xQueueGenericSend+0x3c>
				{
					portYIELD_WITHIN_API();
     dda:	0e 94 97 04 	call	0x92e	; 0x92e <vPortYield>
     dde:	9d cf       	rjmp	.-198    	; 0xd1a <xQueueGenericSend+0x3c>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
     de0:	c8 01       	movw	r24, r16
     de2:	0e 94 be 05 	call	0xb7c	; 0xb7c <prvUnlockQueue>
				( void ) xTaskResumeAll();
     de6:	0e 94 3f 0b 	call	0x167e	; 0x167e <xTaskResumeAll>
     dea:	97 cf       	rjmp	.-210    	; 0xd1a <xQueueGenericSend+0x3c>
			}
		}
		else
		{
			/* The timeout has expired. */
			prvUnlockQueue( pxQueue );
     dec:	c8 01       	movw	r24, r16
     dee:	0e 94 be 05 	call	0xb7c	; 0xb7c <prvUnlockQueue>
			( void ) xTaskResumeAll();
     df2:	0e 94 3f 0b 	call	0x167e	; 0x167e <xTaskResumeAll>

			/* Return to the original privilege level before exiting the
			function. */
			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
     df6:	80 e0       	ldi	r24, 0x00	; 0
		}
	}
}
     df8:	0f 90       	pop	r0
     dfa:	0f 90       	pop	r0
     dfc:	0f 90       	pop	r0
     dfe:	0f 90       	pop	r0
     e00:	0f 90       	pop	r0
     e02:	df 91       	pop	r29
     e04:	cf 91       	pop	r28
     e06:	1f 91       	pop	r17
     e08:	0f 91       	pop	r16
     e0a:	ff 90       	pop	r15
     e0c:	ef 90       	pop	r14
     e0e:	df 90       	pop	r13
     e10:	cf 90       	pop	r12
     e12:	bf 90       	pop	r11
     e14:	9f 90       	pop	r9
     e16:	8f 90       	pop	r8
     e18:	08 95       	ret

00000e1a <xQueueGenericSendFromISR>:

#endif /* configUSE_ALTERNATIVE_API */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSendFromISR( xQueueHandle pxQueue, const void * const pvItemToQueue, signed portBASE_TYPE *pxHigherPriorityTaskWoken, portBASE_TYPE xCopyPosition )
{
     e1a:	0f 93       	push	r16
     e1c:	1f 93       	push	r17
     e1e:	cf 93       	push	r28
     e20:	df 93       	push	r29
     e22:	ec 01       	movw	r28, r24
     e24:	8a 01       	movw	r16, r20
	queue read, instead we return a flag to say whether a context switch is
	required or not (i.e. has a task with a higher priority than us been woken
	by this	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
     e26:	9a 8d       	ldd	r25, Y+26	; 0x1a
     e28:	8b 8d       	ldd	r24, Y+27	; 0x1b
     e2a:	98 17       	cp	r25, r24
     e2c:	c0 f4       	brcc	.+48     	; 0xe5e <xQueueGenericSendFromISR+0x44>
		{
			traceQUEUE_SEND_FROM_ISR( pxQueue );

			prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
     e2e:	ce 01       	movw	r24, r28
     e30:	42 2f       	mov	r20, r18
     e32:	0e 94 7d 05 	call	0xafa	; 0xafa <prvCopyDataToQueue>

			/* If the queue is locked we do not alter the event list.  This will
			be done when the queue is unlocked later. */
			if( pxQueue->xTxLock == queueUNLOCKED )
     e36:	8e 8d       	ldd	r24, Y+30	; 0x1e
     e38:	8f 3f       	cpi	r24, 0xFF	; 255
     e3a:	69 f4       	brne	.+26     	; 0xe56 <xQueueGenericSendFromISR+0x3c>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
     e3c:	89 89       	ldd	r24, Y+17	; 0x11
     e3e:	88 23       	and	r24, r24
     e40:	81 f0       	breq	.+32     	; 0xe62 <xQueueGenericSendFromISR+0x48>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
     e42:	ce 01       	movw	r24, r28
     e44:	41 96       	adiw	r24, 0x11	; 17
     e46:	0e 94 e7 0c 	call	0x19ce	; 0x19ce <xTaskRemoveFromEventList>
     e4a:	88 23       	and	r24, r24
     e4c:	61 f0       	breq	.+24     	; 0xe66 <xQueueGenericSendFromISR+0x4c>
					{
						/* The task waiting has a higher priority so record that a
						context	switch is required. */
						*pxHigherPriorityTaskWoken = pdTRUE;
     e4e:	81 e0       	ldi	r24, 0x01	; 1
     e50:	f8 01       	movw	r30, r16
     e52:	80 83       	st	Z, r24
     e54:	09 c0       	rjmp	.+18     	; 0xe68 <xQueueGenericSendFromISR+0x4e>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
     e56:	8f 5f       	subi	r24, 0xFF	; 255
     e58:	8e 8f       	std	Y+30, r24	; 0x1e
			}

			xReturn = pdPASS;
     e5a:	81 e0       	ldi	r24, 0x01	; 1
     e5c:	05 c0       	rjmp	.+10     	; 0xe68 <xQueueGenericSendFromISR+0x4e>
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
     e5e:	80 e0       	ldi	r24, 0x00	; 0
     e60:	03 c0       	rjmp	.+6      	; 0xe68 <xQueueGenericSendFromISR+0x4e>
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
			}

			xReturn = pdPASS;
     e62:	81 e0       	ldi	r24, 0x01	; 1
     e64:	01 c0       	rjmp	.+2      	; 0xe68 <xQueueGenericSendFromISR+0x4e>
     e66:	81 e0       	ldi	r24, 0x01	; 1
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
     e68:	df 91       	pop	r29
     e6a:	cf 91       	pop	r28
     e6c:	1f 91       	pop	r17
     e6e:	0f 91       	pop	r16
     e70:	08 95       	ret

00000e72 <xQueueGenericReceive>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericReceive( xQueueHandle pxQueue, void * const pvBuffer, portTickType xTicksToWait, portBASE_TYPE xJustPeeking )
{
     e72:	8f 92       	push	r8
     e74:	9f 92       	push	r9
     e76:	bf 92       	push	r11
     e78:	cf 92       	push	r12
     e7a:	df 92       	push	r13
     e7c:	ef 92       	push	r14
     e7e:	ff 92       	push	r15
     e80:	0f 93       	push	r16
     e82:	1f 93       	push	r17
     e84:	cf 93       	push	r28
     e86:	df 93       	push	r29
     e88:	00 d0       	rcall	.+0      	; 0xe8a <xQueueGenericReceive+0x18>
     e8a:	00 d0       	rcall	.+0      	; 0xe8c <xQueueGenericReceive+0x1a>
     e8c:	0f 92       	push	r0
     e8e:	cd b7       	in	r28, 0x3d	; 61
     e90:	de b7       	in	r29, 0x3e	; 62
     e92:	8c 01       	movw	r16, r24
     e94:	4b 01       	movw	r8, r22
     e96:	5d 83       	std	Y+5, r21	; 0x05
     e98:	4c 83       	std	Y+4, r20	; 0x04
     e9a:	b2 2e       	mov	r11, r18
signed portBASE_TYPE xEntryTimeSet = pdFALSE;
     e9c:	ff 24       	eor	r15, r15
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
					xEntryTimeSet = pdTRUE;
     e9e:	ee 24       	eor	r14, r14
     ea0:	e3 94       	inc	r14
						portEXIT_CRITICAL();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
     ea2:	0f 2e       	mov	r0, r31
     ea4:	f1 e1       	ldi	r31, 0x11	; 17
     ea6:	cf 2e       	mov	r12, r31
     ea8:	dd 24       	eor	r13, r13
     eaa:	f0 2d       	mov	r31, r0
     eac:	c8 0e       	add	r12, r24
     eae:	d9 1e       	adc	r13, r25
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
     eb0:	0f b6       	in	r0, 0x3f	; 63
     eb2:	f8 94       	cli
     eb4:	0f 92       	push	r0
		{
			/* Is there data in the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
     eb6:	f8 01       	movw	r30, r16
     eb8:	82 8d       	ldd	r24, Z+26	; 0x1a
     eba:	88 23       	and	r24, r24
     ebc:	51 f1       	breq	.+84     	; 0xf12 <xQueueGenericReceive+0xa0>
			{
				/* Remember our read position in case we are just peeking. */
				pcOriginalReadPosition = pxQueue->pcReadFrom;
     ebe:	e6 80       	ldd	r14, Z+6	; 0x06
     ec0:	f7 80       	ldd	r15, Z+7	; 0x07

				prvCopyDataFromQueue( pxQueue, pvBuffer );
     ec2:	c8 01       	movw	r24, r16
     ec4:	b4 01       	movw	r22, r8
     ec6:	0e 94 4e 05 	call	0xa9c	; 0xa9c <prvCopyDataFromQueue>

				if( xJustPeeking == pdFALSE )
     eca:	bb 20       	and	r11, r11
     ecc:	81 f4       	brne	.+32     	; 0xeee <xQueueGenericReceive+0x7c>
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* We are actually removing data. */
					--( pxQueue->uxMessagesWaiting );
     ece:	f8 01       	movw	r30, r16
     ed0:	82 8d       	ldd	r24, Z+26	; 0x1a
     ed2:	81 50       	subi	r24, 0x01	; 1
     ed4:	82 8f       	std	Z+26, r24	; 0x1a
							pxQueue->pxMutexHolder = xTaskGetCurrentTaskHandle();
						}
					}
					#endif

					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
     ed6:	80 85       	ldd	r24, Z+8	; 0x08
     ed8:	88 23       	and	r24, r24
     eda:	b9 f0       	breq	.+46     	; 0xf0a <xQueueGenericReceive+0x98>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
     edc:	c8 01       	movw	r24, r16
     ede:	08 96       	adiw	r24, 0x08	; 8
     ee0:	0e 94 e7 0c 	call	0x19ce	; 0x19ce <xTaskRemoveFromEventList>
     ee4:	81 30       	cpi	r24, 0x01	; 1
     ee6:	89 f4       	brne	.+34     	; 0xf0a <xQueueGenericReceive+0x98>
						{
							portYIELD_WITHIN_API();
     ee8:	0e 94 97 04 	call	0x92e	; 0x92e <vPortYield>
     eec:	0e c0       	rjmp	.+28     	; 0xf0a <xQueueGenericReceive+0x98>
				{
					traceQUEUE_PEEK( pxQueue );

					/* We are not removing the data, so reset our read
					pointer. */
					pxQueue->pcReadFrom = pcOriginalReadPosition;
     eee:	f8 01       	movw	r30, r16
     ef0:	f7 82       	std	Z+7, r15	; 0x07
     ef2:	e6 82       	std	Z+6, r14	; 0x06

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
     ef4:	81 89       	ldd	r24, Z+17	; 0x11
     ef6:	88 23       	and	r24, r24
     ef8:	41 f0       	breq	.+16     	; 0xf0a <xQueueGenericReceive+0x98>
					{
						/* Tasks that are removed from the event list will get added to
						the pending ready list as the scheduler is still suspended. */
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
     efa:	c8 01       	movw	r24, r16
     efc:	41 96       	adiw	r24, 0x11	; 17
     efe:	0e 94 e7 0c 	call	0x19ce	; 0x19ce <xTaskRemoveFromEventList>
     f02:	88 23       	and	r24, r24
     f04:	11 f0       	breq	.+4      	; 0xf0a <xQueueGenericReceive+0x98>
						{
							/* The task waiting has a higher priority than this task. */
							portYIELD_WITHIN_API();
     f06:	0e 94 97 04 	call	0x92e	; 0x92e <vPortYield>
						}
					}

				}

				taskEXIT_CRITICAL();
     f0a:	0f 90       	pop	r0
     f0c:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
     f0e:	81 e0       	ldi	r24, 0x01	; 1
     f10:	50 c0       	rjmp	.+160    	; 0xfb2 <xQueueGenericReceive+0x140>
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
     f12:	8c 81       	ldd	r24, Y+4	; 0x04
     f14:	9d 81       	ldd	r25, Y+5	; 0x05
     f16:	00 97       	sbiw	r24, 0x00	; 0
     f18:	21 f4       	brne	.+8      	; 0xf22 <xQueueGenericReceive+0xb0>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
     f1a:	0f 90       	pop	r0
     f1c:	0f be       	out	0x3f, r0	; 63
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
     f1e:	80 e0       	ldi	r24, 0x00	; 0
     f20:	48 c0       	rjmp	.+144    	; 0xfb2 <xQueueGenericReceive+0x140>
				}
				else if( xEntryTimeSet == pdFALSE )
     f22:	ff 20       	and	r15, r15
     f24:	29 f4       	brne	.+10     	; 0xf30 <xQueueGenericReceive+0xbe>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
     f26:	ce 01       	movw	r24, r28
     f28:	01 96       	adiw	r24, 0x01	; 1
     f2a:	0e 94 2f 0d 	call	0x1a5e	; 0x1a5e <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
     f2e:	fe 2c       	mov	r15, r14
				}
			}
		}
		taskEXIT_CRITICAL();
     f30:	0f 90       	pop	r0
     f32:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
     f34:	0e 94 61 0a 	call	0x14c2	; 0x14c2 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
     f38:	0f b6       	in	r0, 0x3f	; 63
     f3a:	f8 94       	cli
     f3c:	0f 92       	push	r0
     f3e:	f8 01       	movw	r30, r16
     f40:	85 8d       	ldd	r24, Z+29	; 0x1d
     f42:	8f 3f       	cpi	r24, 0xFF	; 255
     f44:	09 f4       	brne	.+2      	; 0xf48 <xQueueGenericReceive+0xd6>
     f46:	15 8e       	std	Z+29, r1	; 0x1d
     f48:	f8 01       	movw	r30, r16
     f4a:	86 8d       	ldd	r24, Z+30	; 0x1e
     f4c:	8f 3f       	cpi	r24, 0xFF	; 255
     f4e:	09 f4       	brne	.+2      	; 0xf52 <xQueueGenericReceive+0xe0>
     f50:	16 8e       	std	Z+30, r1	; 0x1e
     f52:	0f 90       	pop	r0
     f54:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
     f56:	ce 01       	movw	r24, r28
     f58:	01 96       	adiw	r24, 0x01	; 1
     f5a:	be 01       	movw	r22, r28
     f5c:	6c 5f       	subi	r22, 0xFC	; 252
     f5e:	7f 4f       	sbci	r23, 0xFF	; 255
     f60:	0e 94 3a 0d 	call	0x1a74	; 0x1a74 <xTaskCheckForTimeOut>
     f64:	88 23       	and	r24, r24
     f66:	f9 f4       	brne	.+62     	; 0xfa6 <xQueueGenericReceive+0x134>

static signed portBASE_TYPE prvIsQueueEmpty( const xQueueHandle pxQueue )
{
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
     f68:	0f b6       	in	r0, 0x3f	; 63
     f6a:	f8 94       	cli
     f6c:	0f 92       	push	r0
		xReturn = ( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0 );
     f6e:	f8 01       	movw	r30, r16
     f70:	82 8d       	ldd	r24, Z+26	; 0x1a
	taskEXIT_CRITICAL();
     f72:	0f 90       	pop	r0
     f74:	0f be       	out	0x3f, r0	; 63
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
     f76:	88 23       	and	r24, r24
     f78:	81 f4       	brne	.+32     	; 0xf9a <xQueueGenericReceive+0x128>
						portEXIT_CRITICAL();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
     f7a:	6c 81       	ldd	r22, Y+4	; 0x04
     f7c:	7d 81       	ldd	r23, Y+5	; 0x05
     f7e:	c6 01       	movw	r24, r12
     f80:	0e 94 ca 0c 	call	0x1994	; 0x1994 <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
     f84:	c8 01       	movw	r24, r16
     f86:	0e 94 be 05 	call	0xb7c	; 0xb7c <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
     f8a:	0e 94 3f 0b 	call	0x167e	; 0x167e <xTaskResumeAll>
     f8e:	88 23       	and	r24, r24
     f90:	09 f0       	breq	.+2      	; 0xf94 <xQueueGenericReceive+0x122>
     f92:	8e cf       	rjmp	.-228    	; 0xeb0 <xQueueGenericReceive+0x3e>
				{
					portYIELD_WITHIN_API();
     f94:	0e 94 97 04 	call	0x92e	; 0x92e <vPortYield>
     f98:	8b cf       	rjmp	.-234    	; 0xeb0 <xQueueGenericReceive+0x3e>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
     f9a:	c8 01       	movw	r24, r16
     f9c:	0e 94 be 05 	call	0xb7c	; 0xb7c <prvUnlockQueue>
				( void ) xTaskResumeAll();
     fa0:	0e 94 3f 0b 	call	0x167e	; 0x167e <xTaskResumeAll>
     fa4:	85 cf       	rjmp	.-246    	; 0xeb0 <xQueueGenericReceive+0x3e>
			}
		}
		else
		{
			prvUnlockQueue( pxQueue );
     fa6:	c8 01       	movw	r24, r16
     fa8:	0e 94 be 05 	call	0xb7c	; 0xb7c <prvUnlockQueue>
			( void ) xTaskResumeAll();
     fac:	0e 94 3f 0b 	call	0x167e	; 0x167e <xTaskResumeAll>
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
     fb0:	80 e0       	ldi	r24, 0x00	; 0
		}
	}
}
     fb2:	0f 90       	pop	r0
     fb4:	0f 90       	pop	r0
     fb6:	0f 90       	pop	r0
     fb8:	0f 90       	pop	r0
     fba:	0f 90       	pop	r0
     fbc:	df 91       	pop	r29
     fbe:	cf 91       	pop	r28
     fc0:	1f 91       	pop	r17
     fc2:	0f 91       	pop	r16
     fc4:	ff 90       	pop	r15
     fc6:	ef 90       	pop	r14
     fc8:	df 90       	pop	r13
     fca:	cf 90       	pop	r12
     fcc:	bf 90       	pop	r11
     fce:	9f 90       	pop	r9
     fd0:	8f 90       	pop	r8
     fd2:	08 95       	ret

00000fd4 <xQueueReceiveFromISR>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueReceiveFromISR( xQueueHandle pxQueue, void * const pvBuffer, signed portBASE_TYPE *pxTaskWoken )
{
     fd4:	0f 93       	push	r16
     fd6:	1f 93       	push	r17
     fd8:	cf 93       	push	r28
     fda:	df 93       	push	r29
     fdc:	ec 01       	movw	r28, r24
     fde:	8a 01       	movw	r16, r20
	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( unsigned portBASE_TYPE ) 0U ) ) );

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		/* We cannot block from an ISR, so check there is data available. */
		if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
     fe0:	8a 8d       	ldd	r24, Y+26	; 0x1a
     fe2:	88 23       	and	r24, r24
     fe4:	d1 f0       	breq	.+52     	; 0x101a <xQueueReceiveFromISR+0x46>
		{
			traceQUEUE_RECEIVE_FROM_ISR( pxQueue );

			prvCopyDataFromQueue( pxQueue, pvBuffer );
     fe6:	ce 01       	movw	r24, r28
     fe8:	0e 94 4e 05 	call	0xa9c	; 0xa9c <prvCopyDataFromQueue>
			--( pxQueue->uxMessagesWaiting );
     fec:	8a 8d       	ldd	r24, Y+26	; 0x1a
     fee:	81 50       	subi	r24, 0x01	; 1
     ff0:	8a 8f       	std	Y+26, r24	; 0x1a

			/* If the queue is locked we will not modify the event list.  Instead
			we update the lock count so the task that unlocks the queue will know
			that an ISR has removed data while the queue was locked. */
			if( pxQueue->xRxLock == queueUNLOCKED )
     ff2:	8d 8d       	ldd	r24, Y+29	; 0x1d
     ff4:	8f 3f       	cpi	r24, 0xFF	; 255
     ff6:	69 f4       	brne	.+26     	; 0x1012 <xQueueReceiveFromISR+0x3e>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
     ff8:	88 85       	ldd	r24, Y+8	; 0x08
     ffa:	88 23       	and	r24, r24
     ffc:	81 f0       	breq	.+32     	; 0x101e <xQueueReceiveFromISR+0x4a>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
     ffe:	ce 01       	movw	r24, r28
    1000:	08 96       	adiw	r24, 0x08	; 8
    1002:	0e 94 e7 0c 	call	0x19ce	; 0x19ce <xTaskRemoveFromEventList>
    1006:	88 23       	and	r24, r24
    1008:	61 f0       	breq	.+24     	; 0x1022 <xQueueReceiveFromISR+0x4e>
					{
						/* The task waiting has a higher priority than us so
						force a context switch. */
						*pxTaskWoken = pdTRUE;
    100a:	81 e0       	ldi	r24, 0x01	; 1
    100c:	f8 01       	movw	r30, r16
    100e:	80 83       	st	Z, r24
    1010:	09 c0       	rjmp	.+18     	; 0x1024 <xQueueReceiveFromISR+0x50>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was removed while it was locked. */
				++( pxQueue->xRxLock );
    1012:	8f 5f       	subi	r24, 0xFF	; 255
    1014:	8d 8f       	std	Y+29, r24	; 0x1d
			}

			xReturn = pdPASS;
    1016:	81 e0       	ldi	r24, 0x01	; 1
    1018:	05 c0       	rjmp	.+10     	; 0x1024 <xQueueReceiveFromISR+0x50>
		}
		else
		{
			xReturn = pdFAIL;
    101a:	80 e0       	ldi	r24, 0x00	; 0
    101c:	03 c0       	rjmp	.+6      	; 0x1024 <xQueueReceiveFromISR+0x50>
				/* Increment the lock count so the task that unlocks the queue
				knows that data was removed while it was locked. */
				++( pxQueue->xRxLock );
			}

			xReturn = pdPASS;
    101e:	81 e0       	ldi	r24, 0x01	; 1
    1020:	01 c0       	rjmp	.+2      	; 0x1024 <xQueueReceiveFromISR+0x50>
    1022:	81 e0       	ldi	r24, 0x01	; 1
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    1024:	df 91       	pop	r29
    1026:	cf 91       	pop	r28
    1028:	1f 91       	pop	r17
    102a:	0f 91       	pop	r16
    102c:	08 95       	ret

0000102e <uxQueueMessagesWaiting>:
{
unsigned portBASE_TYPE uxReturn;

	configASSERT( pxQueue );

	taskENTER_CRITICAL();
    102e:	0f b6       	in	r0, 0x3f	; 63
    1030:	f8 94       	cli
    1032:	0f 92       	push	r0
		uxReturn = pxQueue->uxMessagesWaiting;
    1034:	fc 01       	movw	r30, r24
    1036:	82 8d       	ldd	r24, Z+26	; 0x1a
	taskEXIT_CRITICAL();
    1038:	0f 90       	pop	r0
    103a:	0f be       	out	0x3f, r0	; 63

	return uxReturn;
}
    103c:	08 95       	ret

0000103e <uxQueueMessagesWaitingFromISR>:
{
unsigned portBASE_TYPE uxReturn;

	configASSERT( pxQueue );

	uxReturn = pxQueue->uxMessagesWaiting;
    103e:	fc 01       	movw	r30, r24
    1040:	82 8d       	ldd	r24, Z+26	; 0x1a

	return uxReturn;
}
    1042:	08 95       	ret

00001044 <vQueueDelete>:
/*-----------------------------------------------------------*/

void vQueueDelete( xQueueHandle pxQueue )
{
    1044:	cf 93       	push	r28
    1046:	df 93       	push	r29
    1048:	ec 01       	movw	r28, r24
	configASSERT( pxQueue );

	traceQUEUE_DELETE( pxQueue );
	vQueueUnregisterQueue( pxQueue );
	vPortFree( pxQueue->pcHead );
    104a:	88 81       	ld	r24, Y
    104c:	99 81       	ldd	r25, Y+1	; 0x01
    104e:	0e 94 97 02 	call	0x52e	; 0x52e <vPortFree>
	vPortFree( pxQueue );
    1052:	ce 01       	movw	r24, r28
    1054:	0e 94 97 02 	call	0x52e	; 0x52e <vPortFree>
}
    1058:	df 91       	pop	r29
    105a:	cf 91       	pop	r28
    105c:	08 95       	ret

0000105e <xQueueIsQueueEmptyFromISR>:
signed portBASE_TYPE xQueueIsQueueEmptyFromISR( const xQueueHandle pxQueue )
{
signed portBASE_TYPE xReturn;

	configASSERT( pxQueue );
	xReturn = ( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0 );
    105e:	fc 01       	movw	r30, r24
    1060:	92 8d       	ldd	r25, Z+26	; 0x1a
    1062:	81 e0       	ldi	r24, 0x01	; 1
    1064:	91 11       	cpse	r25, r1
    1066:	80 e0       	ldi	r24, 0x00	; 0

	return xReturn;
}
    1068:	08 95       	ret

0000106a <xQueueIsQueueFullFromISR>:
	return xReturn;
}
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueIsQueueFullFromISR( const xQueueHandle pxQueue )
{
    106a:	fc 01       	movw	r30, r24
signed portBASE_TYPE xReturn;

	configASSERT( pxQueue );
	xReturn = ( pxQueue->uxMessagesWaiting == pxQueue->uxLength );
    106c:	22 8d       	ldd	r18, Z+26	; 0x1a
    106e:	81 e0       	ldi	r24, 0x01	; 1
    1070:	93 8d       	ldd	r25, Z+27	; 0x1b
    1072:	29 13       	cpse	r18, r25
    1074:	80 e0       	ldi	r24, 0x00	; 0

	return xReturn;
}
    1076:	08 95       	ret

00001078 <task2_code>:
static void task2_code(void*pvParamter)
{
	for (;;)
	{
		lcd_clrScreen();
		lcd_dispString("I am Task 2");	
    1078:	c0 e6       	ldi	r28, 0x60	; 96
    107a:	d0 e0       	ldi	r29, 0x00	; 0
/*Task 2 Code*/
static void task2_code(void*pvParamter)
{
	for (;;)
	{
		lcd_clrScreen();
    107c:	0e 94 13 03 	call	0x626	; 0x626 <lcd_clrScreen>
		lcd_dispString("I am Task 2");	
    1080:	ce 01       	movw	r24, r28
    1082:	0e 94 17 03 	call	0x62e	; 0x62e <lcd_dispString>
    1086:	8f ef       	ldi	r24, 0xFF	; 255
    1088:	99 e6       	ldi	r25, 0x69	; 105
    108a:	a8 e1       	ldi	r26, 0x18	; 24
    108c:	81 50       	subi	r24, 0x01	; 1
    108e:	90 40       	sbci	r25, 0x00	; 0
    1090:	a0 40       	sbci	r26, 0x00	; 0
    1092:	e1 f7       	brne	.-8      	; 0x108c <task2_code+0x14>
    1094:	00 c0       	rjmp	.+0      	; 0x1096 <task2_code+0x1e>
    1096:	00 00       	nop
		_delay_ms(1000);
		vTaskDelay(2000);
    1098:	80 ed       	ldi	r24, 0xD0	; 208
    109a:	97 e0       	ldi	r25, 0x07	; 7
    109c:	0e 94 03 0c 	call	0x1806	; 0x1806 <vTaskDelay>
    10a0:	ed cf       	rjmp	.-38     	; 0x107c <task2_code+0x4>

000010a2 <task1_code>:
	static char counter=0;
	for (;;)
	{
		counter++;
		lcd_clrScreen();
		lcd_dispString("I am Task 1");
    10a2:	cc e6       	ldi	r28, 0x6C	; 108
    10a4:	d0 e0       	ldi	r29, 0x00	; 0
static void task1_code(void*pvParamter)
{
	static char counter=0;
	for (;;)
	{
		counter++;
    10a6:	80 91 20 03 	lds	r24, 0x0320
    10aa:	8f 5f       	subi	r24, 0xFF	; 255
    10ac:	80 93 20 03 	sts	0x0320, r24
		lcd_clrScreen();
    10b0:	0e 94 13 03 	call	0x626	; 0x626 <lcd_clrScreen>
		lcd_dispString("I am Task 1");
    10b4:	ce 01       	movw	r24, r28
    10b6:	0e 94 17 03 	call	0x62e	; 0x62e <lcd_dispString>
		//_delay_ms(1000);
		if (counter < 10)
    10ba:	80 91 20 03 	lds	r24, 0x0320
    10be:	8a 30       	cpi	r24, 0x0A	; 10
    10c0:	20 f4       	brcc	.+8      	; 0x10ca <task1_code+0x28>
		{
			lcd_displayChar((counter+'0'));
    10c2:	80 5d       	subi	r24, 0xD0	; 208
    10c4:	0e 94 e0 02 	call	0x5c0	; 0x5c0 <lcd_displayChar>
    10c8:	02 c0       	rjmp	.+4      	; 0x10ce <task1_code+0x2c>
		}
		else 
		{
			counter = 0;
    10ca:	10 92 20 03 	sts	0x0320, r1
		}
		vTaskDelay(500);		
    10ce:	84 ef       	ldi	r24, 0xF4	; 244
    10d0:	91 e0       	ldi	r25, 0x01	; 1
    10d2:	0e 94 03 0c 	call	0x1806	; 0x1806 <vTaskDelay>
	}
    10d6:	e7 cf       	rjmp	.-50     	; 0x10a6 <task1_code+0x4>

000010d8 <main>:
/*tasks codes prototypes */
static void task1_code(void*pvParamter);
static void task2_code(void*pvParamter);

int main(void)
{
    10d8:	af 92       	push	r10
    10da:	bf 92       	push	r11
    10dc:	cf 92       	push	r12
    10de:	df 92       	push	r13
    10e0:	ef 92       	push	r14
    10e2:	ff 92       	push	r15
    10e4:	0f 93       	push	r16
	/*initialize LCD*/
	lcd_init();	
    10e6:	0e 94 cf 02 	call	0x59e	; 0x59e <lcd_init>
	/*Creat tasks*/
	xTaskCreate(task1_code,"task1",configMINIMAL_STACK_SIZE,NULL,TASK1_PRIORITY,NULL);
    10ea:	81 e5       	ldi	r24, 0x51	; 81
    10ec:	98 e0       	ldi	r25, 0x08	; 8
    10ee:	68 e7       	ldi	r22, 0x78	; 120
    10f0:	70 e0       	ldi	r23, 0x00	; 0
    10f2:	45 e5       	ldi	r20, 0x55	; 85
    10f4:	50 e0       	ldi	r21, 0x00	; 0
    10f6:	20 e0       	ldi	r18, 0x00	; 0
    10f8:	30 e0       	ldi	r19, 0x00	; 0
    10fa:	01 e0       	ldi	r16, 0x01	; 1
    10fc:	ee 24       	eor	r14, r14
    10fe:	ff 24       	eor	r15, r15
    1100:	cc 24       	eor	r12, r12
    1102:	dd 24       	eor	r13, r13
    1104:	aa 24       	eor	r10, r10
    1106:	bb 24       	eor	r11, r11
    1108:	0e 94 d4 08 	call	0x11a8	; 0x11a8 <xTaskGenericCreate>
	xTaskCreate(task2_code,"task2",configMINIMAL_STACK_SIZE,NULL,TASK2_PRIORITY,NULL);
    110c:	8c e3       	ldi	r24, 0x3C	; 60
    110e:	98 e0       	ldi	r25, 0x08	; 8
    1110:	6e e7       	ldi	r22, 0x7E	; 126
    1112:	70 e0       	ldi	r23, 0x00	; 0
    1114:	45 e5       	ldi	r20, 0x55	; 85
    1116:	50 e0       	ldi	r21, 0x00	; 0
    1118:	20 e0       	ldi	r18, 0x00	; 0
    111a:	30 e0       	ldi	r19, 0x00	; 0
    111c:	02 e0       	ldi	r16, 0x02	; 2
    111e:	0e 94 d4 08 	call	0x11a8	; 0x11a8 <xTaskGenericCreate>
	/*start Scheduler */
	vTaskStartScheduler();
    1122:	0e 94 30 0a 	call	0x1460	; 0x1460 <vTaskStartScheduler>
	
	return 0;
    
}
    1126:	80 e0       	ldi	r24, 0x00	; 0
    1128:	90 e0       	ldi	r25, 0x00	; 0
    112a:	0f 91       	pop	r16
    112c:	ff 90       	pop	r15
    112e:	ef 90       	pop	r14
    1130:	df 90       	pop	r13
    1132:	cf 90       	pop	r12
    1134:	bf 90       	pop	r11
    1136:	af 90       	pop	r10
    1138:	08 95       	ret

0000113a <prvAddCurrentTaskToDelayedList>:
	#endif
}
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( portTickType xTimeToWake )
{
    113a:	cf 93       	push	r28
    113c:	df 93       	push	r29
    113e:	ec 01       	movw	r28, r24
	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
    1140:	e0 91 21 03 	lds	r30, 0x0321
    1144:	f0 91 22 03 	lds	r31, 0x0322
    1148:	93 83       	std	Z+3, r25	; 0x03
    114a:	82 83       	std	Z+2, r24	; 0x02

	if( xTimeToWake < xTickCount )
    114c:	80 91 29 03 	lds	r24, 0x0329
    1150:	90 91 2a 03 	lds	r25, 0x032A
    1154:	c8 17       	cp	r28, r24
    1156:	d9 07       	cpc	r29, r25
    1158:	68 f4       	brcc	.+26     	; 0x1174 <prvAddCurrentTaskToDelayedList+0x3a>
	{
		/* Wake time has overflowed.  Place this item in the overflow list. */
		vListInsert( ( xList * ) pxOverflowDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    115a:	80 91 2d 03 	lds	r24, 0x032D
    115e:	90 91 2e 03 	lds	r25, 0x032E
    1162:	60 91 21 03 	lds	r22, 0x0321
    1166:	70 91 22 03 	lds	r23, 0x0322
    116a:	6e 5f       	subi	r22, 0xFE	; 254
    116c:	7f 4f       	sbci	r23, 0xFF	; 255
    116e:	0e 94 6e 03 	call	0x6dc	; 0x6dc <vListInsert>
    1172:	17 c0       	rjmp	.+46     	; 0x11a2 <prvAddCurrentTaskToDelayedList+0x68>
	}
	else
	{
		/* The wake time has not overflowed, so we can use the current block list. */
		vListInsert( ( xList * ) pxDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    1174:	80 91 2f 03 	lds	r24, 0x032F
    1178:	90 91 30 03 	lds	r25, 0x0330
    117c:	60 91 21 03 	lds	r22, 0x0321
    1180:	70 91 22 03 	lds	r23, 0x0322
    1184:	6e 5f       	subi	r22, 0xFE	; 254
    1186:	7f 4f       	sbci	r23, 0xFF	; 255
    1188:	0e 94 6e 03 	call	0x6dc	; 0x6dc <vListInsert>

		/* If the task entering the blocked state was placed at the head of the
		list of blocked tasks then xNextTaskUnblockTime needs to be updated
		too. */
		if( xTimeToWake < xNextTaskUnblockTime )
    118c:	80 91 89 00 	lds	r24, 0x0089
    1190:	90 91 8a 00 	lds	r25, 0x008A
    1194:	c8 17       	cp	r28, r24
    1196:	d9 07       	cpc	r29, r25
    1198:	20 f4       	brcc	.+8      	; 0x11a2 <prvAddCurrentTaskToDelayedList+0x68>
		{
			xNextTaskUnblockTime = xTimeToWake;
    119a:	d0 93 8a 00 	sts	0x008A, r29
    119e:	c0 93 89 00 	sts	0x0089, r28
		}
	}
}
    11a2:	df 91       	pop	r29
    11a4:	cf 91       	pop	r28
    11a6:	08 95       	ret

000011a8 <xTaskGenericCreate>:
/*-----------------------------------------------------------
 * TASK CREATION API documented in task.h
 *----------------------------------------------------------*/

signed portBASE_TYPE xTaskGenericCreate( pdTASK_CODE pxTaskCode, const signed char * const pcName, unsigned short usStackDepth, void *pvParameters, unsigned portBASE_TYPE uxPriority, xTaskHandle *pxCreatedTask, portSTACK_TYPE *puxStackBuffer, const xMemoryRegion * const xRegions )
{
    11a8:	4f 92       	push	r4
    11aa:	5f 92       	push	r5
    11ac:	6f 92       	push	r6
    11ae:	7f 92       	push	r7
    11b0:	8f 92       	push	r8
    11b2:	9f 92       	push	r9
    11b4:	bf 92       	push	r11
    11b6:	cf 92       	push	r12
    11b8:	df 92       	push	r13
    11ba:	ef 92       	push	r14
    11bc:	ff 92       	push	r15
    11be:	0f 93       	push	r16
    11c0:	1f 93       	push	r17
    11c2:	cf 93       	push	r28
    11c4:	df 93       	push	r29
    11c6:	2c 01       	movw	r4, r24
    11c8:	4b 01       	movw	r8, r22
    11ca:	ea 01       	movw	r28, r20
    11cc:	39 01       	movw	r6, r18
    11ce:	b0 2e       	mov	r11, r16
{
tskTCB *pxNewTCB;

	/* Allocate space for the TCB.  Where the memory comes from depends on
	the implementation of the port malloc function. */
	pxNewTCB = ( tskTCB * ) pvPortMalloc( sizeof( tskTCB ) );
    11d0:	81 e2       	ldi	r24, 0x21	; 33
    11d2:	90 e0       	ldi	r25, 0x00	; 0
    11d4:	0e 94 6e 02 	call	0x4dc	; 0x4dc <pvPortMalloc>
    11d8:	8c 01       	movw	r16, r24

	if( pxNewTCB != NULL )
    11da:	00 97       	sbiw	r24, 0x00	; 0
    11dc:	09 f4       	brne	.+2      	; 0x11e0 <xTaskGenericCreate+0x38>
    11de:	db c0       	rjmp	.+438    	; 0x1396 <xTaskGenericCreate+0x1ee>
	{
		/* Allocate space for the stack used by the task being created.
		The base of the stack memory stored in the TCB so the task can
		be deleted later if required. */
		pxNewTCB->pxStack = ( portSTACK_TYPE * ) pvPortMallocAligned( ( ( ( size_t )usStackDepth ) * sizeof( portSTACK_TYPE ) ), puxStackBuffer );
    11e0:	c1 14       	cp	r12, r1
    11e2:	d1 04       	cpc	r13, r1
    11e4:	09 f0       	breq	.+2      	; 0x11e8 <xTaskGenericCreate+0x40>
    11e6:	ec c0       	rjmp	.+472    	; 0x13c0 <xTaskGenericCreate+0x218>
    11e8:	ce 01       	movw	r24, r28
    11ea:	0e 94 6e 02 	call	0x4dc	; 0x4dc <pvPortMalloc>
    11ee:	6c 01       	movw	r12, r24
    11f0:	f8 01       	movw	r30, r16
    11f2:	90 8f       	std	Z+24, r25	; 0x18
    11f4:	87 8b       	std	Z+23, r24	; 0x17

		if( pxNewTCB->pxStack == NULL )
    11f6:	00 97       	sbiw	r24, 0x00	; 0
    11f8:	29 f4       	brne	.+10     	; 0x1204 <xTaskGenericCreate+0x5c>
		{
			/* Could not allocate the stack.  Delete the allocated TCB. */
			vPortFree( pxNewTCB );
    11fa:	c8 01       	movw	r24, r16
    11fc:	0e 94 97 02 	call	0x52e	; 0x52e <vPortFree>
		}
		taskEXIT_CRITICAL();
	}
	else
	{
		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
    1200:	8f ef       	ldi	r24, 0xFF	; 255
    1202:	ce c0       	rjmp	.+412    	; 0x13a0 <xTaskGenericCreate+0x1f8>
			pxNewTCB = NULL;
		}
		else
		{
			/* Just to help debugging. */
			memset( pxNewTCB->pxStack, ( int ) tskSTACK_FILL_BYTE, ( size_t ) usStackDepth * sizeof( portSTACK_TYPE ) );
    1204:	c6 01       	movw	r24, r12
    1206:	65 ea       	ldi	r22, 0xA5	; 165
    1208:	70 e0       	ldi	r23, 0x00	; 0
    120a:	ae 01       	movw	r20, r28
    120c:	0e 94 7d 0d 	call	0x1afa	; 0x1afa <memset>
		stack grows from high memory to low (as per the 80x86) or visa versa.
		portSTACK_GROWTH is used to make the result positive or negative as
		required by the port. */
		#if( portSTACK_GROWTH < 0 )
		{
			pxTopOfStack = pxNewTCB->pxStack + ( usStackDepth - ( unsigned short ) 1 );
    1210:	9e 01       	movw	r18, r28
    1212:	21 50       	subi	r18, 0x01	; 1
    1214:	30 40       	sbci	r19, 0x00	; 0
    1216:	f8 01       	movw	r30, r16
    1218:	87 89       	ldd	r24, Z+23	; 0x17
    121a:	90 8d       	ldd	r25, Z+24	; 0x18
    121c:	6c 01       	movw	r12, r24
    121e:	c2 0e       	add	r12, r18
    1220:	d3 1e       	adc	r13, r19
{
	/* Store the function name in the TCB. */
	#if configMAX_TASK_NAME_LEN > 1
	{
		/* Don't bring strncpy into the build unnecessarily. */
		strncpy( ( char * ) pxTCB->pcTaskName, ( const char * ) pcName, ( unsigned short ) configMAX_TASK_NAME_LEN );
    1222:	c8 01       	movw	r24, r16
    1224:	49 96       	adiw	r24, 0x19	; 25
    1226:	b4 01       	movw	r22, r8
    1228:	48 e0       	ldi	r20, 0x08	; 8
    122a:	50 e0       	ldi	r21, 0x00	; 0
    122c:	0e 94 84 0d 	call	0x1b08	; 0x1b08 <strncpy>
	}
	#endif
	pxTCB->pcTaskName[ ( unsigned short ) configMAX_TASK_NAME_LEN - ( unsigned short ) 1 ] = ( signed char ) '\0';
    1230:	f8 01       	movw	r30, r16
    1232:	10 a2       	lds	r17, 0x90
    1234:	cb 2d       	mov	r28, r11
    1236:	f2 e0       	ldi	r31, 0x02	; 2
    1238:	fb 15       	cp	r31, r11
    123a:	08 f4       	brcc	.+2      	; 0x123e <xTaskGenericCreate+0x96>
    123c:	c2 e0       	ldi	r28, 0x02	; 2
	if( uxPriority >= configMAX_PRIORITIES )
	{
		uxPriority = configMAX_PRIORITIES - ( unsigned portBASE_TYPE ) 1U;
	}

	pxTCB->uxPriority = uxPriority;
    123e:	f8 01       	movw	r30, r16
    1240:	c6 8b       	std	Z+22, r28	; 0x16
	{
		pxTCB->uxBasePriority = uxPriority;
	}
	#endif

	vListInitialiseItem( &( pxTCB->xGenericListItem ) );
    1242:	88 24       	eor	r8, r8
    1244:	99 24       	eor	r9, r9
    1246:	68 94       	set
    1248:	81 f8       	bld	r8, 1
    124a:	80 0e       	add	r8, r16
    124c:	91 1e       	adc	r9, r17
    124e:	c4 01       	movw	r24, r8
    1250:	0e 94 41 03 	call	0x682	; 0x682 <vListInitialiseItem>
	vListInitialiseItem( &( pxTCB->xEventListItem ) );
    1254:	c8 01       	movw	r24, r16
    1256:	0c 96       	adiw	r24, 0x0c	; 12
    1258:	0e 94 41 03 	call	0x682	; 0x682 <vListInitialiseItem>

	/* Set the pxTCB as a link back from the xListItem.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxTCB->xGenericListItem ), pxTCB );
    125c:	f8 01       	movw	r30, r16
    125e:	11 87       	std	Z+9, r17	; 0x09
    1260:	00 87       	std	Z+8, r16	; 0x08

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) uxPriority );
    1262:	83 e0       	ldi	r24, 0x03	; 3
    1264:	90 e0       	ldi	r25, 0x00	; 0
    1266:	8c 1b       	sub	r24, r28
    1268:	91 09       	sbc	r25, r1
    126a:	95 87       	std	Z+13, r25	; 0x0d
    126c:	84 87       	std	Z+12, r24	; 0x0c
	listSET_LIST_ITEM_OWNER( &( pxTCB->xEventListItem ), pxTCB );
    126e:	13 8b       	std	Z+19, r17	; 0x13
    1270:	02 8b       	std	Z+18, r16	; 0x12
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged );
		}
		#else
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
    1272:	c6 01       	movw	r24, r12
    1274:	b2 01       	movw	r22, r4
    1276:	a3 01       	movw	r20, r6
    1278:	0e 94 d1 03 	call	0x7a2	; 0x7a2 <pxPortInitialiseStack>
    127c:	f8 01       	movw	r30, r16
    127e:	91 83       	std	Z+1, r25	; 0x01
    1280:	80 83       	st	Z, r24
		#endif

		/* Check the alignment of the initialised stack. */
		configASSERT( ( ( ( unsigned long ) pxNewTCB->pxTopOfStack & ( unsigned long ) portBYTE_ALIGNMENT_MASK ) == 0UL ) );

		if( ( void * ) pxCreatedTask != NULL )
    1282:	e1 14       	cp	r14, r1
    1284:	f1 04       	cpc	r15, r1
    1286:	19 f0       	breq	.+6      	; 0x128e <xTaskGenericCreate+0xe6>
		{
			/* Pass the TCB out - in an anonymous way.  The calling function/
			task can use this as a handle to delete the task later if
			required.*/
			*pxCreatedTask = ( xTaskHandle ) pxNewTCB;
    1288:	f7 01       	movw	r30, r14
    128a:	11 83       	std	Z+1, r17	; 0x01
    128c:	00 83       	st	Z, r16
		}
		
		/* We are going to manipulate the task queues to add this task to a
		ready list, so must make sure no interrupts occur. */
		taskENTER_CRITICAL();
    128e:	0f b6       	in	r0, 0x3f	; 63
    1290:	f8 94       	cli
    1292:	0f 92       	push	r0
		{
			uxCurrentNumberOfTasks++;
    1294:	80 91 2b 03 	lds	r24, 0x032B
    1298:	8f 5f       	subi	r24, 0xFF	; 255
    129a:	80 93 2b 03 	sts	0x032B, r24
			if( pxCurrentTCB == NULL )
    129e:	80 91 21 03 	lds	r24, 0x0321
    12a2:	90 91 22 03 	lds	r25, 0x0322
    12a6:	00 97       	sbiw	r24, 0x00	; 0
    12a8:	a1 f5       	brne	.+104    	; 0x1312 <xTaskGenericCreate+0x16a>
			{
				/* There are no other tasks, or all the other tasks are in
				the suspended state - make this the current task. */
				pxCurrentTCB =  pxNewTCB;
    12aa:	10 93 22 03 	sts	0x0322, r17
    12ae:	00 93 21 03 	sts	0x0321, r16

				if( uxCurrentNumberOfTasks == ( unsigned portBASE_TYPE ) 1 )
    12b2:	80 91 2b 03 	lds	r24, 0x032B
    12b6:	81 30       	cpi	r24, 0x01	; 1
    12b8:	d9 f5       	brne	.+118    	; 0x1330 <xTaskGenericCreate+0x188>
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
    12ba:	c3 e3       	ldi	r28, 0x33	; 51
    12bc:	d3 e0       	ldi	r29, 0x03	; 3
    12be:	ce 01       	movw	r24, r28
    12c0:	0e 94 33 03 	call	0x666	; 0x666 <vListInitialise>
    12c4:	ce 01       	movw	r24, r28
    12c6:	09 96       	adiw	r24, 0x09	; 9
    12c8:	0e 94 33 03 	call	0x666	; 0x666 <vListInitialise>
    12cc:	ce 01       	movw	r24, r28
    12ce:	42 96       	adiw	r24, 0x12	; 18
    12d0:	0e 94 33 03 	call	0x666	; 0x666 <vListInitialise>
	}

	vListInitialise( ( xList * ) &xDelayedTaskList1 );
    12d4:	ce e4       	ldi	r28, 0x4E	; 78
    12d6:	d3 e0       	ldi	r29, 0x03	; 3
    12d8:	ce 01       	movw	r24, r28
    12da:	0e 94 33 03 	call	0x666	; 0x666 <vListInitialise>
	vListInitialise( ( xList * ) &xDelayedTaskList2 );
    12de:	0f 2e       	mov	r0, r31
    12e0:	f7 e5       	ldi	r31, 0x57	; 87
    12e2:	ef 2e       	mov	r14, r31
    12e4:	f3 e0       	ldi	r31, 0x03	; 3
    12e6:	ff 2e       	mov	r15, r31
    12e8:	f0 2d       	mov	r31, r0
    12ea:	c7 01       	movw	r24, r14
    12ec:	0e 94 33 03 	call	0x666	; 0x666 <vListInitialise>
	vListInitialise( ( xList * ) &xPendingReadyList );
    12f0:	80 e6       	ldi	r24, 0x60	; 96
    12f2:	93 e0       	ldi	r25, 0x03	; 3
    12f4:	0e 94 33 03 	call	0x666	; 0x666 <vListInitialise>

	#if ( INCLUDE_vTaskDelete == 1 )
	{
		vListInitialise( ( xList * ) &xTasksWaitingTermination );
    12f8:	89 e6       	ldi	r24, 0x69	; 105
    12fa:	93 e0       	ldi	r25, 0x03	; 3
    12fc:	0e 94 33 03 	call	0x666	; 0x666 <vListInitialise>
	}
	#endif

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
    1300:	d0 93 30 03 	sts	0x0330, r29
    1304:	c0 93 2f 03 	sts	0x032F, r28
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
    1308:	f0 92 2e 03 	sts	0x032E, r15
    130c:	e0 92 2d 03 	sts	0x032D, r14
    1310:	0f c0       	rjmp	.+30     	; 0x1330 <xTaskGenericCreate+0x188>
			else
			{
				/* If the scheduler is not already running, make this task the
				current task if it is the highest priority task to be created
				so far. */
				if( xSchedulerRunning == pdFALSE )
    1312:	80 91 27 03 	lds	r24, 0x0327
    1316:	88 23       	and	r24, r24
    1318:	59 f4       	brne	.+22     	; 0x1330 <xTaskGenericCreate+0x188>
				{
					if( pxCurrentTCB->uxPriority <= uxPriority )
    131a:	e0 91 21 03 	lds	r30, 0x0321
    131e:	f0 91 22 03 	lds	r31, 0x0322
    1322:	86 89       	ldd	r24, Z+22	; 0x16
    1324:	b8 16       	cp	r11, r24
    1326:	20 f0       	brcs	.+8      	; 0x1330 <xTaskGenericCreate+0x188>
					{
						pxCurrentTCB = pxNewTCB;
    1328:	10 93 22 03 	sts	0x0322, r17
    132c:	00 93 21 03 	sts	0x0321, r16
				}
			}

			/* Remember the top priority to make context switching faster.  Use
			the priority in pxNewTCB as this has been capped to a valid value. */
			if( pxNewTCB->uxPriority > uxTopUsedPriority )
    1330:	f8 01       	movw	r30, r16
    1332:	86 89       	ldd	r24, Z+22	; 0x16
    1334:	90 91 31 03 	lds	r25, 0x0331
    1338:	98 17       	cp	r25, r24
    133a:	10 f4       	brcc	.+4      	; 0x1340 <xTaskGenericCreate+0x198>
			{
				uxTopUsedPriority = pxNewTCB->uxPriority;
    133c:	80 93 31 03 	sts	0x0331, r24
			{
				/* Add a counter into the TCB for tracing only. */
				pxNewTCB->uxTCBNumber = uxTaskNumber;
			}
			#endif
			uxTaskNumber++;
    1340:	90 91 32 03 	lds	r25, 0x0332
    1344:	9f 5f       	subi	r25, 0xFF	; 255
    1346:	90 93 32 03 	sts	0x0332, r25

			prvAddTaskToReadyQueue( pxNewTCB );
    134a:	90 91 28 03 	lds	r25, 0x0328
    134e:	98 17       	cp	r25, r24
    1350:	10 f4       	brcc	.+4      	; 0x1356 <xTaskGenericCreate+0x1ae>
    1352:	80 93 28 03 	sts	0x0328, r24
    1356:	90 e0       	ldi	r25, 0x00	; 0
    1358:	9c 01       	movw	r18, r24
    135a:	22 0f       	add	r18, r18
    135c:	33 1f       	adc	r19, r19
    135e:	22 0f       	add	r18, r18
    1360:	33 1f       	adc	r19, r19
    1362:	22 0f       	add	r18, r18
    1364:	33 1f       	adc	r19, r19
    1366:	82 0f       	add	r24, r18
    1368:	93 1f       	adc	r25, r19
    136a:	8d 5c       	subi	r24, 0xCD	; 205
    136c:	9c 4f       	sbci	r25, 0xFC	; 252
    136e:	b4 01       	movw	r22, r8
    1370:	0e 94 45 03 	call	0x68a	; 0x68a <vListInsertEnd>

			xReturn = pdPASS;
			traceTASK_CREATE( pxNewTCB );
		}
		taskEXIT_CRITICAL();
    1374:	0f 90       	pop	r0
    1376:	0f be       	out	0x3f, r0	; 63
		traceTASK_CREATE_FAILED();
	}

	if( xReturn == pdPASS )
	{
		if( xSchedulerRunning != pdFALSE )
    1378:	80 91 27 03 	lds	r24, 0x0327
    137c:	88 23       	and	r24, r24
    137e:	69 f0       	breq	.+26     	; 0x139a <xTaskGenericCreate+0x1f2>
		{
			/* If the created task is of a higher priority than the current task
			then it should run now. */
			if( pxCurrentTCB->uxPriority < uxPriority )
    1380:	e0 91 21 03 	lds	r30, 0x0321
    1384:	f0 91 22 03 	lds	r31, 0x0322
    1388:	86 89       	ldd	r24, Z+22	; 0x16
    138a:	8b 15       	cp	r24, r11
    138c:	40 f4       	brcc	.+16     	; 0x139e <xTaskGenericCreate+0x1f6>
			{
				portYIELD_WITHIN_API();
    138e:	0e 94 97 04 	call	0x92e	; 0x92e <vPortYield>
			#endif
			uxTaskNumber++;

			prvAddTaskToReadyQueue( pxNewTCB );

			xReturn = pdPASS;
    1392:	81 e0       	ldi	r24, 0x01	; 1
    1394:	05 c0       	rjmp	.+10     	; 0x13a0 <xTaskGenericCreate+0x1f8>
		}
		taskEXIT_CRITICAL();
	}
	else
	{
		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
    1396:	8f ef       	ldi	r24, 0xFF	; 255
    1398:	03 c0       	rjmp	.+6      	; 0x13a0 <xTaskGenericCreate+0x1f8>
			#endif
			uxTaskNumber++;

			prvAddTaskToReadyQueue( pxNewTCB );

			xReturn = pdPASS;
    139a:	81 e0       	ldi	r24, 0x01	; 1
    139c:	01 c0       	rjmp	.+2      	; 0x13a0 <xTaskGenericCreate+0x1f8>
    139e:	81 e0       	ldi	r24, 0x01	; 1
			}
		}
	}

	return xReturn;
}
    13a0:	df 91       	pop	r29
    13a2:	cf 91       	pop	r28
    13a4:	1f 91       	pop	r17
    13a6:	0f 91       	pop	r16
    13a8:	ff 90       	pop	r15
    13aa:	ef 90       	pop	r14
    13ac:	df 90       	pop	r13
    13ae:	cf 90       	pop	r12
    13b0:	bf 90       	pop	r11
    13b2:	9f 90       	pop	r9
    13b4:	8f 90       	pop	r8
    13b6:	7f 90       	pop	r7
    13b8:	6f 90       	pop	r6
    13ba:	5f 90       	pop	r5
    13bc:	4f 90       	pop	r4
    13be:	08 95       	ret
	if( pxNewTCB != NULL )
	{
		/* Allocate space for the stack used by the task being created.
		The base of the stack memory stored in the TCB so the task can
		be deleted later if required. */
		pxNewTCB->pxStack = ( portSTACK_TYPE * ) pvPortMallocAligned( ( ( ( size_t )usStackDepth ) * sizeof( portSTACK_TYPE ) ), puxStackBuffer );
    13c0:	fc 01       	movw	r30, r24
    13c2:	d0 8e       	std	Z+24, r13	; 0x18
    13c4:	c7 8a       	std	Z+23, r12	; 0x17
    13c6:	1e cf       	rjmp	.-452    	; 0x1204 <xTaskGenericCreate+0x5c>

000013c8 <vTaskDelete>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

	void vTaskDelete( xTaskHandle pxTaskToDelete )
	{
    13c8:	ef 92       	push	r14
    13ca:	ff 92       	push	r15
    13cc:	0f 93       	push	r16
    13ce:	1f 93       	push	r17
    13d0:	cf 93       	push	r28
    13d2:	df 93       	push	r29
    13d4:	7c 01       	movw	r14, r24
	tskTCB *pxTCB;

		taskENTER_CRITICAL();
    13d6:	0f b6       	in	r0, 0x3f	; 63
    13d8:	f8 94       	cli
    13da:	0f 92       	push	r0
		{
			/* Ensure a yield is performed if the current task is being
			deleted. */
			if( pxTaskToDelete == pxCurrentTCB )
    13dc:	80 91 21 03 	lds	r24, 0x0321
    13e0:	90 91 22 03 	lds	r25, 0x0322
    13e4:	e8 16       	cp	r14, r24
    13e6:	f9 06       	cpc	r15, r25
    13e8:	21 f0       	breq	.+8      	; 0x13f2 <vTaskDelete+0x2a>
			{
				pxTaskToDelete = NULL;
			}

			/* If null is passed in here then we are deleting ourselves. */
			pxTCB = prvGetTCBFromHandle( pxTaskToDelete );
    13ea:	e1 14       	cp	r14, r1
    13ec:	f1 04       	cpc	r15, r1
    13ee:	41 f4       	brne	.+16     	; 0x1400 <vTaskDelete+0x38>
    13f0:	02 c0       	rjmp	.+4      	; 0x13f6 <vTaskDelete+0x2e>
		{
			/* Ensure a yield is performed if the current task is being
			deleted. */
			if( pxTaskToDelete == pxCurrentTCB )
			{
				pxTaskToDelete = NULL;
    13f2:	ee 24       	eor	r14, r14
    13f4:	ff 24       	eor	r15, r15
			}

			/* If null is passed in here then we are deleting ourselves. */
			pxTCB = prvGetTCBFromHandle( pxTaskToDelete );
    13f6:	c0 91 21 03 	lds	r28, 0x0321
    13fa:	d0 91 22 03 	lds	r29, 0x0322
    13fe:	01 c0       	rjmp	.+2      	; 0x1402 <vTaskDelete+0x3a>
    1400:	e7 01       	movw	r28, r14

			/* Remove task from the ready list and place in the	termination list.
			This will stop the task from be scheduled.  The idle task will check
			the termination list and free up any memory allocated by the
			scheduler for the TCB and stack. */
			vListRemove( &( pxTCB->xGenericListItem ) );
    1402:	8e 01       	movw	r16, r28
    1404:	0e 5f       	subi	r16, 0xFE	; 254
    1406:	1f 4f       	sbci	r17, 0xFF	; 255
    1408:	c8 01       	movw	r24, r16
    140a:	0e 94 ab 03 	call	0x756	; 0x756 <vListRemove>

			/* Is the task waiting on an event also? */
			if( pxTCB->xEventListItem.pvContainer != NULL )
    140e:	8c 89       	ldd	r24, Y+20	; 0x14
    1410:	9d 89       	ldd	r25, Y+21	; 0x15
    1412:	00 97       	sbiw	r24, 0x00	; 0
    1414:	21 f0       	breq	.+8      	; 0x141e <vTaskDelete+0x56>
			{
				vListRemove( &( pxTCB->xEventListItem ) );
    1416:	ce 01       	movw	r24, r28
    1418:	0c 96       	adiw	r24, 0x0c	; 12
    141a:	0e 94 ab 03 	call	0x756	; 0x756 <vListRemove>
			}

			vListInsertEnd( ( xList * ) &xTasksWaitingTermination, &( pxTCB->xGenericListItem ) );
    141e:	89 e6       	ldi	r24, 0x69	; 105
    1420:	93 e0       	ldi	r25, 0x03	; 3
    1422:	b8 01       	movw	r22, r16
    1424:	0e 94 45 03 	call	0x68a	; 0x68a <vListInsertEnd>

			/* Increment the ucTasksDeleted variable so the idle task knows
			there is a task that has been deleted and that it should therefore
			check the xTasksWaitingTermination list. */
			++uxTasksDeleted;
    1428:	80 91 2c 03 	lds	r24, 0x032C
    142c:	8f 5f       	subi	r24, 0xFF	; 255
    142e:	80 93 2c 03 	sts	0x032C, r24

			/* Increment the uxTaskNumberVariable also so kernel aware debuggers
			can detect that the task lists need re-generating. */
			uxTaskNumber++;
    1432:	80 91 32 03 	lds	r24, 0x0332
    1436:	8f 5f       	subi	r24, 0xFF	; 255
    1438:	80 93 32 03 	sts	0x0332, r24

			traceTASK_DELETE( pxTCB );
		}
		taskEXIT_CRITICAL();
    143c:	0f 90       	pop	r0
    143e:	0f be       	out	0x3f, r0	; 63

		/* Force a reschedule if we have just deleted the current task. */
		if( xSchedulerRunning != pdFALSE )
    1440:	80 91 27 03 	lds	r24, 0x0327
    1444:	88 23       	and	r24, r24
    1446:	29 f0       	breq	.+10     	; 0x1452 <vTaskDelete+0x8a>
		{
			if( ( void * ) pxTaskToDelete == NULL )
    1448:	e1 14       	cp	r14, r1
    144a:	f1 04       	cpc	r15, r1
    144c:	11 f4       	brne	.+4      	; 0x1452 <vTaskDelete+0x8a>
			{
				portYIELD_WITHIN_API();
    144e:	0e 94 97 04 	call	0x92e	; 0x92e <vPortYield>
			}
		}
	}
    1452:	df 91       	pop	r29
    1454:	cf 91       	pop	r28
    1456:	1f 91       	pop	r17
    1458:	0f 91       	pop	r16
    145a:	ff 90       	pop	r15
    145c:	ef 90       	pop	r14
    145e:	08 95       	ret

00001460 <vTaskStartScheduler>:
 * PUBLIC SCHEDULER CONTROL documented in task.h
 *----------------------------------------------------------*/


void vTaskStartScheduler( void )
{
    1460:	af 92       	push	r10
    1462:	bf 92       	push	r11
    1464:	cf 92       	push	r12
    1466:	df 92       	push	r13
    1468:	ef 92       	push	r14
    146a:	ff 92       	push	r15
    146c:	0f 93       	push	r16
		xReturn = xTaskCreate( prvIdleTask, ( signed char * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), &xIdleTaskHandle );
	}
	#else
	{
		/* Create the idle task without storing its handle. */
		xReturn = xTaskCreate( prvIdleTask, ( signed char * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), NULL );
    146e:	8f ec       	ldi	r24, 0xCF	; 207
    1470:	9b e0       	ldi	r25, 0x0B	; 11
    1472:	64 e8       	ldi	r22, 0x84	; 132
    1474:	70 e0       	ldi	r23, 0x00	; 0
    1476:	45 e5       	ldi	r20, 0x55	; 85
    1478:	50 e0       	ldi	r21, 0x00	; 0
    147a:	20 e0       	ldi	r18, 0x00	; 0
    147c:	30 e0       	ldi	r19, 0x00	; 0
    147e:	00 e0       	ldi	r16, 0x00	; 0
    1480:	ee 24       	eor	r14, r14
    1482:	ff 24       	eor	r15, r15
    1484:	cc 24       	eor	r12, r12
    1486:	dd 24       	eor	r13, r13
    1488:	aa 24       	eor	r10, r10
    148a:	bb 24       	eor	r11, r11
    148c:	0e 94 d4 08 	call	0x11a8	; 0x11a8 <xTaskGenericCreate>
			xReturn = xTimerCreateTimerTask();
		}
	}
	#endif

	if( xReturn == pdPASS )
    1490:	81 30       	cpi	r24, 0x01	; 1
    1492:	49 f4       	brne	.+18     	; 0x14a6 <vTaskStartScheduler+0x46>
		so interrupts will automatically get re-enabled when the first task
		starts to run.

		STEPPING THROUGH HERE USING A DEBUGGER CAN CAUSE BIG PROBLEMS IF THE
		DEBUGGER ALLOWS INTERRUPTS TO BE PROCESSED. */
		portDISABLE_INTERRUPTS();
    1494:	f8 94       	cli

		xSchedulerRunning = pdTRUE;
    1496:	80 93 27 03 	sts	0x0327, r24
		xTickCount = ( portTickType ) 0U;
    149a:	10 92 2a 03 	sts	0x032A, r1
    149e:	10 92 29 03 	sts	0x0329, r1
		the run time counter time base. */
		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();
		
		/* Setting up the timer tick is hardware specific and thus in the
		portable interface. */
		if( xPortStartScheduler() != pdFALSE )
    14a2:	0e 94 61 04 	call	0x8c2	; 0x8c2 <xPortStartScheduler>
		}
	}

	/* This line will only be reached if the kernel could not be started. */
	configASSERT( xReturn );
}
    14a6:	0f 91       	pop	r16
    14a8:	ff 90       	pop	r15
    14aa:	ef 90       	pop	r14
    14ac:	df 90       	pop	r13
    14ae:	cf 90       	pop	r12
    14b0:	bf 90       	pop	r11
    14b2:	af 90       	pop	r10
    14b4:	08 95       	ret

000014b6 <vTaskEndScheduler>:
void vTaskEndScheduler( void )
{
	/* Stop the scheduler interrupts and call the portable scheduler end
	routine so the original ISRs can be restored if necessary.  The port
	layer must ensure interrupts enable	bit is left in the correct state. */
	portDISABLE_INTERRUPTS();
    14b6:	f8 94       	cli
	xSchedulerRunning = pdFALSE;
    14b8:	10 92 27 03 	sts	0x0327, r1
	vPortEndScheduler();
    14bc:	0e 94 96 04 	call	0x92c	; 0x92c <vPortEndScheduler>
}
    14c0:	08 95       	ret

000014c2 <vTaskSuspendAll>:

void vTaskSuspendAll( void )
{
	/* A critical section is not required as the variable is of type
	portBASE_TYPE. */
	++uxSchedulerSuspended;
    14c2:	80 91 26 03 	lds	r24, 0x0326
    14c6:	8f 5f       	subi	r24, 0xFF	; 255
    14c8:	80 93 26 03 	sts	0x0326, r24
}
    14cc:	08 95       	ret

000014ce <xTaskGetTickCount>:
portTickType xTaskGetTickCount( void )
{
portTickType xTicks;

	/* Critical section required if running on a 16 bit processor. */
	taskENTER_CRITICAL();
    14ce:	0f b6       	in	r0, 0x3f	; 63
    14d0:	f8 94       	cli
    14d2:	0f 92       	push	r0
	{
		xTicks = xTickCount;
    14d4:	80 91 29 03 	lds	r24, 0x0329
    14d8:	90 91 2a 03 	lds	r25, 0x032A
	}
	taskEXIT_CRITICAL();
    14dc:	0f 90       	pop	r0
    14de:	0f be       	out	0x3f, r0	; 63

	return xTicks;
}
    14e0:	08 95       	ret

000014e2 <xTaskGetTickCountFromISR>:
{
portTickType xReturn;
unsigned portBASE_TYPE uxSavedInterruptStatus;

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	xReturn = xTickCount;
    14e2:	80 91 29 03 	lds	r24, 0x0329
    14e6:	90 91 2a 03 	lds	r25, 0x032A
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    14ea:	08 95       	ret

000014ec <uxTaskGetNumberOfTasks>:

unsigned portBASE_TYPE uxTaskGetNumberOfTasks( void )
{
	/* A critical section is not required because the variables are of type
	portBASE_TYPE. */
	return uxCurrentNumberOfTasks;
    14ec:	80 91 2b 03 	lds	r24, 0x032B
}
    14f0:	08 95       	ret

000014f2 <vTaskIncrementTick>:
 * SCHEDULER INTERNALS AVAILABLE FOR PORTING PURPOSES
 * documented in task.h
 *----------------------------------------------------------*/

void vTaskIncrementTick( void )
{
    14f2:	0f 93       	push	r16
    14f4:	1f 93       	push	r17
    14f6:	cf 93       	push	r28
    14f8:	df 93       	push	r29
tskTCB * pxTCB;

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    14fa:	80 91 26 03 	lds	r24, 0x0326
    14fe:	88 23       	and	r24, r24
    1500:	09 f0       	breq	.+2      	; 0x1504 <vTaskIncrementTick+0x12>
    1502:	b3 c0       	rjmp	.+358    	; 0x166a <vTaskIncrementTick+0x178>
	{
		++xTickCount;
    1504:	80 91 29 03 	lds	r24, 0x0329
    1508:	90 91 2a 03 	lds	r25, 0x032A
    150c:	01 96       	adiw	r24, 0x01	; 1
    150e:	90 93 2a 03 	sts	0x032A, r25
    1512:	80 93 29 03 	sts	0x0329, r24
		if( xTickCount == ( portTickType ) 0U )
    1516:	80 91 29 03 	lds	r24, 0x0329
    151a:	90 91 2a 03 	lds	r25, 0x032A
    151e:	00 97       	sbiw	r24, 0x00	; 0
    1520:	99 f5       	brne	.+102    	; 0x1588 <vTaskIncrementTick+0x96>
			/* Tick count has overflowed so we need to swap the delay lists.
			If there are any items in pxDelayedTaskList here then there is
			an error! */
			configASSERT( ( listLIST_IS_EMPTY( pxDelayedTaskList ) ) );
			
			pxTemp = pxDelayedTaskList;
    1522:	80 91 2f 03 	lds	r24, 0x032F
    1526:	90 91 30 03 	lds	r25, 0x0330
			pxDelayedTaskList = pxOverflowDelayedTaskList;
    152a:	20 91 2d 03 	lds	r18, 0x032D
    152e:	30 91 2e 03 	lds	r19, 0x032E
    1532:	30 93 30 03 	sts	0x0330, r19
    1536:	20 93 2f 03 	sts	0x032F, r18
			pxOverflowDelayedTaskList = pxTemp;
    153a:	90 93 2e 03 	sts	0x032E, r25
    153e:	80 93 2d 03 	sts	0x032D, r24
			xNumOfOverflows++;
    1542:	80 91 23 03 	lds	r24, 0x0323
    1546:	8f 5f       	subi	r24, 0xFF	; 255
    1548:	80 93 23 03 	sts	0x0323, r24
	
			if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    154c:	e0 91 2f 03 	lds	r30, 0x032F
    1550:	f0 91 30 03 	lds	r31, 0x0330
    1554:	80 81       	ld	r24, Z
    1556:	88 23       	and	r24, r24
    1558:	39 f4       	brne	.+14     	; 0x1568 <vTaskIncrementTick+0x76>
				/* The new current delayed list is empty.  Set
				xNextTaskUnblockTime to the maximum possible value so it is
				extremely unlikely that the	
				if( xTickCount >= xNextTaskUnblockTime ) test will pass until
				there is an item in the delayed list. */
				xNextTaskUnblockTime = portMAX_DELAY;
    155a:	8f ef       	ldi	r24, 0xFF	; 255
    155c:	9f ef       	ldi	r25, 0xFF	; 255
    155e:	90 93 8a 00 	sts	0x008A, r25
    1562:	80 93 89 00 	sts	0x0089, r24
    1566:	10 c0       	rjmp	.+32     	; 0x1588 <vTaskIncrementTick+0x96>
			{
				/* The new current delayed list is not empty, get the value of
				the item at the head of the delayed list.  This is the time at
				which the task at the head of the delayed list should be removed
				from the Blocked state. */
				pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
    1568:	e0 91 2f 03 	lds	r30, 0x032F
    156c:	f0 91 30 03 	lds	r31, 0x0330
    1570:	05 80       	ldd	r0, Z+5	; 0x05
    1572:	f6 81       	ldd	r31, Z+6	; 0x06
    1574:	e0 2d       	mov	r30, r0
    1576:	06 80       	ldd	r0, Z+6	; 0x06
    1578:	f7 81       	ldd	r31, Z+7	; 0x07
    157a:	e0 2d       	mov	r30, r0
				xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( pxTCB->xGenericListItem ) );
    157c:	82 81       	ldd	r24, Z+2	; 0x02
    157e:	93 81       	ldd	r25, Z+3	; 0x03
    1580:	90 93 8a 00 	sts	0x008A, r25
    1584:	80 93 89 00 	sts	0x0089, r24
			}
		}

		/* See if this tick has made a timeout expire. */
		prvCheckDelayedTasks();
    1588:	20 91 29 03 	lds	r18, 0x0329
    158c:	30 91 2a 03 	lds	r19, 0x032A
    1590:	80 91 89 00 	lds	r24, 0x0089
    1594:	90 91 8a 00 	lds	r25, 0x008A
    1598:	28 17       	cp	r18, r24
    159a:	39 07       	cpc	r19, r25
    159c:	08 f4       	brcc	.+2      	; 0x15a0 <vTaskIncrementTick+0xae>
    159e:	6a c0       	rjmp	.+212    	; 0x1674 <vTaskIncrementTick+0x182>
    15a0:	e0 91 2f 03 	lds	r30, 0x032F
    15a4:	f0 91 30 03 	lds	r31, 0x0330
    15a8:	80 81       	ld	r24, Z
    15aa:	88 23       	and	r24, r24
    15ac:	99 f0       	breq	.+38     	; 0x15d4 <vTaskIncrementTick+0xe2>
    15ae:	e0 91 2f 03 	lds	r30, 0x032F
    15b2:	f0 91 30 03 	lds	r31, 0x0330
    15b6:	05 80       	ldd	r0, Z+5	; 0x05
    15b8:	f6 81       	ldd	r31, Z+6	; 0x06
    15ba:	e0 2d       	mov	r30, r0
    15bc:	c6 81       	ldd	r28, Z+6	; 0x06
    15be:	d7 81       	ldd	r29, Z+7	; 0x07
    15c0:	8a 81       	ldd	r24, Y+2	; 0x02
    15c2:	9b 81       	ldd	r25, Y+3	; 0x03
    15c4:	20 91 29 03 	lds	r18, 0x0329
    15c8:	30 91 2a 03 	lds	r19, 0x032A
    15cc:	28 17       	cp	r18, r24
    15ce:	39 07       	cpc	r19, r25
    15d0:	f8 f4       	brcc	.+62     	; 0x1610 <vTaskIncrementTick+0x11e>
    15d2:	19 c0       	rjmp	.+50     	; 0x1606 <vTaskIncrementTick+0x114>
    15d4:	8f ef       	ldi	r24, 0xFF	; 255
    15d6:	9f ef       	ldi	r25, 0xFF	; 255
    15d8:	90 93 8a 00 	sts	0x008A, r25
    15dc:	80 93 89 00 	sts	0x0089, r24
    15e0:	49 c0       	rjmp	.+146    	; 0x1674 <vTaskIncrementTick+0x182>
    15e2:	e0 91 2f 03 	lds	r30, 0x032F
    15e6:	f0 91 30 03 	lds	r31, 0x0330
    15ea:	05 80       	ldd	r0, Z+5	; 0x05
    15ec:	f6 81       	ldd	r31, Z+6	; 0x06
    15ee:	e0 2d       	mov	r30, r0
    15f0:	c6 81       	ldd	r28, Z+6	; 0x06
    15f2:	d7 81       	ldd	r29, Z+7	; 0x07
    15f4:	8a 81       	ldd	r24, Y+2	; 0x02
    15f6:	9b 81       	ldd	r25, Y+3	; 0x03
    15f8:	20 91 29 03 	lds	r18, 0x0329
    15fc:	30 91 2a 03 	lds	r19, 0x032A
    1600:	28 17       	cp	r18, r24
    1602:	39 07       	cpc	r19, r25
    1604:	28 f4       	brcc	.+10     	; 0x1610 <vTaskIncrementTick+0x11e>
    1606:	90 93 8a 00 	sts	0x008A, r25
    160a:	80 93 89 00 	sts	0x0089, r24
    160e:	32 c0       	rjmp	.+100    	; 0x1674 <vTaskIncrementTick+0x182>
    1610:	8e 01       	movw	r16, r28
    1612:	0e 5f       	subi	r16, 0xFE	; 254
    1614:	1f 4f       	sbci	r17, 0xFF	; 255
    1616:	c8 01       	movw	r24, r16
    1618:	0e 94 ab 03 	call	0x756	; 0x756 <vListRemove>
    161c:	8c 89       	ldd	r24, Y+20	; 0x14
    161e:	9d 89       	ldd	r25, Y+21	; 0x15
    1620:	00 97       	sbiw	r24, 0x00	; 0
    1622:	21 f0       	breq	.+8      	; 0x162c <vTaskIncrementTick+0x13a>
    1624:	ce 01       	movw	r24, r28
    1626:	0c 96       	adiw	r24, 0x0c	; 12
    1628:	0e 94 ab 03 	call	0x756	; 0x756 <vListRemove>
    162c:	8e 89       	ldd	r24, Y+22	; 0x16
    162e:	90 91 28 03 	lds	r25, 0x0328
    1632:	98 17       	cp	r25, r24
    1634:	10 f4       	brcc	.+4      	; 0x163a <vTaskIncrementTick+0x148>
    1636:	80 93 28 03 	sts	0x0328, r24
    163a:	90 e0       	ldi	r25, 0x00	; 0
    163c:	9c 01       	movw	r18, r24
    163e:	22 0f       	add	r18, r18
    1640:	33 1f       	adc	r19, r19
    1642:	22 0f       	add	r18, r18
    1644:	33 1f       	adc	r19, r19
    1646:	22 0f       	add	r18, r18
    1648:	33 1f       	adc	r19, r19
    164a:	82 0f       	add	r24, r18
    164c:	93 1f       	adc	r25, r19
    164e:	8d 5c       	subi	r24, 0xCD	; 205
    1650:	9c 4f       	sbci	r25, 0xFC	; 252
    1652:	b8 01       	movw	r22, r16
    1654:	0e 94 45 03 	call	0x68a	; 0x68a <vListInsertEnd>
    1658:	e0 91 2f 03 	lds	r30, 0x032F
    165c:	f0 91 30 03 	lds	r31, 0x0330
    1660:	80 81       	ld	r24, Z
    1662:	88 23       	and	r24, r24
    1664:	09 f0       	breq	.+2      	; 0x1668 <vTaskIncrementTick+0x176>
    1666:	bd cf       	rjmp	.-134    	; 0x15e2 <vTaskIncrementTick+0xf0>
    1668:	b5 cf       	rjmp	.-150    	; 0x15d4 <vTaskIncrementTick+0xe2>
	}
	else
	{
		++uxMissedTicks;
    166a:	80 91 25 03 	lds	r24, 0x0325
    166e:	8f 5f       	subi	r24, 0xFF	; 255
    1670:	80 93 25 03 	sts	0x0325, r24
		}
	}
	#endif

	traceTASK_INCREMENT_TICK( xTickCount );
}
    1674:	df 91       	pop	r29
    1676:	cf 91       	pop	r28
    1678:	1f 91       	pop	r17
    167a:	0f 91       	pop	r16
    167c:	08 95       	ret

0000167e <xTaskResumeAll>:
	++uxSchedulerSuspended;
}
/*----------------------------------------------------------*/

signed portBASE_TYPE xTaskResumeAll( void )
{
    167e:	af 92       	push	r10
    1680:	bf 92       	push	r11
    1682:	cf 92       	push	r12
    1684:	df 92       	push	r13
    1686:	ef 92       	push	r14
    1688:	ff 92       	push	r15
    168a:	0f 93       	push	r16
    168c:	1f 93       	push	r17
    168e:	cf 93       	push	r28
    1690:	df 93       	push	r29
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
    1692:	0f b6       	in	r0, 0x3f	; 63
    1694:	f8 94       	cli
    1696:	0f 92       	push	r0
	{
		--uxSchedulerSuspended;
    1698:	80 91 26 03 	lds	r24, 0x0326
    169c:	81 50       	subi	r24, 0x01	; 1
    169e:	80 93 26 03 	sts	0x0326, r24

		if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    16a2:	80 91 26 03 	lds	r24, 0x0326
    16a6:	88 23       	and	r24, r24
    16a8:	09 f0       	breq	.+2      	; 0x16ac <xTaskResumeAll+0x2e>
    16aa:	69 c0       	rjmp	.+210    	; 0x177e <xTaskResumeAll+0x100>
		{
			if( uxCurrentNumberOfTasks > ( unsigned portBASE_TYPE ) 0U )
    16ac:	80 91 2b 03 	lds	r24, 0x032B
    16b0:	88 23       	and	r24, r24
    16b2:	81 f5       	brne	.+96     	; 0x1714 <xTaskResumeAll+0x96>
    16b4:	67 c0       	rjmp	.+206    	; 0x1784 <xTaskResumeAll+0x106>

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) );
    16b6:	d6 01       	movw	r26, r12
    16b8:	ed 91       	ld	r30, X+
    16ba:	fc 91       	ld	r31, X
    16bc:	c6 81       	ldd	r28, Z+6	; 0x06
    16be:	d7 81       	ldd	r29, Z+7	; 0x07
					vListRemove( &( pxTCB->xEventListItem ) );
    16c0:	ce 01       	movw	r24, r28
    16c2:	0c 96       	adiw	r24, 0x0c	; 12
    16c4:	0e 94 ab 03 	call	0x756	; 0x756 <vListRemove>
					vListRemove( &( pxTCB->xGenericListItem ) );
    16c8:	8e 01       	movw	r16, r28
    16ca:	0e 5f       	subi	r16, 0xFE	; 254
    16cc:	1f 4f       	sbci	r17, 0xFF	; 255
    16ce:	c8 01       	movw	r24, r16
    16d0:	0e 94 ab 03 	call	0x756	; 0x756 <vListRemove>
					prvAddTaskToReadyQueue( pxTCB );
    16d4:	8e 89       	ldd	r24, Y+22	; 0x16
    16d6:	90 91 28 03 	lds	r25, 0x0328
    16da:	98 17       	cp	r25, r24
    16dc:	10 f4       	brcc	.+4      	; 0x16e2 <xTaskResumeAll+0x64>
    16de:	80 93 28 03 	sts	0x0328, r24
    16e2:	90 e0       	ldi	r25, 0x00	; 0
    16e4:	9c 01       	movw	r18, r24
    16e6:	22 0f       	add	r18, r18
    16e8:	33 1f       	adc	r19, r19
    16ea:	22 0f       	add	r18, r18
    16ec:	33 1f       	adc	r19, r19
    16ee:	22 0f       	add	r18, r18
    16f0:	33 1f       	adc	r19, r19
    16f2:	82 0f       	add	r24, r18
    16f4:	93 1f       	adc	r25, r19
    16f6:	8d 5c       	subi	r24, 0xCD	; 205
    16f8:	9c 4f       	sbci	r25, 0xFC	; 252
    16fa:	b8 01       	movw	r22, r16
    16fc:	0e 94 45 03 	call	0x68a	; 0x68a <vListInsertEnd>

					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    1700:	e0 91 21 03 	lds	r30, 0x0321
    1704:	f0 91 22 03 	lds	r31, 0x0322
    1708:	9e 89       	ldd	r25, Y+22	; 0x16
    170a:	86 89       	ldd	r24, Z+22	; 0x16
    170c:	98 17       	cp	r25, r24
    170e:	88 f0       	brcs	.+34     	; 0x1732 <xTaskResumeAll+0xb4>
					{
						xYieldRequired = pdTRUE;
    1710:	ba 2c       	mov	r11, r10
    1712:	0f c0       	rjmp	.+30     	; 0x1732 <xTaskResumeAll+0xb4>
	{
		--uxSchedulerSuspended;

		if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
		{
			if( uxCurrentNumberOfTasks > ( unsigned portBASE_TYPE ) 0U )
    1714:	bb 24       	eor	r11, r11
			{
				portBASE_TYPE xYieldRequired = pdFALSE;

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
    1716:	0f 2e       	mov	r0, r31
    1718:	f0 e6       	ldi	r31, 0x60	; 96
    171a:	ef 2e       	mov	r14, r31
    171c:	f3 e0       	ldi	r31, 0x03	; 3
    171e:	ff 2e       	mov	r15, r31
    1720:	f0 2d       	mov	r31, r0
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) );
    1722:	0f 2e       	mov	r0, r31
    1724:	f5 e6       	ldi	r31, 0x65	; 101
    1726:	cf 2e       	mov	r12, r31
    1728:	f3 e0       	ldi	r31, 0x03	; 3
    172a:	df 2e       	mov	r13, r31
    172c:	f0 2d       	mov	r31, r0

					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
					{
						xYieldRequired = pdTRUE;
    172e:	aa 24       	eor	r10, r10
    1730:	a3 94       	inc	r10
			{
				portBASE_TYPE xYieldRequired = pdFALSE;

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
    1732:	f7 01       	movw	r30, r14
    1734:	80 81       	ld	r24, Z
    1736:	88 23       	and	r24, r24
    1738:	09 f0       	breq	.+2      	; 0x173c <xTaskResumeAll+0xbe>
    173a:	bd cf       	rjmp	.-134    	; 0x16b6 <xTaskResumeAll+0x38>
				}

				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
    173c:	80 91 25 03 	lds	r24, 0x0325
    1740:	88 23       	and	r24, r24
    1742:	81 f0       	breq	.+32     	; 0x1764 <xTaskResumeAll+0xe6>
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
    1744:	80 91 25 03 	lds	r24, 0x0325
    1748:	88 23       	and	r24, r24
    174a:	99 f0       	breq	.+38     	; 0x1772 <xTaskResumeAll+0xf4>
					{
						vTaskIncrementTick();
    174c:	0e 94 79 0a 	call	0x14f2	; 0x14f2 <vTaskIncrementTick>
						--uxMissedTicks;
    1750:	80 91 25 03 	lds	r24, 0x0325
    1754:	81 50       	subi	r24, 0x01	; 1
    1756:	80 93 25 03 	sts	0x0325, r24
				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
    175a:	80 91 25 03 	lds	r24, 0x0325
    175e:	88 23       	and	r24, r24
    1760:	a9 f7       	brne	.-22     	; 0x174c <xTaskResumeAll+0xce>
    1762:	07 c0       	rjmp	.+14     	; 0x1772 <xTaskResumeAll+0xf4>
						xYieldRequired = pdTRUE;
					}
					#endif
				}

				if( ( xYieldRequired == pdTRUE ) || ( xMissedYield == pdTRUE ) )
    1764:	f1 e0       	ldi	r31, 0x01	; 1
    1766:	bf 16       	cp	r11, r31
    1768:	21 f0       	breq	.+8      	; 0x1772 <xTaskResumeAll+0xf4>
    176a:	80 91 24 03 	lds	r24, 0x0324
    176e:	81 30       	cpi	r24, 0x01	; 1
    1770:	41 f4       	brne	.+16     	; 0x1782 <xTaskResumeAll+0x104>
				{
					xAlreadyYielded = pdTRUE;
					xMissedYield = pdFALSE;
    1772:	10 92 24 03 	sts	0x0324, r1
					portYIELD_WITHIN_API();
    1776:	0e 94 97 04 	call	0x92e	; 0x92e <vPortYield>
					#endif
				}

				if( ( xYieldRequired == pdTRUE ) || ( xMissedYield == pdTRUE ) )
				{
					xAlreadyYielded = pdTRUE;
    177a:	81 e0       	ldi	r24, 0x01	; 1
    177c:	03 c0       	rjmp	.+6      	; 0x1784 <xTaskResumeAll+0x106>
/*----------------------------------------------------------*/

signed portBASE_TYPE xTaskResumeAll( void )
{
register tskTCB *pxTCB;
signed portBASE_TYPE xAlreadyYielded = pdFALSE;
    177e:	80 e0       	ldi	r24, 0x00	; 0
    1780:	01 c0       	rjmp	.+2      	; 0x1784 <xTaskResumeAll+0x106>
    1782:	80 e0       	ldi	r24, 0x00	; 0
					portYIELD_WITHIN_API();
				}
			}
		}
	}
	taskEXIT_CRITICAL();
    1784:	0f 90       	pop	r0
    1786:	0f be       	out	0x3f, r0	; 63

	return xAlreadyYielded;
}
    1788:	df 91       	pop	r29
    178a:	cf 91       	pop	r28
    178c:	1f 91       	pop	r17
    178e:	0f 91       	pop	r16
    1790:	ff 90       	pop	r15
    1792:	ef 90       	pop	r14
    1794:	df 90       	pop	r13
    1796:	cf 90       	pop	r12
    1798:	bf 90       	pop	r11
    179a:	af 90       	pop	r10
    179c:	08 95       	ret

0000179e <prvIdleTask>:
		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		if( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0U )
		{
			vTaskSuspendAll();
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
    179e:	09 e6       	ldi	r16, 0x69	; 105
    17a0:	13 e0       	ldi	r17, 0x03	; 3
			{
				tskTCB *pxTCB;

				taskENTER_CRITICAL();
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( ( ( xList * ) &xTasksWaitingTermination ) );
    17a2:	0f 2e       	mov	r0, r31
    17a4:	fe e6       	ldi	r31, 0x6E	; 110
    17a6:	ef 2e       	mov	r14, r31
    17a8:	f3 e0       	ldi	r31, 0x03	; 3
    17aa:	ff 2e       	mov	r15, r31
    17ac:	f0 2d       	mov	r31, r0
	{
		portBASE_TYPE xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		if( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0U )
    17ae:	80 91 2c 03 	lds	r24, 0x032C
    17b2:	88 23       	and	r24, r24
    17b4:	e1 f3       	breq	.-8      	; 0x17ae <prvIdleTask+0x10>
		{
			vTaskSuspendAll();
    17b6:	0e 94 61 0a 	call	0x14c2	; 0x14c2 <vTaskSuspendAll>
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
    17ba:	d8 01       	movw	r26, r16
    17bc:	cc 91       	ld	r28, X
			xTaskResumeAll();
    17be:	0e 94 3f 0b 	call	0x167e	; 0x167e <xTaskResumeAll>

			if( xListIsEmpty == pdFALSE )
    17c2:	cc 23       	and	r28, r28
    17c4:	a1 f3       	breq	.-24     	; 0x17ae <prvIdleTask+0x10>
			{
				tskTCB *pxTCB;

				taskENTER_CRITICAL();
    17c6:	0f b6       	in	r0, 0x3f	; 63
    17c8:	f8 94       	cli
    17ca:	0f 92       	push	r0
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( ( ( xList * ) &xTasksWaitingTermination ) );
    17cc:	d7 01       	movw	r26, r14
    17ce:	ed 91       	ld	r30, X+
    17d0:	fc 91       	ld	r31, X
    17d2:	c6 81       	ldd	r28, Z+6	; 0x06
    17d4:	d7 81       	ldd	r29, Z+7	; 0x07
					vListRemove( &( pxTCB->xGenericListItem ) );
    17d6:	ce 01       	movw	r24, r28
    17d8:	02 96       	adiw	r24, 0x02	; 2
    17da:	0e 94 ab 03 	call	0x756	; 0x756 <vListRemove>
					--uxCurrentNumberOfTasks;
    17de:	80 91 2b 03 	lds	r24, 0x032B
    17e2:	81 50       	subi	r24, 0x01	; 1
    17e4:	80 93 2b 03 	sts	0x032B, r24
					--uxTasksDeleted;
    17e8:	80 91 2c 03 	lds	r24, 0x032C
    17ec:	81 50       	subi	r24, 0x01	; 1
    17ee:	80 93 2c 03 	sts	0x032C, r24
				}
				taskEXIT_CRITICAL();
    17f2:	0f 90       	pop	r0
    17f4:	0f be       	out	0x3f, r0	; 63

	static void prvDeleteTCB( tskTCB *pxTCB )
	{
		/* Free up the memory allocated by the scheduler for the task.  It is up to
		the task to free any memory allocated at the application level. */
		vPortFreeAligned( pxTCB->pxStack );
    17f6:	8f 89       	ldd	r24, Y+23	; 0x17
    17f8:	98 8d       	ldd	r25, Y+24	; 0x18
    17fa:	0e 94 97 02 	call	0x52e	; 0x52e <vPortFree>
		vPortFree( pxTCB );
    17fe:	ce 01       	movw	r24, r28
    1800:	0e 94 97 02 	call	0x52e	; 0x52e <vPortFree>
    1804:	d4 cf       	rjmp	.-88     	; 0x17ae <prvIdleTask+0x10>

00001806 <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( portTickType xTicksToDelay )
	{
    1806:	cf 93       	push	r28
    1808:	df 93       	push	r29
    180a:	ec 01       	movw	r28, r24
	portTickType xTimeToWake;
	signed portBASE_TYPE xAlreadyYielded = pdFALSE;

		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( portTickType ) 0U )
    180c:	00 97       	sbiw	r24, 0x00	; 0
    180e:	b1 f0       	breq	.+44     	; 0x183c <vTaskDelay+0x36>
		{
			vTaskSuspendAll();
    1810:	0e 94 61 0a 	call	0x14c2	; 0x14c2 <vTaskSuspendAll>
				This task cannot be in an event list as it is the currently
				executing task. */

				/* Calculate the time to wake - this may overflow but this is
				not a problem. */
				xTimeToWake = xTickCount + xTicksToDelay;
    1814:	80 91 29 03 	lds	r24, 0x0329
    1818:	90 91 2a 03 	lds	r25, 0x032A
    181c:	c8 0f       	add	r28, r24
    181e:	d9 1f       	adc	r29, r25

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    1820:	80 91 21 03 	lds	r24, 0x0321
    1824:	90 91 22 03 	lds	r25, 0x0322
    1828:	02 96       	adiw	r24, 0x02	; 2
    182a:	0e 94 ab 03 	call	0x756	; 0x756 <vListRemove>
				prvAddCurrentTaskToDelayedList( xTimeToWake );
    182e:	ce 01       	movw	r24, r28
    1830:	0e 94 9d 08 	call	0x113a	; 0x113a <prvAddCurrentTaskToDelayedList>
			}
			xAlreadyYielded = xTaskResumeAll();
    1834:	0e 94 3f 0b 	call	0x167e	; 0x167e <xTaskResumeAll>
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    1838:	88 23       	and	r24, r24
    183a:	11 f4       	brne	.+4      	; 0x1840 <vTaskDelay+0x3a>
		{
			portYIELD_WITHIN_API();
    183c:	0e 94 97 04 	call	0x92e	; 0x92e <vPortYield>
		}
	}
    1840:	df 91       	pop	r29
    1842:	cf 91       	pop	r28
    1844:	08 95       	ret

00001846 <vTaskDelayUntil>:
 *----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelayUntil == 1 )

	void vTaskDelayUntil( portTickType * const pxPreviousWakeTime, portTickType xTimeIncrement )
	{
    1846:	0f 93       	push	r16
    1848:	1f 93       	push	r17
    184a:	cf 93       	push	r28
    184c:	df 93       	push	r29
    184e:	8c 01       	movw	r16, r24
    1850:	eb 01       	movw	r28, r22
	portBASE_TYPE xAlreadyYielded, xShouldDelay = pdFALSE;

		configASSERT( pxPreviousWakeTime );
		configASSERT( ( xTimeIncrement > 0U ) );

		vTaskSuspendAll();
    1852:	0e 94 61 0a 	call	0x14c2	; 0x14c2 <vTaskSuspendAll>
		{
			/* Generate the tick time at which the task wants to wake. */
			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
    1856:	f8 01       	movw	r30, r16
    1858:	80 81       	ld	r24, Z
    185a:	91 81       	ldd	r25, Z+1	; 0x01
    185c:	c8 0f       	add	r28, r24
    185e:	d9 1f       	adc	r29, r25

			if( xTickCount < *pxPreviousWakeTime )
    1860:	20 91 29 03 	lds	r18, 0x0329
    1864:	30 91 2a 03 	lds	r19, 0x032A
    1868:	28 17       	cp	r18, r24
    186a:	39 07       	cpc	r19, r25
    186c:	68 f4       	brcc	.+26     	; 0x1888 <vTaskDelayUntil+0x42>
				/* The tick count has overflowed since this function was
				lasted called.  In this case the only time we should ever
				actually delay is if the wake time has also	overflowed,
				and the wake time is greater than the tick time.  When this
				is the case it is as if neither time had overflowed. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xTickCount ) )
    186e:	c8 17       	cp	r28, r24
    1870:	d9 07       	cpc	r29, r25
    1872:	50 f5       	brcc	.+84     	; 0x18c8 <vTaskDelayUntil+0x82>
    1874:	80 91 29 03 	lds	r24, 0x0329
    1878:	90 91 2a 03 	lds	r25, 0x032A
					xShouldDelay = pdTRUE;
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
    187c:	d1 83       	std	Z+1, r29	; 0x01
    187e:	c0 83       	st	Z, r28

			if( xShouldDelay != pdFALSE )
    1880:	8c 17       	cp	r24, r28
    1882:	9d 07       	cpc	r25, r29
    1884:	b0 f4       	brcc	.+44     	; 0x18b2 <vTaskDelayUntil+0x6c>
    1886:	0b c0       	rjmp	.+22     	; 0x189e <vTaskDelayUntil+0x58>
			else
			{
				/* The tick time has not overflowed.  In this case we will
				delay if either the wake time has overflowed, and/or the
				tick time is less than the wake time. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xTickCount ) )
    1888:	c8 17       	cp	r28, r24
    188a:	d9 07       	cpc	r29, r25
    188c:	c8 f0       	brcs	.+50     	; 0x18c0 <vTaskDelayUntil+0x7a>
    188e:	80 91 29 03 	lds	r24, 0x0329
    1892:	90 91 2a 03 	lds	r25, 0x032A
    1896:	8c 17       	cp	r24, r28
    1898:	9d 07       	cpc	r25, r29
    189a:	90 f0       	brcs	.+36     	; 0x18c0 <vTaskDelayUntil+0x7a>
    189c:	15 c0       	rjmp	.+42     	; 0x18c8 <vTaskDelayUntil+0x82>
				traceTASK_DELAY_UNTIL();

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    189e:	80 91 21 03 	lds	r24, 0x0321
    18a2:	90 91 22 03 	lds	r25, 0x0322
    18a6:	02 96       	adiw	r24, 0x02	; 2
    18a8:	0e 94 ab 03 	call	0x756	; 0x756 <vListRemove>
				prvAddCurrentTaskToDelayedList( xTimeToWake );
    18ac:	ce 01       	movw	r24, r28
    18ae:	0e 94 9d 08 	call	0x113a	; 0x113a <prvAddCurrentTaskToDelayedList>
			}
		}
		xAlreadyYielded = xTaskResumeAll();
    18b2:	0e 94 3f 0b 	call	0x167e	; 0x167e <xTaskResumeAll>

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    18b6:	88 23       	and	r24, r24
    18b8:	59 f4       	brne	.+22     	; 0x18d0 <vTaskDelayUntil+0x8a>
		{
			portYIELD_WITHIN_API();
    18ba:	0e 94 97 04 	call	0x92e	; 0x92e <vPortYield>
    18be:	08 c0       	rjmp	.+16     	; 0x18d0 <vTaskDelayUntil+0x8a>
					xShouldDelay = pdTRUE;
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
    18c0:	f8 01       	movw	r30, r16
    18c2:	d1 83       	std	Z+1, r29	; 0x01
    18c4:	c0 83       	st	Z, r28
    18c6:	eb cf       	rjmp	.-42     	; 0x189e <vTaskDelayUntil+0x58>
    18c8:	f8 01       	movw	r30, r16
    18ca:	d1 83       	std	Z+1, r29	; 0x01
    18cc:	c0 83       	st	Z, r28
    18ce:	f1 cf       	rjmp	.-30     	; 0x18b2 <vTaskDelayUntil+0x6c>
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
		{
			portYIELD_WITHIN_API();
		}
	}
    18d0:	df 91       	pop	r29
    18d2:	cf 91       	pop	r28
    18d4:	1f 91       	pop	r17
    18d6:	0f 91       	pop	r16
    18d8:	08 95       	ret

000018da <vTaskSwitchContext>:
#endif
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
    18da:	80 91 26 03 	lds	r24, 0x0326
    18de:	88 23       	and	r24, r24
    18e0:	99 f4       	brne	.+38     	; 0x1908 <vTaskSwitchContext+0x2e>
	
		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();
	
		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
    18e2:	80 91 28 03 	lds	r24, 0x0328
    18e6:	90 e0       	ldi	r25, 0x00	; 0
    18e8:	fc 01       	movw	r30, r24
    18ea:	ee 0f       	add	r30, r30
    18ec:	ff 1f       	adc	r31, r31
    18ee:	ee 0f       	add	r30, r30
    18f0:	ff 1f       	adc	r31, r31
    18f2:	ee 0f       	add	r30, r30
    18f4:	ff 1f       	adc	r31, r31
    18f6:	8e 0f       	add	r24, r30
    18f8:	9f 1f       	adc	r25, r31
    18fa:	fc 01       	movw	r30, r24
    18fc:	ed 5c       	subi	r30, 0xCD	; 205
    18fe:	fc 4f       	sbci	r31, 0xFC	; 252
    1900:	80 81       	ld	r24, Z
    1902:	88 23       	and	r24, r24
    1904:	29 f0       	breq	.+10     	; 0x1910 <vTaskSwitchContext+0x36>
    1906:	1b c0       	rjmp	.+54     	; 0x193e <vTaskSwitchContext+0x64>
{
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xMissedYield = pdTRUE;
    1908:	81 e0       	ldi	r24, 0x01	; 1
    190a:	80 93 24 03 	sts	0x0324, r24
    190e:	08 95       	ret
	
		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
		{
			configASSERT( uxTopReadyPriority );
			--uxTopReadyPriority;
    1910:	80 91 28 03 	lds	r24, 0x0328
    1914:	81 50       	subi	r24, 0x01	; 1
    1916:	80 93 28 03 	sts	0x0328, r24
	
		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();
	
		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
    191a:	80 91 28 03 	lds	r24, 0x0328
    191e:	90 e0       	ldi	r25, 0x00	; 0
    1920:	fc 01       	movw	r30, r24
    1922:	ee 0f       	add	r30, r30
    1924:	ff 1f       	adc	r31, r31
    1926:	ee 0f       	add	r30, r30
    1928:	ff 1f       	adc	r31, r31
    192a:	ee 0f       	add	r30, r30
    192c:	ff 1f       	adc	r31, r31
    192e:	8e 0f       	add	r24, r30
    1930:	9f 1f       	adc	r25, r31
    1932:	fc 01       	movw	r30, r24
    1934:	ed 5c       	subi	r30, 0xCD	; 205
    1936:	fc 4f       	sbci	r31, 0xFC	; 252
    1938:	80 81       	ld	r24, Z
    193a:	88 23       	and	r24, r24
    193c:	49 f3       	breq	.-46     	; 0x1910 <vTaskSwitchContext+0x36>
			--uxTopReadyPriority;
		}
	
		/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the tasks of the
		same priority get an equal share of the processor time. */
		listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopReadyPriority ] ) );
    193e:	80 91 28 03 	lds	r24, 0x0328
    1942:	90 e0       	ldi	r25, 0x00	; 0
    1944:	fc 01       	movw	r30, r24
    1946:	ee 0f       	add	r30, r30
    1948:	ff 1f       	adc	r31, r31
    194a:	ee 0f       	add	r30, r30
    194c:	ff 1f       	adc	r31, r31
    194e:	ee 0f       	add	r30, r30
    1950:	ff 1f       	adc	r31, r31
    1952:	e8 0f       	add	r30, r24
    1954:	f9 1f       	adc	r31, r25
    1956:	ed 5c       	subi	r30, 0xCD	; 205
    1958:	fc 4f       	sbci	r31, 0xFC	; 252
    195a:	a1 81       	ldd	r26, Z+1	; 0x01
    195c:	b2 81       	ldd	r27, Z+2	; 0x02
    195e:	12 96       	adiw	r26, 0x02	; 2
    1960:	0d 90       	ld	r0, X+
    1962:	bc 91       	ld	r27, X
    1964:	a0 2d       	mov	r26, r0
    1966:	b2 83       	std	Z+2, r27	; 0x02
    1968:	a1 83       	std	Z+1, r26	; 0x01
    196a:	cf 01       	movw	r24, r30
    196c:	03 96       	adiw	r24, 0x03	; 3
    196e:	a8 17       	cp	r26, r24
    1970:	b9 07       	cpc	r27, r25
    1972:	31 f4       	brne	.+12     	; 0x1980 <vTaskSwitchContext+0xa6>
    1974:	12 96       	adiw	r26, 0x02	; 2
    1976:	8d 91       	ld	r24, X+
    1978:	9c 91       	ld	r25, X
    197a:	13 97       	sbiw	r26, 0x03	; 3
    197c:	92 83       	std	Z+2, r25	; 0x02
    197e:	81 83       	std	Z+1, r24	; 0x01
    1980:	01 80       	ldd	r0, Z+1	; 0x01
    1982:	f2 81       	ldd	r31, Z+2	; 0x02
    1984:	e0 2d       	mov	r30, r0
    1986:	86 81       	ldd	r24, Z+6	; 0x06
    1988:	97 81       	ldd	r25, Z+7	; 0x07
    198a:	90 93 22 03 	sts	0x0322, r25
    198e:	80 93 21 03 	sts	0x0321, r24
    1992:	08 95       	ret

00001994 <vTaskPlaceOnEventList>:
	}
}
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( const xList * const pxEventList, portTickType xTicksToWait )
{
    1994:	cf 93       	push	r28
    1996:	df 93       	push	r29
    1998:	eb 01       	movw	r28, r22
	SCHEDULER SUSPENDED. */

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event. */
	vListInsert( ( xList * ) pxEventList, ( xListItem * ) &( pxCurrentTCB->xEventListItem ) );
    199a:	60 91 21 03 	lds	r22, 0x0321
    199e:	70 91 22 03 	lds	r23, 0x0322
    19a2:	64 5f       	subi	r22, 0xF4	; 244
    19a4:	7f 4f       	sbci	r23, 0xFF	; 255
    19a6:	0e 94 6e 03 	call	0x6dc	; 0x6dc <vListInsert>

	/* We must remove ourselves from the ready list before adding ourselves
	to the blocked list as the same list item is used for both lists.  We have
	exclusive access to the ready lists as the scheduler is locked. */
	vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    19aa:	80 91 21 03 	lds	r24, 0x0321
    19ae:	90 91 22 03 	lds	r25, 0x0322
    19b2:	02 96       	adiw	r24, 0x02	; 2
    19b4:	0e 94 ab 03 	call	0x756	; 0x756 <vListRemove>
	}
	#else
	{
			/* Calculate the time at which the task should be woken if the event does
			not occur.  This may overflow but this doesn't matter. */
			xTimeToWake = xTickCount + xTicksToWait;
    19b8:	80 91 29 03 	lds	r24, 0x0329
    19bc:	90 91 2a 03 	lds	r25, 0x032A
			prvAddCurrentTaskToDelayedList( xTimeToWake );
    19c0:	8c 0f       	add	r24, r28
    19c2:	9d 1f       	adc	r25, r29
    19c4:	0e 94 9d 08 	call	0x113a	; 0x113a <prvAddCurrentTaskToDelayedList>
	}
	#endif
}
    19c8:	df 91       	pop	r29
    19ca:	cf 91       	pop	r28
    19cc:	08 95       	ret

000019ce <xTaskRemoveFromEventList>:
	
#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xTaskRemoveFromEventList( const xList * const pxEventList )
{
    19ce:	0f 93       	push	r16
    19d0:	1f 93       	push	r17
    19d2:	cf 93       	push	r28
    19d4:	df 93       	push	r29
	get called - the lock count on the queue will get modified instead.  This
	means we can always expect exclusive access to the event list here.
	
	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
    19d6:	dc 01       	movw	r26, r24
    19d8:	15 96       	adiw	r26, 0x05	; 5
    19da:	ed 91       	ld	r30, X+
    19dc:	fc 91       	ld	r31, X
    19de:	16 97       	sbiw	r26, 0x06	; 6
    19e0:	06 81       	ldd	r16, Z+6	; 0x06
    19e2:	17 81       	ldd	r17, Z+7	; 0x07
	configASSERT( pxUnblockedTCB );
	vListRemove( &( pxUnblockedTCB->xEventListItem ) );
    19e4:	e8 01       	movw	r28, r16
    19e6:	2c 96       	adiw	r28, 0x0c	; 12
    19e8:	ce 01       	movw	r24, r28
    19ea:	0e 94 ab 03 	call	0x756	; 0x756 <vListRemove>

	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    19ee:	80 91 26 03 	lds	r24, 0x0326
    19f2:	88 23       	and	r24, r24
    19f4:	e9 f4       	brne	.+58     	; 0x1a30 <xTaskRemoveFromEventList+0x62>
	{
		vListRemove( &( pxUnblockedTCB->xGenericListItem ) );
    19f6:	e8 01       	movw	r28, r16
    19f8:	22 96       	adiw	r28, 0x02	; 2
    19fa:	ce 01       	movw	r24, r28
    19fc:	0e 94 ab 03 	call	0x756	; 0x756 <vListRemove>
		prvAddTaskToReadyQueue( pxUnblockedTCB );
    1a00:	f8 01       	movw	r30, r16
    1a02:	86 89       	ldd	r24, Z+22	; 0x16
    1a04:	90 91 28 03 	lds	r25, 0x0328
    1a08:	98 17       	cp	r25, r24
    1a0a:	10 f4       	brcc	.+4      	; 0x1a10 <xTaskRemoveFromEventList+0x42>
    1a0c:	80 93 28 03 	sts	0x0328, r24
    1a10:	90 e0       	ldi	r25, 0x00	; 0
    1a12:	9c 01       	movw	r18, r24
    1a14:	22 0f       	add	r18, r18
    1a16:	33 1f       	adc	r19, r19
    1a18:	22 0f       	add	r18, r18
    1a1a:	33 1f       	adc	r19, r19
    1a1c:	22 0f       	add	r18, r18
    1a1e:	33 1f       	adc	r19, r19
    1a20:	82 0f       	add	r24, r18
    1a22:	93 1f       	adc	r25, r19
    1a24:	8d 5c       	subi	r24, 0xCD	; 205
    1a26:	9c 4f       	sbci	r25, 0xFC	; 252
    1a28:	be 01       	movw	r22, r28
    1a2a:	0e 94 45 03 	call	0x68a	; 0x68a <vListInsertEnd>
    1a2e:	05 c0       	rjmp	.+10     	; 0x1a3a <xTaskRemoveFromEventList+0x6c>
	}
	else
	{
		/* We cannot access the delayed or ready lists, so will hold this
		task pending until the scheduler is resumed. */
		vListInsertEnd( ( xList * ) &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
    1a30:	80 e6       	ldi	r24, 0x60	; 96
    1a32:	93 e0       	ldi	r25, 0x03	; 3
    1a34:	be 01       	movw	r22, r28
    1a36:	0e 94 45 03 	call	0x68a	; 0x68a <vListInsertEnd>
	}

	if( pxUnblockedTCB->uxPriority >= pxCurrentTCB->uxPriority )
    1a3a:	e0 91 21 03 	lds	r30, 0x0321
    1a3e:	f0 91 22 03 	lds	r31, 0x0322
	else
	{
		xReturn = pdFALSE;
	}

	return xReturn;
    1a42:	81 e0       	ldi	r24, 0x01	; 1
    1a44:	d8 01       	movw	r26, r16
    1a46:	56 96       	adiw	r26, 0x16	; 22
    1a48:	2c 91       	ld	r18, X
    1a4a:	56 97       	sbiw	r26, 0x16	; 22
    1a4c:	96 89       	ldd	r25, Z+22	; 0x16
    1a4e:	29 17       	cp	r18, r25
    1a50:	08 f4       	brcc	.+2      	; 0x1a54 <xTaskRemoveFromEventList+0x86>
    1a52:	80 e0       	ldi	r24, 0x00	; 0
}
    1a54:	df 91       	pop	r29
    1a56:	cf 91       	pop	r28
    1a58:	1f 91       	pop	r17
    1a5a:	0f 91       	pop	r16
    1a5c:	08 95       	ret

00001a5e <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( xTimeOutType * const pxTimeOut )
{
    1a5e:	fc 01       	movw	r30, r24
	configASSERT( pxTimeOut );
	pxTimeOut->xOverflowCount = xNumOfOverflows;
    1a60:	80 91 23 03 	lds	r24, 0x0323
    1a64:	80 83       	st	Z, r24
	pxTimeOut->xTimeOnEntering = xTickCount;
    1a66:	80 91 29 03 	lds	r24, 0x0329
    1a6a:	90 91 2a 03 	lds	r25, 0x032A
    1a6e:	92 83       	std	Z+2, r25	; 0x02
    1a70:	81 83       	std	Z+1, r24	; 0x01
}
    1a72:	08 95       	ret

00001a74 <xTaskCheckForTimeOut>:
/*-----------------------------------------------------------*/

portBASE_TYPE xTaskCheckForTimeOut( xTimeOutType * const pxTimeOut, portTickType * const pxTicksToWait )
{
    1a74:	fc 01       	movw	r30, r24
portBASE_TYPE xReturn;

	configASSERT( pxTimeOut );
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
    1a76:	0f b6       	in	r0, 0x3f	; 63
    1a78:	f8 94       	cli
    1a7a:	0f 92       	push	r0
				xReturn = pdFALSE;
			}
			else /* We are not blocking indefinitely, perform the checks below. */
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( ( portTickType ) xTickCount >= ( portTickType ) pxTimeOut->xTimeOnEntering ) )
    1a7c:	80 91 23 03 	lds	r24, 0x0323
    1a80:	90 81       	ld	r25, Z
    1a82:	98 17       	cp	r25, r24
    1a84:	49 f0       	breq	.+18     	; 0x1a98 <xTaskCheckForTimeOut+0x24>
    1a86:	80 91 29 03 	lds	r24, 0x0329
    1a8a:	90 91 2a 03 	lds	r25, 0x032A
    1a8e:	21 81       	ldd	r18, Z+1	; 0x01
    1a90:	32 81       	ldd	r19, Z+2	; 0x02
    1a92:	82 17       	cp	r24, r18
    1a94:	93 07       	cpc	r25, r19
    1a96:	f0 f4       	brcc	.+60     	; 0x1ad4 <xTaskCheckForTimeOut+0x60>
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
		}
		else if( ( ( portTickType ) ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering ) ) < ( portTickType ) *pxTicksToWait )
    1a98:	80 91 29 03 	lds	r24, 0x0329
    1a9c:	90 91 2a 03 	lds	r25, 0x032A
    1aa0:	21 81       	ldd	r18, Z+1	; 0x01
    1aa2:	32 81       	ldd	r19, Z+2	; 0x02
    1aa4:	db 01       	movw	r26, r22
    1aa6:	4d 91       	ld	r20, X+
    1aa8:	5c 91       	ld	r21, X
    1aaa:	11 97       	sbiw	r26, 0x01	; 1
    1aac:	82 1b       	sub	r24, r18
    1aae:	93 0b       	sbc	r25, r19
    1ab0:	84 17       	cp	r24, r20
    1ab2:	95 07       	cpc	r25, r21
    1ab4:	88 f4       	brcc	.+34     	; 0x1ad8 <xTaskCheckForTimeOut+0x64>
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering );
    1ab6:	80 91 29 03 	lds	r24, 0x0329
    1aba:	90 91 2a 03 	lds	r25, 0x032A
    1abe:	28 1b       	sub	r18, r24
    1ac0:	39 0b       	sbc	r19, r25
    1ac2:	24 0f       	add	r18, r20
    1ac4:	35 1f       	adc	r19, r21
    1ac6:	2d 93       	st	X+, r18
    1ac8:	3c 93       	st	X, r19
			vTaskSetTimeOutState( pxTimeOut );
    1aca:	cf 01       	movw	r24, r30
    1acc:	0e 94 2f 0d 	call	0x1a5e	; 0x1a5e <vTaskSetTimeOutState>
			xReturn = pdFALSE;
    1ad0:	80 e0       	ldi	r24, 0x00	; 0
    1ad2:	03 c0       	rjmp	.+6      	; 0x1ada <xTaskCheckForTimeOut+0x66>
		{
			/* The tick count is greater than the time at which vTaskSetTimeout()
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
    1ad4:	81 e0       	ldi	r24, 0x01	; 1
    1ad6:	01 c0       	rjmp	.+2      	; 0x1ada <xTaskCheckForTimeOut+0x66>
			vTaskSetTimeOutState( pxTimeOut );
			xReturn = pdFALSE;
		}
		else
		{
			xReturn = pdTRUE;
    1ad8:	81 e0       	ldi	r24, 0x01	; 1
		}
	}
	taskEXIT_CRITICAL();
    1ada:	0f 90       	pop	r0
    1adc:	0f be       	out	0x3f, r0	; 63

	return xReturn;
}
    1ade:	08 95       	ret

00001ae0 <vTaskMissedYield>:
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
	xMissedYield = pdTRUE;
    1ae0:	81 e0       	ldi	r24, 0x01	; 1
    1ae2:	80 93 24 03 	sts	0x0324, r24
}
    1ae6:	08 95       	ret

00001ae8 <memcpy>:
    1ae8:	fb 01       	movw	r30, r22
    1aea:	dc 01       	movw	r26, r24
    1aec:	02 c0       	rjmp	.+4      	; 0x1af2 <memcpy+0xa>
    1aee:	01 90       	ld	r0, Z+
    1af0:	0d 92       	st	X+, r0
    1af2:	41 50       	subi	r20, 0x01	; 1
    1af4:	50 40       	sbci	r21, 0x00	; 0
    1af6:	d8 f7       	brcc	.-10     	; 0x1aee <memcpy+0x6>
    1af8:	08 95       	ret

00001afa <memset>:
    1afa:	dc 01       	movw	r26, r24
    1afc:	01 c0       	rjmp	.+2      	; 0x1b00 <memset+0x6>
    1afe:	6d 93       	st	X+, r22
    1b00:	41 50       	subi	r20, 0x01	; 1
    1b02:	50 40       	sbci	r21, 0x00	; 0
    1b04:	e0 f7       	brcc	.-8      	; 0x1afe <memset+0x4>
    1b06:	08 95       	ret

00001b08 <strncpy>:
    1b08:	fb 01       	movw	r30, r22
    1b0a:	dc 01       	movw	r26, r24
    1b0c:	41 50       	subi	r20, 0x01	; 1
    1b0e:	50 40       	sbci	r21, 0x00	; 0
    1b10:	48 f0       	brcs	.+18     	; 0x1b24 <strncpy+0x1c>
    1b12:	01 90       	ld	r0, Z+
    1b14:	0d 92       	st	X+, r0
    1b16:	00 20       	and	r0, r0
    1b18:	c9 f7       	brne	.-14     	; 0x1b0c <strncpy+0x4>
    1b1a:	01 c0       	rjmp	.+2      	; 0x1b1e <strncpy+0x16>
    1b1c:	1d 92       	st	X+, r1
    1b1e:	41 50       	subi	r20, 0x01	; 1
    1b20:	50 40       	sbci	r21, 0x00	; 0
    1b22:	e0 f7       	brcc	.-8      	; 0x1b1c <strncpy+0x14>
    1b24:	08 95       	ret

00001b26 <_exit>:
    1b26:	f8 94       	cli

00001b28 <__stop_program>:
    1b28:	ff cf       	rjmp	.-2      	; 0x1b28 <__stop_program>
