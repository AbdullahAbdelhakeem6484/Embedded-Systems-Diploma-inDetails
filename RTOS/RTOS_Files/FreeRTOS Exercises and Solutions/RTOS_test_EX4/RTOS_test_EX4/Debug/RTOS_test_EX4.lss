
RTOS_test_EX4.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00001a6c  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000012  00800060  00001a6c  00001b00  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          000002e8  00800072  00800072  00001b12  2**0
                  ALLOC
  3 .stab         00000888  00000000  00000000  00001b14  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      000001ac  00000000  00000000  0000239c  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_aranges 00000140  00000000  00000000  00002548  2**3
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00002283  00000000  00000000  00002688  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00000a7f  00000000  00000000  0000490b  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00000bbc  00000000  00000000  0000538a  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00000770  00000000  00000000  00005f48  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00000e47  00000000  00000000  000066b8  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00001f63  00000000  00000000  000074ff  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000090  00000000  00000000  00009462  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 2a 00 	jmp	0x54	; 0x54 <__ctors_end>
       4:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
       8:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
       c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      10:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      14:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      18:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      1c:	0c 94 be 04 	jmp	0x97c	; 0x97c <__vector_7>
      20:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      24:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      28:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      2c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      30:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      34:	0c 94 d6 07 	jmp	0xfac	; 0xfac <__vector_13>
      38:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      3c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      40:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      44:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      48:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      4c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      50:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>

00000054 <__ctors_end>:
      54:	11 24       	eor	r1, r1
      56:	1f be       	out	0x3f, r1	; 63
      58:	cf e5       	ldi	r28, 0x5F	; 95
      5a:	d8 e0       	ldi	r29, 0x08	; 8
      5c:	de bf       	out	0x3e, r29	; 62
      5e:	cd bf       	out	0x3d, r28	; 61

00000060 <__do_copy_data>:
      60:	10 e0       	ldi	r17, 0x00	; 0
      62:	a0 e6       	ldi	r26, 0x60	; 96
      64:	b0 e0       	ldi	r27, 0x00	; 0
      66:	ec e6       	ldi	r30, 0x6C	; 108
      68:	fa e1       	ldi	r31, 0x1A	; 26
      6a:	02 c0       	rjmp	.+4      	; 0x70 <__do_copy_data+0x10>
      6c:	05 90       	lpm	r0, Z+
      6e:	0d 92       	st	X+, r0
      70:	a2 37       	cpi	r26, 0x72	; 114
      72:	b1 07       	cpc	r27, r17
      74:	d9 f7       	brne	.-10     	; 0x6c <__do_copy_data+0xc>

00000076 <__do_clear_bss>:
      76:	13 e0       	ldi	r17, 0x03	; 3
      78:	a2 e7       	ldi	r26, 0x72	; 114
      7a:	b0 e0       	ldi	r27, 0x00	; 0
      7c:	01 c0       	rjmp	.+2      	; 0x80 <.do_clear_bss_start>

0000007e <.do_clear_bss_loop>:
      7e:	1d 92       	st	X+, r1

00000080 <.do_clear_bss_start>:
      80:	aa 35       	cpi	r26, 0x5A	; 90
      82:	b1 07       	cpc	r27, r17
      84:	e1 f7       	brne	.-8      	; 0x7e <.do_clear_bss_loop>
      86:	0e 94 10 08 	call	0x1020	; 0x1020 <main>
      8a:	0c 94 34 0d 	jmp	0x1a68	; 0x1a68 <_exit>

0000008e <__bad_interrupt>:
      8e:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000092 <xCoRoutineCreate>:
static void prvCheckDelayedList( void );

/*-----------------------------------------------------------*/

signed portBASE_TYPE xCoRoutineCreate( crCOROUTINE_CODE pxCoRoutineCode, unsigned portBASE_TYPE uxPriority, unsigned portBASE_TYPE uxIndex )
{
      92:	af 92       	push	r10
      94:	bf 92       	push	r11
      96:	cf 92       	push	r12
      98:	df 92       	push	r13
      9a:	ef 92       	push	r14
      9c:	ff 92       	push	r15
      9e:	0f 93       	push	r16
      a0:	1f 93       	push	r17
      a2:	cf 93       	push	r28
      a4:	df 93       	push	r29
      a6:	6c 01       	movw	r12, r24
      a8:	e6 2e       	mov	r14, r22
      aa:	f4 2e       	mov	r15, r20
signed portBASE_TYPE xReturn;
corCRCB *pxCoRoutine;

	/* Allocate the memory that will store the co-routine control block. */
	pxCoRoutine = ( corCRCB * ) pvPortMalloc( sizeof( corCRCB ) );
      ac:	8a e1       	ldi	r24, 0x1A	; 26
      ae:	90 e0       	ldi	r25, 0x00	; 0
      b0:	0e 94 6e 02 	call	0x4dc	; 0x4dc <pvPortMalloc>
      b4:	8c 01       	movw	r16, r24
	if( pxCoRoutine )
      b6:	00 97       	sbiw	r24, 0x00	; 0
      b8:	09 f4       	brne	.+2      	; 0xbc <xCoRoutineCreate+0x2a>
      ba:	62 c0       	rjmp	.+196    	; 0x180 <xCoRoutineCreate+0xee>
	{
		/* If pxCurrentCoRoutine is NULL then this is the first co-routine to
		be created and the co-routine data structures need initialising. */
		if( pxCurrentCoRoutine == NULL )
      bc:	80 91 72 00 	lds	r24, 0x0072
      c0:	90 91 73 00 	lds	r25, 0x0073
      c4:	00 97       	sbiw	r24, 0x00	; 0
      c6:	39 f5       	brne	.+78     	; 0x116 <xCoRoutineCreate+0x84>
		{
			pxCurrentCoRoutine = pxCoRoutine;
      c8:	10 93 73 00 	sts	0x0073, r17
      cc:	00 93 72 00 	sts	0x0072, r16
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = 0; uxPriority < configMAX_CO_ROUTINE_PRIORITIES; uxPriority++ )
	{
		vListInitialise( ( xList * ) &( pxReadyCoRoutineLists[ uxPriority ] ) );
      d0:	c5 e7       	ldi	r28, 0x75	; 117
      d2:	d0 e0       	ldi	r29, 0x00	; 0
      d4:	ce 01       	movw	r24, r28
      d6:	0e 94 a6 02 	call	0x54c	; 0x54c <vListInitialise>
      da:	ce 01       	movw	r24, r28
      dc:	09 96       	adiw	r24, 0x09	; 9
      de:	0e 94 a6 02 	call	0x54c	; 0x54c <vListInitialise>
	}

	vListInitialise( ( xList * ) &xDelayedCoRoutineList1 );
      e2:	c7 e8       	ldi	r28, 0x87	; 135
      e4:	d0 e0       	ldi	r29, 0x00	; 0
      e6:	ce 01       	movw	r24, r28
      e8:	0e 94 a6 02 	call	0x54c	; 0x54c <vListInitialise>
	vListInitialise( ( xList * ) &xDelayedCoRoutineList2 );
      ec:	0f 2e       	mov	r0, r31
      ee:	f0 e9       	ldi	r31, 0x90	; 144
      f0:	af 2e       	mov	r10, r31
      f2:	f0 e0       	ldi	r31, 0x00	; 0
      f4:	bf 2e       	mov	r11, r31
      f6:	f0 2d       	mov	r31, r0
      f8:	c5 01       	movw	r24, r10
      fa:	0e 94 a6 02 	call	0x54c	; 0x54c <vListInitialise>
	vListInitialise( ( xList * ) &xPendingReadyCoRoutineList );
      fe:	89 e9       	ldi	r24, 0x99	; 153
     100:	90 e0       	ldi	r25, 0x00	; 0
     102:	0e 94 a6 02 	call	0x54c	; 0x54c <vListInitialise>

	/* Start with pxDelayedCoRoutineList using list1 and the
	pxOverflowDelayedCoRoutineList using list2. */
	pxDelayedCoRoutineList = &xDelayedCoRoutineList1;
     106:	d0 93 a3 00 	sts	0x00A3, r29
     10a:	c0 93 a2 00 	sts	0x00A2, r28
	pxOverflowDelayedCoRoutineList = &xDelayedCoRoutineList2;
     10e:	b0 92 a5 00 	sts	0x00A5, r11
     112:	a0 92 a4 00 	sts	0x00A4, r10
     116:	ce 2d       	mov	r28, r14
     118:	e1 10       	cpse	r14, r1
     11a:	c1 e0       	ldi	r28, 0x01	; 1
		{
			uxPriority = configMAX_CO_ROUTINE_PRIORITIES - 1;
		}

		/* Fill out the co-routine control block from the function parameters. */
		pxCoRoutine->uxState = corINITIAL_STATE;
     11c:	f8 01       	movw	r30, r16
     11e:	11 8e       	std	Z+25, r1	; 0x19
     120:	10 8e       	std	Z+24, r1	; 0x18
		pxCoRoutine->uxPriority = uxPriority;
     122:	c6 8b       	std	Z+22, r28	; 0x16
		pxCoRoutine->uxIndex = uxIndex;
     124:	f7 8a       	std	Z+23, r15	; 0x17
		pxCoRoutine->pxCoRoutineFunction = pxCoRoutineCode;
     126:	c1 92       	st	Z+, r12
     128:	d1 92       	st	Z+, r13
     12a:	7f 01       	movw	r14, r30

		/* Initialise all the other co-routine control block parameters. */
		vListInitialiseItem( &( pxCoRoutine->xGenericListItem ) );
     12c:	cf 01       	movw	r24, r30
     12e:	0e 94 b4 02 	call	0x568	; 0x568 <vListInitialiseItem>
		vListInitialiseItem( &( pxCoRoutine->xEventListItem ) );
     132:	c8 01       	movw	r24, r16
     134:	0c 96       	adiw	r24, 0x0c	; 12
     136:	0e 94 b4 02 	call	0x568	; 0x568 <vListInitialiseItem>

		/* Set the co-routine control block as a link back from the xListItem.
		This is so we can get back to the containing CRCB from a generic item
		in a list. */
		listSET_LIST_ITEM_OWNER( &( pxCoRoutine->xGenericListItem ), pxCoRoutine );
     13a:	f8 01       	movw	r30, r16
     13c:	11 87       	std	Z+9, r17	; 0x09
     13e:	00 87       	std	Z+8, r16	; 0x08
		listSET_LIST_ITEM_OWNER( &( pxCoRoutine->xEventListItem ), pxCoRoutine );
     140:	13 8b       	std	Z+19, r17	; 0x13
     142:	02 8b       	std	Z+18, r16	; 0x12
	
		/* Event lists are always in priority order. */
		listSET_LIST_ITEM_VALUE( &( pxCoRoutine->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) uxPriority );
     144:	83 e0       	ldi	r24, 0x03	; 3
     146:	90 e0       	ldi	r25, 0x00	; 0
     148:	8c 1b       	sub	r24, r28
     14a:	91 09       	sbc	r25, r1
     14c:	95 87       	std	Z+13, r25	; 0x0d
     14e:	84 87       	std	Z+12, r24	; 0x0c
		
		/* Now the co-routine has been initialised it can be added to the ready
		list at the correct priority. */
		prvAddCoRoutineToReadyQueue( pxCoRoutine );
     150:	86 89       	ldd	r24, Z+22	; 0x16
     152:	90 91 74 00 	lds	r25, 0x0074
     156:	98 17       	cp	r25, r24
     158:	10 f4       	brcc	.+4      	; 0x15e <xCoRoutineCreate+0xcc>
     15a:	80 93 74 00 	sts	0x0074, r24
     15e:	90 e0       	ldi	r25, 0x00	; 0
     160:	9c 01       	movw	r18, r24
     162:	22 0f       	add	r18, r18
     164:	33 1f       	adc	r19, r19
     166:	22 0f       	add	r18, r18
     168:	33 1f       	adc	r19, r19
     16a:	22 0f       	add	r18, r18
     16c:	33 1f       	adc	r19, r19
     16e:	82 0f       	add	r24, r18
     170:	93 1f       	adc	r25, r19
     172:	8b 58       	subi	r24, 0x8B	; 139
     174:	9f 4f       	sbci	r25, 0xFF	; 255
     176:	b7 01       	movw	r22, r14
     178:	0e 94 b8 02 	call	0x570	; 0x570 <vListInsertEnd>

		xReturn = pdPASS;
     17c:	81 e0       	ldi	r24, 0x01	; 1
     17e:	01 c0       	rjmp	.+2      	; 0x182 <xCoRoutineCreate+0xf0>
	}
	else
	{		
		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
     180:	8f ef       	ldi	r24, 0xFF	; 255
	}
	
	return xReturn;	
}
     182:	df 91       	pop	r29
     184:	cf 91       	pop	r28
     186:	1f 91       	pop	r17
     188:	0f 91       	pop	r16
     18a:	ff 90       	pop	r15
     18c:	ef 90       	pop	r14
     18e:	df 90       	pop	r13
     190:	cf 90       	pop	r12
     192:	bf 90       	pop	r11
     194:	af 90       	pop	r10
     196:	08 95       	ret

00000198 <vCoRoutineAddToDelayedList>:
/*-----------------------------------------------------------*/

void vCoRoutineAddToDelayedList( portTickType xTicksToDelay, xList *pxEventList )
{
     198:	0f 93       	push	r16
     19a:	1f 93       	push	r17
     19c:	cf 93       	push	r28
     19e:	df 93       	push	r29
     1a0:	8b 01       	movw	r16, r22
portTickType xTimeToWake;

	/* Calculate the time to wake - this may overflow but this is
	not a problem. */
	xTimeToWake = xCoRoutineTickCount + xTicksToDelay;
     1a2:	c0 91 a6 00 	lds	r28, 0x00A6
     1a6:	d0 91 a7 00 	lds	r29, 0x00A7
     1aa:	c8 0f       	add	r28, r24
     1ac:	d9 1f       	adc	r29, r25

	/* We must remove ourselves from the ready list before adding
	ourselves to the blocked list as the same list item is used for
	both lists. */
	vListRemove( ( xListItem * ) &( pxCurrentCoRoutine->xGenericListItem ) );
     1ae:	80 91 72 00 	lds	r24, 0x0072
     1b2:	90 91 73 00 	lds	r25, 0x0073
     1b6:	02 96       	adiw	r24, 0x02	; 2
     1b8:	0e 94 1e 03 	call	0x63c	; 0x63c <vListRemove>

	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentCoRoutine->xGenericListItem ), xTimeToWake );
     1bc:	e0 91 72 00 	lds	r30, 0x0072
     1c0:	f0 91 73 00 	lds	r31, 0x0073
     1c4:	d3 83       	std	Z+3, r29	; 0x03
     1c6:	c2 83       	std	Z+2, r28	; 0x02

	if( xTimeToWake < xCoRoutineTickCount )
     1c8:	80 91 a6 00 	lds	r24, 0x00A6
     1cc:	90 91 a7 00 	lds	r25, 0x00A7
     1d0:	c8 17       	cp	r28, r24
     1d2:	d9 07       	cpc	r29, r25
     1d4:	50 f4       	brcc	.+20     	; 0x1ea <vCoRoutineAddToDelayedList+0x52>
	{
		/* Wake time has overflowed.  Place this item in the
		overflow list. */
		vListInsert( ( xList * ) pxOverflowDelayedCoRoutineList, ( xListItem * ) &( pxCurrentCoRoutine->xGenericListItem ) );
     1d6:	bf 01       	movw	r22, r30
     1d8:	6e 5f       	subi	r22, 0xFE	; 254
     1da:	7f 4f       	sbci	r23, 0xFF	; 255
     1dc:	80 91 a4 00 	lds	r24, 0x00A4
     1e0:	90 91 a5 00 	lds	r25, 0x00A5
     1e4:	0e 94 e1 02 	call	0x5c2	; 0x5c2 <vListInsert>
     1e8:	09 c0       	rjmp	.+18     	; 0x1fc <vCoRoutineAddToDelayedList+0x64>
	}
	else
	{
		/* The wake time has not overflowed, so we can use the
		current block list. */
		vListInsert( ( xList * ) pxDelayedCoRoutineList, ( xListItem * ) &( pxCurrentCoRoutine->xGenericListItem ) );
     1ea:	bf 01       	movw	r22, r30
     1ec:	6e 5f       	subi	r22, 0xFE	; 254
     1ee:	7f 4f       	sbci	r23, 0xFF	; 255
     1f0:	80 91 a2 00 	lds	r24, 0x00A2
     1f4:	90 91 a3 00 	lds	r25, 0x00A3
     1f8:	0e 94 e1 02 	call	0x5c2	; 0x5c2 <vListInsert>
	}

	if( pxEventList )
     1fc:	01 15       	cp	r16, r1
     1fe:	11 05       	cpc	r17, r1
     200:	49 f0       	breq	.+18     	; 0x214 <vCoRoutineAddToDelayedList+0x7c>
	{
		/* Also add the co-routine to an event list.  If this is done then the
		function must be called with interrupts disabled. */
		vListInsert( pxEventList, &( pxCurrentCoRoutine->xEventListItem ) );
     202:	60 91 72 00 	lds	r22, 0x0072
     206:	70 91 73 00 	lds	r23, 0x0073
     20a:	64 5f       	subi	r22, 0xF4	; 244
     20c:	7f 4f       	sbci	r23, 0xFF	; 255
     20e:	c8 01       	movw	r24, r16
     210:	0e 94 e1 02 	call	0x5c2	; 0x5c2 <vListInsert>
	}
}
     214:	df 91       	pop	r29
     216:	cf 91       	pop	r28
     218:	1f 91       	pop	r17
     21a:	0f 91       	pop	r16
     21c:	08 95       	ret

0000021e <vCoRoutineSchedule>:
	xLastTickCount = xCoRoutineTickCount;
}
/*-----------------------------------------------------------*/

void vCoRoutineSchedule( void )
{
     21e:	cf 92       	push	r12
     220:	df 92       	push	r13
     222:	ef 92       	push	r14
     224:	ff 92       	push	r15
     226:	0f 93       	push	r16
     228:	1f 93       	push	r17
     22a:	cf 93       	push	r28
     22c:	df 93       	push	r29
static void prvCheckPendingReadyList( void )
{
	/* Are there any co-routines waiting to get moved to the ready list?  These
	are co-routines that have been readied by an ISR.  The ISR cannot access
	the	ready lists itself. */
	while( listLIST_IS_EMPTY( &xPendingReadyCoRoutineList ) == pdFALSE )
     22e:	80 91 99 00 	lds	r24, 0x0099
     232:	88 23       	and	r24, r24
     234:	b9 f1       	breq	.+110    	; 0x2a4 <vCoRoutineSchedule+0x86>
		corCRCB *pxUnblockedCRCB;

		/* The pending ready list can be accessed by an ISR. */
		portDISABLE_INTERRUPTS();
		{	
			pxUnblockedCRCB = ( corCRCB * ) listGET_OWNER_OF_HEAD_ENTRY( (&xPendingReadyCoRoutineList) );			
     236:	0f 2e       	mov	r0, r31
     238:	fe e9       	ldi	r31, 0x9E	; 158
     23a:	ef 2e       	mov	r14, r31
     23c:	f0 e0       	ldi	r31, 0x00	; 0
     23e:	ff 2e       	mov	r15, r31
     240:	f0 2d       	mov	r31, r0
static void prvCheckPendingReadyList( void )
{
	/* Are there any co-routines waiting to get moved to the ready list?  These
	are co-routines that have been readied by an ISR.  The ISR cannot access
	the	ready lists itself. */
	while( listLIST_IS_EMPTY( &xPendingReadyCoRoutineList ) == pdFALSE )
     242:	0f 2e       	mov	r0, r31
     244:	f9 e9       	ldi	r31, 0x99	; 153
     246:	cf 2e       	mov	r12, r31
     248:	f0 e0       	ldi	r31, 0x00	; 0
     24a:	df 2e       	mov	r13, r31
     24c:	f0 2d       	mov	r31, r0
	{
		corCRCB *pxUnblockedCRCB;

		/* The pending ready list can be accessed by an ISR. */
		portDISABLE_INTERRUPTS();
     24e:	f8 94       	cli
		{	
			pxUnblockedCRCB = ( corCRCB * ) listGET_OWNER_OF_HEAD_ENTRY( (&xPendingReadyCoRoutineList) );			
     250:	d7 01       	movw	r26, r14
     252:	ed 91       	ld	r30, X+
     254:	fc 91       	ld	r31, X
     256:	c6 81       	ldd	r28, Z+6	; 0x06
     258:	d7 81       	ldd	r29, Z+7	; 0x07
			vListRemove( &( pxUnblockedCRCB->xEventListItem ) );
     25a:	ce 01       	movw	r24, r28
     25c:	0c 96       	adiw	r24, 0x0c	; 12
     25e:	0e 94 1e 03 	call	0x63c	; 0x63c <vListRemove>
		}
		portENABLE_INTERRUPTS();
     262:	78 94       	sei

		vListRemove( &( pxUnblockedCRCB->xGenericListItem ) );
     264:	8e 01       	movw	r16, r28
     266:	0e 5f       	subi	r16, 0xFE	; 254
     268:	1f 4f       	sbci	r17, 0xFF	; 255
     26a:	c8 01       	movw	r24, r16
     26c:	0e 94 1e 03 	call	0x63c	; 0x63c <vListRemove>
		prvAddCoRoutineToReadyQueue( pxUnblockedCRCB );	
     270:	8e 89       	ldd	r24, Y+22	; 0x16
     272:	90 91 74 00 	lds	r25, 0x0074
     276:	98 17       	cp	r25, r24
     278:	10 f4       	brcc	.+4      	; 0x27e <vCoRoutineSchedule+0x60>
     27a:	80 93 74 00 	sts	0x0074, r24
     27e:	90 e0       	ldi	r25, 0x00	; 0
     280:	9c 01       	movw	r18, r24
     282:	22 0f       	add	r18, r18
     284:	33 1f       	adc	r19, r19
     286:	22 0f       	add	r18, r18
     288:	33 1f       	adc	r19, r19
     28a:	22 0f       	add	r18, r18
     28c:	33 1f       	adc	r19, r19
     28e:	82 0f       	add	r24, r18
     290:	93 1f       	adc	r25, r19
     292:	8b 58       	subi	r24, 0x8B	; 139
     294:	9f 4f       	sbci	r25, 0xFF	; 255
     296:	b8 01       	movw	r22, r16
     298:	0e 94 b8 02 	call	0x570	; 0x570 <vListInsertEnd>
static void prvCheckPendingReadyList( void )
{
	/* Are there any co-routines waiting to get moved to the ready list?  These
	are co-routines that have been readied by an ISR.  The ISR cannot access
	the	ready lists itself. */
	while( listLIST_IS_EMPTY( &xPendingReadyCoRoutineList ) == pdFALSE )
     29c:	f6 01       	movw	r30, r12
     29e:	80 81       	ld	r24, Z
     2a0:	88 23       	and	r24, r24
     2a2:	a9 f6       	brne	.-86     	; 0x24e <vCoRoutineSchedule+0x30>

static void prvCheckDelayedList( void )
{
corCRCB *pxCRCB;

	xPassedTicks = xTaskGetTickCount() - xLastTickCount;
     2a4:	0e 94 08 0a 	call	0x1410	; 0x1410 <xTaskGetTickCount>
     2a8:	20 91 a8 00 	lds	r18, 0x00A8
     2ac:	30 91 a9 00 	lds	r19, 0x00A9
     2b0:	82 1b       	sub	r24, r18
     2b2:	93 0b       	sbc	r25, r19
     2b4:	90 93 ab 00 	sts	0x00AB, r25
     2b8:	80 93 aa 00 	sts	0x00AA, r24
     2bc:	74 c0       	rjmp	.+232    	; 0x3a6 <vCoRoutineSchedule+0x188>
	while( xPassedTicks )
	{
		xCoRoutineTickCount++;
     2be:	20 91 a6 00 	lds	r18, 0x00A6
     2c2:	30 91 a7 00 	lds	r19, 0x00A7
     2c6:	2f 5f       	subi	r18, 0xFF	; 255
     2c8:	3f 4f       	sbci	r19, 0xFF	; 255
     2ca:	30 93 a7 00 	sts	0x00A7, r19
     2ce:	20 93 a6 00 	sts	0x00A6, r18
		xPassedTicks--;
     2d2:	01 97       	sbiw	r24, 0x01	; 1
     2d4:	90 93 ab 00 	sts	0x00AB, r25
     2d8:	80 93 aa 00 	sts	0x00AA, r24

		/* If the tick count has overflowed we need to swap the ready lists. */
		if( xCoRoutineTickCount == 0 )
     2dc:	21 15       	cp	r18, r1
     2de:	31 05       	cpc	r19, r1
     2e0:	81 f4       	brne	.+32     	; 0x302 <vCoRoutineSchedule+0xe4>
		{
			xList * pxTemp;

			/* Tick count has overflowed so we need to swap the delay lists.  If there are
			any items in pxDelayedCoRoutineList here then there is an error! */
			pxTemp = pxDelayedCoRoutineList;
     2e2:	80 91 a2 00 	lds	r24, 0x00A2
     2e6:	90 91 a3 00 	lds	r25, 0x00A3
			pxDelayedCoRoutineList = pxOverflowDelayedCoRoutineList;
     2ea:	20 91 a4 00 	lds	r18, 0x00A4
     2ee:	30 91 a5 00 	lds	r19, 0x00A5
     2f2:	30 93 a3 00 	sts	0x00A3, r19
     2f6:	20 93 a2 00 	sts	0x00A2, r18
			pxOverflowDelayedCoRoutineList = pxTemp;
     2fa:	90 93 a5 00 	sts	0x00A5, r25
     2fe:	80 93 a4 00 	sts	0x00A4, r24
		}

		/* See if this tick has made a timeout expire. */
		while( listLIST_IS_EMPTY( pxDelayedCoRoutineList ) == pdFALSE )
     302:	e0 91 a2 00 	lds	r30, 0x00A2
     306:	f0 91 a3 00 	lds	r31, 0x00A3
     30a:	80 81       	ld	r24, Z
     30c:	88 23       	and	r24, r24
     30e:	09 f4       	brne	.+2      	; 0x312 <vCoRoutineSchedule+0xf4>
     310:	4a c0       	rjmp	.+148    	; 0x3a6 <vCoRoutineSchedule+0x188>
		{
			pxCRCB = ( corCRCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedCoRoutineList );
     312:	05 80       	ldd	r0, Z+5	; 0x05
     314:	f6 81       	ldd	r31, Z+6	; 0x06
     316:	e0 2d       	mov	r30, r0
     318:	c6 81       	ldd	r28, Z+6	; 0x06
     31a:	d7 81       	ldd	r29, Z+7	; 0x07

			if( xCoRoutineTickCount < listGET_LIST_ITEM_VALUE( &( pxCRCB->xGenericListItem ) ) )				
     31c:	2a 81       	ldd	r18, Y+2	; 0x02
     31e:	3b 81       	ldd	r19, Y+3	; 0x03
     320:	80 91 a6 00 	lds	r24, 0x00A6
     324:	90 91 a7 00 	lds	r25, 0x00A7
     328:	82 17       	cp	r24, r18
     32a:	93 07       	cpc	r25, r19
     32c:	78 f4       	brcc	.+30     	; 0x34c <vCoRoutineSchedule+0x12e>
     32e:	3b c0       	rjmp	.+118    	; 0x3a6 <vCoRoutineSchedule+0x188>
		}

		/* See if this tick has made a timeout expire. */
		while( listLIST_IS_EMPTY( pxDelayedCoRoutineList ) == pdFALSE )
		{
			pxCRCB = ( corCRCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedCoRoutineList );
     330:	05 80       	ldd	r0, Z+5	; 0x05
     332:	f6 81       	ldd	r31, Z+6	; 0x06
     334:	e0 2d       	mov	r30, r0
     336:	c6 81       	ldd	r28, Z+6	; 0x06
     338:	d7 81       	ldd	r29, Z+7	; 0x07

			if( xCoRoutineTickCount < listGET_LIST_ITEM_VALUE( &( pxCRCB->xGenericListItem ) ) )				
     33a:	2a 81       	ldd	r18, Y+2	; 0x02
     33c:	3b 81       	ldd	r19, Y+3	; 0x03
     33e:	80 91 a6 00 	lds	r24, 0x00A6
     342:	90 91 a7 00 	lds	r25, 0x00A7
     346:	82 17       	cp	r24, r18
     348:	93 07       	cpc	r25, r19
     34a:	68 f1       	brcs	.+90     	; 0x3a6 <vCoRoutineSchedule+0x188>
			{			
				/* Timeout not yet expired. */																			
				break;																				
			}																						

			portDISABLE_INTERRUPTS();
     34c:	f8 94       	cli
				/* The event could have occurred just before this critical
				section.  If this is the case then the generic list item will
				have been moved to the pending ready list and the following
				line is still valid.  Also the pvContainer parameter will have
				been set to NULL so the following lines are also valid. */
				vListRemove( &( pxCRCB->xGenericListItem ) );											
     34e:	8e 01       	movw	r16, r28
     350:	0e 5f       	subi	r16, 0xFE	; 254
     352:	1f 4f       	sbci	r17, 0xFF	; 255
     354:	c8 01       	movw	r24, r16
     356:	0e 94 1e 03 	call	0x63c	; 0x63c <vListRemove>

				/* Is the co-routine waiting on an event also? */												
				if( pxCRCB->xEventListItem.pvContainer )													
     35a:	8c 89       	ldd	r24, Y+20	; 0x14
     35c:	9d 89       	ldd	r25, Y+21	; 0x15
     35e:	00 97       	sbiw	r24, 0x00	; 0
     360:	21 f0       	breq	.+8      	; 0x36a <vCoRoutineSchedule+0x14c>
				{															
					vListRemove( &( pxCRCB->xEventListItem ) );											
     362:	ce 01       	movw	r24, r28
     364:	0c 96       	adiw	r24, 0x0c	; 12
     366:	0e 94 1e 03 	call	0x63c	; 0x63c <vListRemove>
				}
			}
			portENABLE_INTERRUPTS();
     36a:	78 94       	sei

			prvAddCoRoutineToReadyQueue( pxCRCB );													
     36c:	8e 89       	ldd	r24, Y+22	; 0x16
     36e:	90 91 74 00 	lds	r25, 0x0074
     372:	98 17       	cp	r25, r24
     374:	10 f4       	brcc	.+4      	; 0x37a <vCoRoutineSchedule+0x15c>
     376:	80 93 74 00 	sts	0x0074, r24
     37a:	90 e0       	ldi	r25, 0x00	; 0
     37c:	9c 01       	movw	r18, r24
     37e:	22 0f       	add	r18, r18
     380:	33 1f       	adc	r19, r19
     382:	22 0f       	add	r18, r18
     384:	33 1f       	adc	r19, r19
     386:	22 0f       	add	r18, r18
     388:	33 1f       	adc	r19, r19
     38a:	82 0f       	add	r24, r18
     38c:	93 1f       	adc	r25, r19
     38e:	8b 58       	subi	r24, 0x8B	; 139
     390:	9f 4f       	sbci	r25, 0xFF	; 255
     392:	b8 01       	movw	r22, r16
     394:	0e 94 b8 02 	call	0x570	; 0x570 <vListInsertEnd>
			pxDelayedCoRoutineList = pxOverflowDelayedCoRoutineList;
			pxOverflowDelayedCoRoutineList = pxTemp;
		}

		/* See if this tick has made a timeout expire. */
		while( listLIST_IS_EMPTY( pxDelayedCoRoutineList ) == pdFALSE )
     398:	e0 91 a2 00 	lds	r30, 0x00A2
     39c:	f0 91 a3 00 	lds	r31, 0x00A3
     3a0:	80 81       	ld	r24, Z
     3a2:	88 23       	and	r24, r24
     3a4:	29 f6       	brne	.-118    	; 0x330 <vCoRoutineSchedule+0x112>
static void prvCheckDelayedList( void )
{
corCRCB *pxCRCB;

	xPassedTicks = xTaskGetTickCount() - xLastTickCount;
	while( xPassedTicks )
     3a6:	80 91 aa 00 	lds	r24, 0x00AA
     3aa:	90 91 ab 00 	lds	r25, 0x00AB
     3ae:	00 97       	sbiw	r24, 0x00	; 0
     3b0:	09 f0       	breq	.+2      	; 0x3b4 <vCoRoutineSchedule+0x196>
     3b2:	85 cf       	rjmp	.-246    	; 0x2be <vCoRoutineSchedule+0xa0>

			prvAddCoRoutineToReadyQueue( pxCRCB );													
		}																									
	}

	xLastTickCount = xCoRoutineTickCount;
     3b4:	80 91 a6 00 	lds	r24, 0x00A6
     3b8:	90 91 a7 00 	lds	r25, 0x00A7
     3bc:	90 93 a9 00 	sts	0x00A9, r25
     3c0:	80 93 a8 00 	sts	0x00A8, r24

	/* See if any delayed co-routines have timed out. */
	prvCheckDelayedList();

	/* Find the highest priority queue that contains ready co-routines. */
	while( listLIST_IS_EMPTY( &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) ) )
     3c4:	20 91 74 00 	lds	r18, 0x0074
     3c8:	82 2f       	mov	r24, r18
     3ca:	90 e0       	ldi	r25, 0x00	; 0
     3cc:	fc 01       	movw	r30, r24
     3ce:	ee 0f       	add	r30, r30
     3d0:	ff 1f       	adc	r31, r31
     3d2:	ee 0f       	add	r30, r30
     3d4:	ff 1f       	adc	r31, r31
     3d6:	ee 0f       	add	r30, r30
     3d8:	ff 1f       	adc	r31, r31
     3da:	e8 0f       	add	r30, r24
     3dc:	f9 1f       	adc	r31, r25
     3de:	eb 58       	subi	r30, 0x8B	; 139
     3e0:	ff 4f       	sbci	r31, 0xFF	; 255
     3e2:	30 81       	ld	r19, Z
     3e4:	33 23       	and	r19, r19
     3e6:	d9 f4       	brne	.+54     	; 0x41e <vCoRoutineSchedule+0x200>
	{
		if( uxTopCoRoutineReadyPriority == 0 )
     3e8:	22 23       	and	r18, r18
     3ea:	31 f4       	brne	.+12     	; 0x3f8 <vCoRoutineSchedule+0x1da>
     3ec:	47 c0       	rjmp	.+142    	; 0x47c <vCoRoutineSchedule+0x25e>
     3ee:	22 23       	and	r18, r18
     3f0:	19 f4       	brne	.+6      	; 0x3f8 <vCoRoutineSchedule+0x1da>
     3f2:	20 93 74 00 	sts	0x0074, r18
     3f6:	42 c0       	rjmp	.+132    	; 0x47c <vCoRoutineSchedule+0x25e>
		{
			/* No more co-routines to check. */
			return;
		}
		--uxTopCoRoutineReadyPriority;
     3f8:	21 50       	subi	r18, 0x01	; 1

	/* See if any delayed co-routines have timed out. */
	prvCheckDelayedList();

	/* Find the highest priority queue that contains ready co-routines. */
	while( listLIST_IS_EMPTY( &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) ) )
     3fa:	82 2f       	mov	r24, r18
     3fc:	90 e0       	ldi	r25, 0x00	; 0
     3fe:	fc 01       	movw	r30, r24
     400:	ee 0f       	add	r30, r30
     402:	ff 1f       	adc	r31, r31
     404:	ee 0f       	add	r30, r30
     406:	ff 1f       	adc	r31, r31
     408:	ee 0f       	add	r30, r30
     40a:	ff 1f       	adc	r31, r31
     40c:	e8 0f       	add	r30, r24
     40e:	f9 1f       	adc	r31, r25
     410:	eb 58       	subi	r30, 0x8B	; 139
     412:	ff 4f       	sbci	r31, 0xFF	; 255
     414:	30 81       	ld	r19, Z
     416:	33 23       	and	r19, r19
     418:	51 f3       	breq	.-44     	; 0x3ee <vCoRoutineSchedule+0x1d0>
     41a:	20 93 74 00 	sts	0x0074, r18
		--uxTopCoRoutineReadyPriority;
	}

	/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the co-routines
	 of the	same priority get an equal share of the processor time. */
	listGET_OWNER_OF_NEXT_ENTRY( pxCurrentCoRoutine, &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) );
     41e:	fc 01       	movw	r30, r24
     420:	ee 0f       	add	r30, r30
     422:	ff 1f       	adc	r31, r31
     424:	ee 0f       	add	r30, r30
     426:	ff 1f       	adc	r31, r31
     428:	ee 0f       	add	r30, r30
     42a:	ff 1f       	adc	r31, r31
     42c:	8e 0f       	add	r24, r30
     42e:	9f 1f       	adc	r25, r31
     430:	fc 01       	movw	r30, r24
     432:	eb 58       	subi	r30, 0x8B	; 139
     434:	ff 4f       	sbci	r31, 0xFF	; 255
     436:	a1 81       	ldd	r26, Z+1	; 0x01
     438:	b2 81       	ldd	r27, Z+2	; 0x02
     43a:	12 96       	adiw	r26, 0x02	; 2
     43c:	0d 90       	ld	r0, X+
     43e:	bc 91       	ld	r27, X
     440:	a0 2d       	mov	r26, r0
     442:	b2 83       	std	Z+2, r27	; 0x02
     444:	a1 83       	std	Z+1, r26	; 0x01
     446:	cf 01       	movw	r24, r30
     448:	03 96       	adiw	r24, 0x03	; 3
     44a:	a8 17       	cp	r26, r24
     44c:	b9 07       	cpc	r27, r25
     44e:	31 f4       	brne	.+12     	; 0x45c <vCoRoutineSchedule+0x23e>
     450:	12 96       	adiw	r26, 0x02	; 2
     452:	8d 91       	ld	r24, X+
     454:	9c 91       	ld	r25, X
     456:	13 97       	sbiw	r26, 0x03	; 3
     458:	92 83       	std	Z+2, r25	; 0x02
     45a:	81 83       	std	Z+1, r24	; 0x01
     45c:	01 80       	ldd	r0, Z+1	; 0x01
     45e:	f2 81       	ldd	r31, Z+2	; 0x02
     460:	e0 2d       	mov	r30, r0
     462:	a6 81       	ldd	r26, Z+6	; 0x06
     464:	b7 81       	ldd	r27, Z+7	; 0x07
     466:	b0 93 73 00 	sts	0x0073, r27
     46a:	a0 93 72 00 	sts	0x0072, r26

	/* Call the co-routine. */
	( pxCurrentCoRoutine->pxCoRoutineFunction )( pxCurrentCoRoutine, pxCurrentCoRoutine->uxIndex );
     46e:	ed 91       	ld	r30, X+
     470:	fc 91       	ld	r31, X
     472:	11 97       	sbiw	r26, 0x01	; 1
     474:	cd 01       	movw	r24, r26
     476:	57 96       	adiw	r26, 0x17	; 23
     478:	6c 91       	ld	r22, X
     47a:	09 95       	icall

	return;
}
     47c:	df 91       	pop	r29
     47e:	cf 91       	pop	r28
     480:	1f 91       	pop	r17
     482:	0f 91       	pop	r16
     484:	ff 90       	pop	r15
     486:	ef 90       	pop	r14
     488:	df 90       	pop	r13
     48a:	cf 90       	pop	r12
     48c:	08 95       	ret

0000048e <xCoRoutineRemoveFromEventList>:
	pxOverflowDelayedCoRoutineList = &xDelayedCoRoutineList2;
}
/*-----------------------------------------------------------*/

signed portBASE_TYPE xCoRoutineRemoveFromEventList( const xList *pxEventList )
{
     48e:	0f 93       	push	r16
     490:	1f 93       	push	r17
     492:	cf 93       	push	r28
     494:	df 93       	push	r29
signed portBASE_TYPE xReturn;

	/* This function is called from within an interrupt.  It can only access
	event lists and the pending ready list.  This function assumes that a
	check has already been made to ensure pxEventList is not empty. */
	pxUnblockedCRCB = ( corCRCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
     496:	dc 01       	movw	r26, r24
     498:	15 96       	adiw	r26, 0x05	; 5
     49a:	ed 91       	ld	r30, X+
     49c:	fc 91       	ld	r31, X
     49e:	16 97       	sbiw	r26, 0x06	; 6
     4a0:	06 81       	ldd	r16, Z+6	; 0x06
     4a2:	17 81       	ldd	r17, Z+7	; 0x07
	vListRemove( &( pxUnblockedCRCB->xEventListItem ) );
     4a4:	e8 01       	movw	r28, r16
     4a6:	2c 96       	adiw	r28, 0x0c	; 12
     4a8:	ce 01       	movw	r24, r28
     4aa:	0e 94 1e 03 	call	0x63c	; 0x63c <vListRemove>
	vListInsertEnd( ( xList * ) &( xPendingReadyCoRoutineList ), &( pxUnblockedCRCB->xEventListItem ) );
     4ae:	89 e9       	ldi	r24, 0x99	; 153
     4b0:	90 e0       	ldi	r25, 0x00	; 0
     4b2:	be 01       	movw	r22, r28
     4b4:	0e 94 b8 02 	call	0x570	; 0x570 <vListInsertEnd>

	if( pxUnblockedCRCB->uxPriority >= pxCurrentCoRoutine->uxPriority )
     4b8:	e0 91 72 00 	lds	r30, 0x0072
     4bc:	f0 91 73 00 	lds	r31, 0x0073
	{
		xReturn = pdTRUE;
     4c0:	81 e0       	ldi	r24, 0x01	; 1
     4c2:	d8 01       	movw	r26, r16
     4c4:	56 96       	adiw	r26, 0x16	; 22
     4c6:	2c 91       	ld	r18, X
     4c8:	56 97       	sbiw	r26, 0x16	; 22
     4ca:	96 89       	ldd	r25, Z+22	; 0x16
     4cc:	29 17       	cp	r18, r25
     4ce:	08 f4       	brcc	.+2      	; 0x4d2 <xCoRoutineRemoveFromEventList+0x44>
     4d0:	80 e0       	ldi	r24, 0x00	; 0
	{
		xReturn = pdFALSE;
	}

	return xReturn;
}
     4d2:	df 91       	pop	r29
     4d4:	cf 91       	pop	r28
     4d6:	1f 91       	pop	r17
     4d8:	0f 91       	pop	r16
     4da:	08 95       	ret

000004dc <pvPortMalloc>:

static size_t xNextFreeByte = ( size_t ) 0;
/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
     4dc:	0f 93       	push	r16
     4de:	1f 93       	push	r17
     4e0:	cf 93       	push	r28
     4e2:	df 93       	push	r29
     4e4:	ec 01       	movw	r28, r24
			/* Byte alignment required. */
			xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
		}
	#endif

	vTaskSuspendAll();
     4e6:	0e 94 02 0a 	call	0x1404	; 0x1404 <vTaskSuspendAll>
	{
		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configTOTAL_HEAP_SIZE ) &&
     4ea:	00 91 ac 00 	lds	r16, 0x00AC
     4ee:	10 91 ad 00 	lds	r17, 0x00AD
     4f2:	c0 0f       	add	r28, r16
     4f4:	d1 1f       	adc	r29, r17
     4f6:	82 e0       	ldi	r24, 0x02	; 2
     4f8:	c8 35       	cpi	r28, 0x58	; 88
     4fa:	d8 07       	cpc	r29, r24
     4fc:	50 f4       	brcc	.+20     	; 0x512 <pvPortMalloc+0x36>
     4fe:	0c 17       	cp	r16, r28
     500:	1d 07       	cpc	r17, r29
     502:	50 f4       	brcc	.+20     	; 0x518 <pvPortMalloc+0x3c>
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
		{
			/* Return the next free byte then increment the index past this
			block. */
			pvReturn = &( xHeap.ucHeap[ xNextFreeByte ] );
     504:	02 55       	subi	r16, 0x52	; 82
     506:	1f 4f       	sbci	r17, 0xFF	; 255
			xNextFreeByte += xWantedSize;			
     508:	d0 93 ad 00 	sts	0x00AD, r29
     50c:	c0 93 ac 00 	sts	0x00AC, r28
     510:	05 c0       	rjmp	.+10     	; 0x51c <pvPortMalloc+0x40>
static size_t xNextFreeByte = ( size_t ) 0;
/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
void *pvReturn = NULL; 
     512:	00 e0       	ldi	r16, 0x00	; 0
     514:	10 e0       	ldi	r17, 0x00	; 0
     516:	02 c0       	rjmp	.+4      	; 0x51c <pvPortMalloc+0x40>
     518:	00 e0       	ldi	r16, 0x00	; 0
     51a:	10 e0       	ldi	r17, 0x00	; 0
			block. */
			pvReturn = &( xHeap.ucHeap[ xNextFreeByte ] );
			xNextFreeByte += xWantedSize;			
		}	
	}
	xTaskResumeAll();
     51c:	0e 94 e0 0a 	call	0x15c0	; 0x15c0 <xTaskResumeAll>
		}
	}
	#endif	

	return pvReturn;
}
     520:	80 2f       	mov	r24, r16
     522:	91 2f       	mov	r25, r17
     524:	df 91       	pop	r29
     526:	cf 91       	pop	r28
     528:	1f 91       	pop	r17
     52a:	0f 91       	pop	r16
     52c:	08 95       	ret

0000052e <vPortFree>:
{
	/* Memory cannot be freed using this scheme.  See heap_2.c and heap_3.c 
	for alternative implementations, and the memory management pages of 
	http://www.FreeRTOS.org for more information. */
	( void ) pv;
}
     52e:	08 95       	ret

00000530 <vPortInitialiseBlocks>:
/*-----------------------------------------------------------*/

void vPortInitialiseBlocks( void )
{
	/* Only required when static memory is not cleared. */
	xNextFreeByte = ( size_t ) 0;
     530:	10 92 ad 00 	sts	0x00AD, r1
     534:	10 92 ac 00 	sts	0x00AC, r1
}
     538:	08 95       	ret

0000053a <xPortGetFreeHeapSize>:
/*-----------------------------------------------------------*/

size_t xPortGetFreeHeapSize( void )
{
	return ( configTOTAL_HEAP_SIZE - xNextFreeByte );
     53a:	20 91 ac 00 	lds	r18, 0x00AC
     53e:	30 91 ad 00 	lds	r19, 0x00AD
     542:	88 e5       	ldi	r24, 0x58	; 88
     544:	92 e0       	ldi	r25, 0x02	; 2
     546:	82 1b       	sub	r24, r18
     548:	93 0b       	sbc	r25, r19
}
     54a:	08 95       	ret

0000054c <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( xList *pxList )
{
     54c:	fc 01       	movw	r30, r24
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( xListItem * ) &( pxList->xListEnd );
     54e:	03 96       	adiw	r24, 0x03	; 3
     550:	92 83       	std	Z+2, r25	; 0x02
     552:	81 83       	std	Z+1, r24	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
     554:	2f ef       	ldi	r18, 0xFF	; 255
     556:	3f ef       	ldi	r19, 0xFF	; 255
     558:	34 83       	std	Z+4, r19	; 0x04
     55a:	23 83       	std	Z+3, r18	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( xListItem * ) &( pxList->xListEnd );
     55c:	96 83       	std	Z+6, r25	; 0x06
     55e:	85 83       	std	Z+5, r24	; 0x05
	pxList->xListEnd.pxPrevious = ( xListItem * ) &( pxList->xListEnd );
     560:	90 87       	std	Z+8, r25	; 0x08
     562:	87 83       	std	Z+7, r24	; 0x07

	pxList->uxNumberOfItems = ( unsigned portBASE_TYPE ) 0U;
     564:	10 82       	st	Z, r1
}
     566:	08 95       	ret

00000568 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( xListItem *pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
     568:	fc 01       	movw	r30, r24
     56a:	11 86       	std	Z+9, r1	; 0x09
     56c:	10 86       	std	Z+8, r1	; 0x08
}
     56e:	08 95       	ret

00000570 <vListInsertEnd>:
/*-----------------------------------------------------------*/

void vListInsertEnd( xList *pxList, xListItem *pxNewListItem )
{
     570:	cf 93       	push	r28
     572:	df 93       	push	r29
     574:	ec 01       	movw	r28, r24
     576:	fb 01       	movw	r30, r22

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	pvListGetOwnerOfNextEntry.  This means it has to be the item pointed to by
	the pxIndex member. */
	pxIndex = pxList->pxIndex;
     578:	89 81       	ldd	r24, Y+1	; 0x01
     57a:	9a 81       	ldd	r25, Y+2	; 0x02

	pxNewListItem->pxNext = pxIndex->pxNext;
     57c:	dc 01       	movw	r26, r24
     57e:	12 96       	adiw	r26, 0x02	; 2
     580:	2d 91       	ld	r18, X+
     582:	3c 91       	ld	r19, X
     584:	13 97       	sbiw	r26, 0x03	; 3
     586:	33 83       	std	Z+3, r19	; 0x03
     588:	22 83       	std	Z+2, r18	; 0x02
	pxNewListItem->pxPrevious = pxList->pxIndex;
     58a:	29 81       	ldd	r18, Y+1	; 0x01
     58c:	3a 81       	ldd	r19, Y+2	; 0x02
     58e:	35 83       	std	Z+5, r19	; 0x05
     590:	24 83       	std	Z+4, r18	; 0x04
	pxIndex->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
     592:	12 96       	adiw	r26, 0x02	; 2
     594:	2d 91       	ld	r18, X+
     596:	3c 91       	ld	r19, X
     598:	13 97       	sbiw	r26, 0x03	; 3
     59a:	d9 01       	movw	r26, r18
     59c:	15 96       	adiw	r26, 0x05	; 5
     59e:	7c 93       	st	X, r23
     5a0:	6e 93       	st	-X, r22
     5a2:	14 97       	sbiw	r26, 0x04	; 4
	pxIndex->pxNext = ( volatile xListItem * ) pxNewListItem;
     5a4:	dc 01       	movw	r26, r24
     5a6:	13 96       	adiw	r26, 0x03	; 3
     5a8:	7c 93       	st	X, r23
     5aa:	6e 93       	st	-X, r22
     5ac:	12 97       	sbiw	r26, 0x02	; 2
	pxList->pxIndex = ( volatile xListItem * ) pxNewListItem;
     5ae:	7a 83       	std	Y+2, r23	; 0x02
     5b0:	69 83       	std	Y+1, r22	; 0x01

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     5b2:	d1 87       	std	Z+9, r29	; 0x09
     5b4:	c0 87       	std	Z+8, r28	; 0x08

	( pxList->uxNumberOfItems )++;
     5b6:	88 81       	ld	r24, Y
     5b8:	8f 5f       	subi	r24, 0xFF	; 255
     5ba:	88 83       	st	Y, r24
}
     5bc:	df 91       	pop	r29
     5be:	cf 91       	pop	r28
     5c0:	08 95       	ret

000005c2 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( xList *pxList, xListItem *pxNewListItem )
{
     5c2:	cf 93       	push	r28
     5c4:	df 93       	push	r29
     5c6:	ac 01       	movw	r20, r24
     5c8:	eb 01       	movw	r28, r22
volatile xListItem *pxIterator;
portTickType xValueOfInsertion;

	/* Insert the new list item into the list, sorted in ulListItem order. */
	xValueOfInsertion = pxNewListItem->xItemValue;
     5ca:	28 81       	ld	r18, Y
     5cc:	39 81       	ldd	r19, Y+1	; 0x01
	are stored in ready lists (all of which have the same ulListItem value)
	get an equal share of the CPU.  However, if the xItemValue is the same as
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
     5ce:	8f ef       	ldi	r24, 0xFF	; 255
     5d0:	2f 3f       	cpi	r18, 0xFF	; 255
     5d2:	38 07       	cpc	r19, r24
     5d4:	21 f4       	brne	.+8      	; 0x5de <vListInsert+0x1c>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
     5d6:	fa 01       	movw	r30, r20
     5d8:	a7 81       	ldd	r26, Z+7	; 0x07
     5da:	b0 85       	ldd	r27, Z+8	; 0x08
     5dc:	18 c0       	rjmp	.+48     	; 0x60e <vListInsert+0x4c>
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		See http://www.freertos.org/FAQHelp.html for more tips.
		**********************************************************************/
		
		for( pxIterator = ( xListItem * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext )
     5de:	da 01       	movw	r26, r20
     5e0:	13 96       	adiw	r26, 0x03	; 3
     5e2:	fa 01       	movw	r30, r20
     5e4:	85 81       	ldd	r24, Z+5	; 0x05
     5e6:	96 81       	ldd	r25, Z+6	; 0x06
     5e8:	fc 01       	movw	r30, r24
     5ea:	80 81       	ld	r24, Z
     5ec:	91 81       	ldd	r25, Z+1	; 0x01
     5ee:	28 17       	cp	r18, r24
     5f0:	39 07       	cpc	r19, r25
     5f2:	68 f0       	brcs	.+26     	; 0x60e <vListInsert+0x4c>
     5f4:	12 96       	adiw	r26, 0x02	; 2
     5f6:	0d 90       	ld	r0, X+
     5f8:	bc 91       	ld	r27, X
     5fa:	a0 2d       	mov	r26, r0
     5fc:	12 96       	adiw	r26, 0x02	; 2
     5fe:	ed 91       	ld	r30, X+
     600:	fc 91       	ld	r31, X
     602:	13 97       	sbiw	r26, 0x03	; 3
     604:	80 81       	ld	r24, Z
     606:	91 81       	ldd	r25, Z+1	; 0x01
     608:	28 17       	cp	r18, r24
     60a:	39 07       	cpc	r19, r25
     60c:	98 f7       	brcc	.-26     	; 0x5f4 <vListInsert+0x32>
			/* There is nothing to do here, we are just iterating to the
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
     60e:	12 96       	adiw	r26, 0x02	; 2
     610:	ed 91       	ld	r30, X+
     612:	fc 91       	ld	r31, X
     614:	13 97       	sbiw	r26, 0x03	; 3
     616:	fb 83       	std	Y+3, r31	; 0x03
     618:	ea 83       	std	Y+2, r30	; 0x02
	pxNewListItem->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
     61a:	d5 83       	std	Z+5, r29	; 0x05
     61c:	c4 83       	std	Z+4, r28	; 0x04
	pxNewListItem->pxPrevious = pxIterator;
     61e:	bd 83       	std	Y+5, r27	; 0x05
     620:	ac 83       	std	Y+4, r26	; 0x04
	pxIterator->pxNext = ( volatile xListItem * ) pxNewListItem;
     622:	13 96       	adiw	r26, 0x03	; 3
     624:	dc 93       	st	X, r29
     626:	ce 93       	st	-X, r28
     628:	12 97       	sbiw	r26, 0x02	; 2

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     62a:	59 87       	std	Y+9, r21	; 0x09
     62c:	48 87       	std	Y+8, r20	; 0x08

	( pxList->uxNumberOfItems )++;
     62e:	fa 01       	movw	r30, r20
     630:	80 81       	ld	r24, Z
     632:	8f 5f       	subi	r24, 0xFF	; 255
     634:	80 83       	st	Z, r24
}
     636:	df 91       	pop	r29
     638:	cf 91       	pop	r28
     63a:	08 95       	ret

0000063c <vListRemove>:
/*-----------------------------------------------------------*/

void vListRemove( xListItem *pxItemToRemove )
{
     63c:	fc 01       	movw	r30, r24
xList * pxList;

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
     63e:	a2 81       	ldd	r26, Z+2	; 0x02
     640:	b3 81       	ldd	r27, Z+3	; 0x03
     642:	84 81       	ldd	r24, Z+4	; 0x04
     644:	95 81       	ldd	r25, Z+5	; 0x05
     646:	15 96       	adiw	r26, 0x05	; 5
     648:	9c 93       	st	X, r25
     64a:	8e 93       	st	-X, r24
     64c:	14 97       	sbiw	r26, 0x04	; 4
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
     64e:	a4 81       	ldd	r26, Z+4	; 0x04
     650:	b5 81       	ldd	r27, Z+5	; 0x05
     652:	82 81       	ldd	r24, Z+2	; 0x02
     654:	93 81       	ldd	r25, Z+3	; 0x03
     656:	13 96       	adiw	r26, 0x03	; 3
     658:	9c 93       	st	X, r25
     65a:	8e 93       	st	-X, r24
     65c:	12 97       	sbiw	r26, 0x02	; 2
	
	/* The list item knows which list it is in.  Obtain the list from the list
	item. */
	pxList = ( xList * ) pxItemToRemove->pvContainer;
     65e:	a0 85       	ldd	r26, Z+8	; 0x08
     660:	b1 85       	ldd	r27, Z+9	; 0x09

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
     662:	11 96       	adiw	r26, 0x01	; 1
     664:	8d 91       	ld	r24, X+
     666:	9c 91       	ld	r25, X
     668:	12 97       	sbiw	r26, 0x02	; 2
     66a:	8e 17       	cp	r24, r30
     66c:	9f 07       	cpc	r25, r31
     66e:	31 f4       	brne	.+12     	; 0x67c <vListRemove+0x40>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
     670:	84 81       	ldd	r24, Z+4	; 0x04
     672:	95 81       	ldd	r25, Z+5	; 0x05
     674:	12 96       	adiw	r26, 0x02	; 2
     676:	9c 93       	st	X, r25
     678:	8e 93       	st	-X, r24
     67a:	11 97       	sbiw	r26, 0x01	; 1
	}

	pxItemToRemove->pvContainer = NULL;
     67c:	11 86       	std	Z+9, r1	; 0x09
     67e:	10 86       	std	Z+8, r1	; 0x08
	( pxList->uxNumberOfItems )--;
     680:	8c 91       	ld	r24, X
     682:	81 50       	subi	r24, 0x01	; 1
     684:	8c 93       	st	X, r24
}
     686:	08 95       	ret

00000688 <pxPortInitialiseStack>:
unsigned short usAddress;

	/* Place a few bytes of known values on the bottom of the stack. 
	This is just useful for debugging. */

	*pxTopOfStack = 0x11;
     688:	21 e1       	ldi	r18, 0x11	; 17
     68a:	fc 01       	movw	r30, r24
     68c:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = 0x22;
     68e:	31 97       	sbiw	r30, 0x01	; 1
     690:	32 e2       	ldi	r19, 0x22	; 34
     692:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = 0x33;
     694:	fc 01       	movw	r30, r24
     696:	32 97       	sbiw	r30, 0x02	; 2
     698:	a3 e3       	ldi	r26, 0x33	; 51
     69a:	a0 83       	st	Z, r26
	/*lint -e950 -e611 -e923 Lint doesn't like this much - but nothing I can do about it. */

	/* The start of the task code will be popped off the stack last, so place
	it on first. */
	usAddress = ( unsigned short ) pxCode;
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned short ) 0x00ff );
     69c:	fc 01       	movw	r30, r24
     69e:	33 97       	sbiw	r30, 0x03	; 3
     6a0:	60 83       	st	Z, r22
	pxTopOfStack--;

	usAddress >>= 8;
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned short ) 0x00ff );
     6a2:	fc 01       	movw	r30, r24
     6a4:	34 97       	sbiw	r30, 0x04	; 4
     6a6:	70 83       	st	Z, r23

	/* Next simulate the stack as if after a call to portSAVE_CONTEXT().  
	portSAVE_CONTEXT places the flags on the stack immediately after r0
	to ensure the interrupts get disabled as soon as possible, and so ensuring
	the stack use is minimal should a context switch interrupt occur. */
	*pxTopOfStack = ( portSTACK_TYPE ) 0x00;	/* R0 */
     6a8:	fc 01       	movw	r30, r24
     6aa:	35 97       	sbiw	r30, 0x05	; 5
     6ac:	10 82       	st	Z, r1
	pxTopOfStack--;
	*pxTopOfStack = portFLAGS_INT_ENABLED;
     6ae:	fc 01       	movw	r30, r24
     6b0:	36 97       	sbiw	r30, 0x06	; 6
     6b2:	60 e8       	ldi	r22, 0x80	; 128
     6b4:	60 83       	st	Z, r22
	pxTopOfStack--;


	/* Now the remaining registers.   The compiler expects R1 to be 0. */
	*pxTopOfStack = ( portSTACK_TYPE ) 0x00;	/* R1 */
     6b6:	fc 01       	movw	r30, r24
     6b8:	37 97       	sbiw	r30, 0x07	; 7
     6ba:	10 82       	st	Z, r1
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x02;	/* R2 */
     6bc:	fc 01       	movw	r30, r24
     6be:	38 97       	sbiw	r30, 0x08	; 8
     6c0:	62 e0       	ldi	r22, 0x02	; 2
     6c2:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x03;	/* R3 */
     6c4:	fc 01       	movw	r30, r24
     6c6:	39 97       	sbiw	r30, 0x09	; 9
     6c8:	63 e0       	ldi	r22, 0x03	; 3
     6ca:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x04;	/* R4 */
     6cc:	fc 01       	movw	r30, r24
     6ce:	3a 97       	sbiw	r30, 0x0a	; 10
     6d0:	64 e0       	ldi	r22, 0x04	; 4
     6d2:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x05;	/* R5 */
     6d4:	fc 01       	movw	r30, r24
     6d6:	3b 97       	sbiw	r30, 0x0b	; 11
     6d8:	65 e0       	ldi	r22, 0x05	; 5
     6da:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x06;	/* R6 */
     6dc:	fc 01       	movw	r30, r24
     6de:	3c 97       	sbiw	r30, 0x0c	; 12
     6e0:	66 e0       	ldi	r22, 0x06	; 6
     6e2:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x07;	/* R7 */
     6e4:	fc 01       	movw	r30, r24
     6e6:	3d 97       	sbiw	r30, 0x0d	; 13
     6e8:	67 e0       	ldi	r22, 0x07	; 7
     6ea:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x08;	/* R8 */
     6ec:	fc 01       	movw	r30, r24
     6ee:	3e 97       	sbiw	r30, 0x0e	; 14
     6f0:	68 e0       	ldi	r22, 0x08	; 8
     6f2:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x09;	/* R9 */
     6f4:	fc 01       	movw	r30, r24
     6f6:	3f 97       	sbiw	r30, 0x0f	; 15
     6f8:	69 e0       	ldi	r22, 0x09	; 9
     6fa:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x10;	/* R10 */
     6fc:	fc 01       	movw	r30, r24
     6fe:	70 97       	sbiw	r30, 0x10	; 16
     700:	60 e1       	ldi	r22, 0x10	; 16
     702:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x11;	/* R11 */
     704:	fc 01       	movw	r30, r24
     706:	71 97       	sbiw	r30, 0x11	; 17
     708:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x12;	/* R12 */
     70a:	fc 01       	movw	r30, r24
     70c:	72 97       	sbiw	r30, 0x12	; 18
     70e:	22 e1       	ldi	r18, 0x12	; 18
     710:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x13;	/* R13 */
     712:	fc 01       	movw	r30, r24
     714:	73 97       	sbiw	r30, 0x13	; 19
     716:	23 e1       	ldi	r18, 0x13	; 19
     718:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x14;	/* R14 */
     71a:	fc 01       	movw	r30, r24
     71c:	74 97       	sbiw	r30, 0x14	; 20
     71e:	24 e1       	ldi	r18, 0x14	; 20
     720:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x15;	/* R15 */
     722:	fc 01       	movw	r30, r24
     724:	75 97       	sbiw	r30, 0x15	; 21
     726:	25 e1       	ldi	r18, 0x15	; 21
     728:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x16;	/* R16 */
     72a:	fc 01       	movw	r30, r24
     72c:	76 97       	sbiw	r30, 0x16	; 22
     72e:	26 e1       	ldi	r18, 0x16	; 22
     730:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x17;	/* R17 */
     732:	fc 01       	movw	r30, r24
     734:	77 97       	sbiw	r30, 0x17	; 23
     736:	27 e1       	ldi	r18, 0x17	; 23
     738:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x18;	/* R18 */
     73a:	fc 01       	movw	r30, r24
     73c:	78 97       	sbiw	r30, 0x18	; 24
     73e:	28 e1       	ldi	r18, 0x18	; 24
     740:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x19;	/* R19 */
     742:	fc 01       	movw	r30, r24
     744:	79 97       	sbiw	r30, 0x19	; 25
     746:	29 e1       	ldi	r18, 0x19	; 25
     748:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x20;	/* R20 */
     74a:	fc 01       	movw	r30, r24
     74c:	7a 97       	sbiw	r30, 0x1a	; 26
     74e:	20 e2       	ldi	r18, 0x20	; 32
     750:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x21;	/* R21 */
     752:	fc 01       	movw	r30, r24
     754:	7b 97       	sbiw	r30, 0x1b	; 27
     756:	21 e2       	ldi	r18, 0x21	; 33
     758:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x22;	/* R22 */
     75a:	fc 01       	movw	r30, r24
     75c:	7c 97       	sbiw	r30, 0x1c	; 28
     75e:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x23;	/* R23 */
     760:	fc 01       	movw	r30, r24
     762:	7d 97       	sbiw	r30, 0x1d	; 29
     764:	23 e2       	ldi	r18, 0x23	; 35
     766:	20 83       	st	Z, r18
	pxTopOfStack--;

	/* Place the parameter on the stack in the expected location. */
	usAddress = ( unsigned short ) pvParameters;
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned short ) 0x00ff );
     768:	fc 01       	movw	r30, r24
     76a:	7e 97       	sbiw	r30, 0x1e	; 30
     76c:	40 83       	st	Z, r20
	pxTopOfStack--;

	usAddress >>= 8;
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned short ) 0x00ff );
     76e:	fc 01       	movw	r30, r24
     770:	7f 97       	sbiw	r30, 0x1f	; 31
     772:	50 83       	st	Z, r21
	pxTopOfStack--;

	*pxTopOfStack = ( portSTACK_TYPE ) 0x26;	/* R26 X */
     774:	fc 01       	movw	r30, r24
     776:	b0 97       	sbiw	r30, 0x20	; 32
     778:	26 e2       	ldi	r18, 0x26	; 38
     77a:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x27;	/* R27 */
     77c:	fc 01       	movw	r30, r24
     77e:	b1 97       	sbiw	r30, 0x21	; 33
     780:	27 e2       	ldi	r18, 0x27	; 39
     782:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x28;	/* R28 Y */
     784:	fc 01       	movw	r30, r24
     786:	b2 97       	sbiw	r30, 0x22	; 34
     788:	28 e2       	ldi	r18, 0x28	; 40
     78a:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x29;	/* R29 */
     78c:	fc 01       	movw	r30, r24
     78e:	b3 97       	sbiw	r30, 0x23	; 35
     790:	29 e2       	ldi	r18, 0x29	; 41
     792:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x30;	/* R30 Z */
     794:	fc 01       	movw	r30, r24
     796:	b4 97       	sbiw	r30, 0x24	; 36
     798:	20 e3       	ldi	r18, 0x30	; 48
     79a:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x031;	/* R31 */
     79c:	fc 01       	movw	r30, r24
     79e:	b5 97       	sbiw	r30, 0x25	; 37
     7a0:	21 e3       	ldi	r18, 0x31	; 49
     7a2:	20 83       	st	Z, r18
	pxTopOfStack--;

	/*lint +e950 +e611 +e923 */

	return pxTopOfStack;
     7a4:	86 97       	sbiw	r24, 0x26	; 38
}
     7a6:	08 95       	ret

000007a8 <xPortStartScheduler>:
	/* Setup compare match value for compare match A.  Interrupts are disabled 
	before this is called so we need not worry here. */
	ucLowByte = ( unsigned char ) ( ulCompareMatch & ( unsigned long ) 0xff );
	ulCompareMatch >>= 8;
	ucHighByte = ( unsigned char ) ( ulCompareMatch & ( unsigned long ) 0xff );
	OCR1AH = ucHighByte;
     7a8:	1b bc       	out	0x2b, r1	; 43
	OCR1AL = ucLowByte;
     7aa:	8c e7       	ldi	r24, 0x7C	; 124
     7ac:	8a bd       	out	0x2a, r24	; 42

	/* Setup clock source and compare match behaviour. */
	ucLowByte = portCLEAR_COUNTER_ON_MATCH | portPRESCALE_64;
	TCCR1B = ucLowByte;
     7ae:	8b e0       	ldi	r24, 0x0B	; 11
     7b0:	8e bd       	out	0x2e, r24	; 46

	/* Enable the interrupt - this is okay as interrupt are currently globally
	disabled. */
	ucLowByte = TIMSK;
     7b2:	89 b7       	in	r24, 0x39	; 57
	ucLowByte |= portCOMPARE_MATCH_A_INTERRUPT_ENABLE;
     7b4:	80 61       	ori	r24, 0x10	; 16
	TIMSK = ucLowByte;
     7b6:	89 bf       	out	0x39, r24	; 57
{
	/* Setup the hardware to generate the tick. */
	prvSetupTimerInterrupt();

	/* Restore the context of the first task that is going to run. */
	portRESTORE_CONTEXT();
     7b8:	a0 91 08 03 	lds	r26, 0x0308
     7bc:	b0 91 09 03 	lds	r27, 0x0309
     7c0:	cd 91       	ld	r28, X+
     7c2:	cd bf       	out	0x3d, r28	; 61
     7c4:	dd 91       	ld	r29, X+
     7c6:	de bf       	out	0x3e, r29	; 62
     7c8:	ff 91       	pop	r31
     7ca:	ef 91       	pop	r30
     7cc:	df 91       	pop	r29
     7ce:	cf 91       	pop	r28
     7d0:	bf 91       	pop	r27
     7d2:	af 91       	pop	r26
     7d4:	9f 91       	pop	r25
     7d6:	8f 91       	pop	r24
     7d8:	7f 91       	pop	r23
     7da:	6f 91       	pop	r22
     7dc:	5f 91       	pop	r21
     7de:	4f 91       	pop	r20
     7e0:	3f 91       	pop	r19
     7e2:	2f 91       	pop	r18
     7e4:	1f 91       	pop	r17
     7e6:	0f 91       	pop	r16
     7e8:	ff 90       	pop	r15
     7ea:	ef 90       	pop	r14
     7ec:	df 90       	pop	r13
     7ee:	cf 90       	pop	r12
     7f0:	bf 90       	pop	r11
     7f2:	af 90       	pop	r10
     7f4:	9f 90       	pop	r9
     7f6:	8f 90       	pop	r8
     7f8:	7f 90       	pop	r7
     7fa:	6f 90       	pop	r6
     7fc:	5f 90       	pop	r5
     7fe:	4f 90       	pop	r4
     800:	3f 90       	pop	r3
     802:	2f 90       	pop	r2
     804:	1f 90       	pop	r1
     806:	0f 90       	pop	r0
     808:	0f be       	out	0x3f, r0	; 63
     80a:	0f 90       	pop	r0

	/* Simulate a function call end as generated by the compiler.  We will now
	jump to the start of the task the context of which we have just restored. */
	asm volatile ( "ret" );
     80c:	08 95       	ret

	/* Should not get here. */
	return pdTRUE;
}
     80e:	81 e0       	ldi	r24, 0x01	; 1
     810:	08 95       	ret

00000812 <vPortEndScheduler>:

void vPortEndScheduler( void )
{
	/* It is unlikely that the AVR port will get stopped.  If required simply
	disable the tick interrupt here. */
}
     812:	08 95       	ret

00000814 <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
     814:	0f 92       	push	r0
     816:	0f b6       	in	r0, 0x3f	; 63
     818:	f8 94       	cli
     81a:	0f 92       	push	r0
     81c:	1f 92       	push	r1
     81e:	11 24       	eor	r1, r1
     820:	2f 92       	push	r2
     822:	3f 92       	push	r3
     824:	4f 92       	push	r4
     826:	5f 92       	push	r5
     828:	6f 92       	push	r6
     82a:	7f 92       	push	r7
     82c:	8f 92       	push	r8
     82e:	9f 92       	push	r9
     830:	af 92       	push	r10
     832:	bf 92       	push	r11
     834:	cf 92       	push	r12
     836:	df 92       	push	r13
     838:	ef 92       	push	r14
     83a:	ff 92       	push	r15
     83c:	0f 93       	push	r16
     83e:	1f 93       	push	r17
     840:	2f 93       	push	r18
     842:	3f 93       	push	r19
     844:	4f 93       	push	r20
     846:	5f 93       	push	r21
     848:	6f 93       	push	r22
     84a:	7f 93       	push	r23
     84c:	8f 93       	push	r24
     84e:	9f 93       	push	r25
     850:	af 93       	push	r26
     852:	bf 93       	push	r27
     854:	cf 93       	push	r28
     856:	df 93       	push	r29
     858:	ef 93       	push	r30
     85a:	ff 93       	push	r31
     85c:	a0 91 08 03 	lds	r26, 0x0308
     860:	b0 91 09 03 	lds	r27, 0x0309
     864:	0d b6       	in	r0, 0x3d	; 61
     866:	0d 92       	st	X+, r0
     868:	0e b6       	in	r0, 0x3e	; 62
     86a:	0d 92       	st	X+, r0
	vTaskSwitchContext();
     86c:	0e 94 0e 0c 	call	0x181c	; 0x181c <vTaskSwitchContext>
	portRESTORE_CONTEXT();
     870:	a0 91 08 03 	lds	r26, 0x0308
     874:	b0 91 09 03 	lds	r27, 0x0309
     878:	cd 91       	ld	r28, X+
     87a:	cd bf       	out	0x3d, r28	; 61
     87c:	dd 91       	ld	r29, X+
     87e:	de bf       	out	0x3e, r29	; 62
     880:	ff 91       	pop	r31
     882:	ef 91       	pop	r30
     884:	df 91       	pop	r29
     886:	cf 91       	pop	r28
     888:	bf 91       	pop	r27
     88a:	af 91       	pop	r26
     88c:	9f 91       	pop	r25
     88e:	8f 91       	pop	r24
     890:	7f 91       	pop	r23
     892:	6f 91       	pop	r22
     894:	5f 91       	pop	r21
     896:	4f 91       	pop	r20
     898:	3f 91       	pop	r19
     89a:	2f 91       	pop	r18
     89c:	1f 91       	pop	r17
     89e:	0f 91       	pop	r16
     8a0:	ff 90       	pop	r15
     8a2:	ef 90       	pop	r14
     8a4:	df 90       	pop	r13
     8a6:	cf 90       	pop	r12
     8a8:	bf 90       	pop	r11
     8aa:	af 90       	pop	r10
     8ac:	9f 90       	pop	r9
     8ae:	8f 90       	pop	r8
     8b0:	7f 90       	pop	r7
     8b2:	6f 90       	pop	r6
     8b4:	5f 90       	pop	r5
     8b6:	4f 90       	pop	r4
     8b8:	3f 90       	pop	r3
     8ba:	2f 90       	pop	r2
     8bc:	1f 90       	pop	r1
     8be:	0f 90       	pop	r0
     8c0:	0f be       	out	0x3f, r0	; 63
     8c2:	0f 90       	pop	r0

	asm volatile ( "ret" );
     8c4:	08 95       	ret

000008c6 <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
     8c6:	0f 92       	push	r0
     8c8:	0f b6       	in	r0, 0x3f	; 63
     8ca:	f8 94       	cli
     8cc:	0f 92       	push	r0
     8ce:	1f 92       	push	r1
     8d0:	11 24       	eor	r1, r1
     8d2:	2f 92       	push	r2
     8d4:	3f 92       	push	r3
     8d6:	4f 92       	push	r4
     8d8:	5f 92       	push	r5
     8da:	6f 92       	push	r6
     8dc:	7f 92       	push	r7
     8de:	8f 92       	push	r8
     8e0:	9f 92       	push	r9
     8e2:	af 92       	push	r10
     8e4:	bf 92       	push	r11
     8e6:	cf 92       	push	r12
     8e8:	df 92       	push	r13
     8ea:	ef 92       	push	r14
     8ec:	ff 92       	push	r15
     8ee:	0f 93       	push	r16
     8f0:	1f 93       	push	r17
     8f2:	2f 93       	push	r18
     8f4:	3f 93       	push	r19
     8f6:	4f 93       	push	r20
     8f8:	5f 93       	push	r21
     8fa:	6f 93       	push	r22
     8fc:	7f 93       	push	r23
     8fe:	8f 93       	push	r24
     900:	9f 93       	push	r25
     902:	af 93       	push	r26
     904:	bf 93       	push	r27
     906:	cf 93       	push	r28
     908:	df 93       	push	r29
     90a:	ef 93       	push	r30
     90c:	ff 93       	push	r31
     90e:	a0 91 08 03 	lds	r26, 0x0308
     912:	b0 91 09 03 	lds	r27, 0x0309
     916:	0d b6       	in	r0, 0x3d	; 61
     918:	0d 92       	st	X+, r0
     91a:	0e b6       	in	r0, 0x3e	; 62
     91c:	0d 92       	st	X+, r0
	vTaskIncrementTick();
     91e:	0e 94 1a 0a 	call	0x1434	; 0x1434 <vTaskIncrementTick>
	vTaskSwitchContext();
     922:	0e 94 0e 0c 	call	0x181c	; 0x181c <vTaskSwitchContext>
	portRESTORE_CONTEXT();
     926:	a0 91 08 03 	lds	r26, 0x0308
     92a:	b0 91 09 03 	lds	r27, 0x0309
     92e:	cd 91       	ld	r28, X+
     930:	cd bf       	out	0x3d, r28	; 61
     932:	dd 91       	ld	r29, X+
     934:	de bf       	out	0x3e, r29	; 62
     936:	ff 91       	pop	r31
     938:	ef 91       	pop	r30
     93a:	df 91       	pop	r29
     93c:	cf 91       	pop	r28
     93e:	bf 91       	pop	r27
     940:	af 91       	pop	r26
     942:	9f 91       	pop	r25
     944:	8f 91       	pop	r24
     946:	7f 91       	pop	r23
     948:	6f 91       	pop	r22
     94a:	5f 91       	pop	r21
     94c:	4f 91       	pop	r20
     94e:	3f 91       	pop	r19
     950:	2f 91       	pop	r18
     952:	1f 91       	pop	r17
     954:	0f 91       	pop	r16
     956:	ff 90       	pop	r15
     958:	ef 90       	pop	r14
     95a:	df 90       	pop	r13
     95c:	cf 90       	pop	r12
     95e:	bf 90       	pop	r11
     960:	af 90       	pop	r10
     962:	9f 90       	pop	r9
     964:	8f 90       	pop	r8
     966:	7f 90       	pop	r7
     968:	6f 90       	pop	r6
     96a:	5f 90       	pop	r5
     96c:	4f 90       	pop	r4
     96e:	3f 90       	pop	r3
     970:	2f 90       	pop	r2
     972:	1f 90       	pop	r1
     974:	0f 90       	pop	r0
     976:	0f be       	out	0x3f, r0	; 63
     978:	0f 90       	pop	r0

	asm volatile ( "ret" );
     97a:	08 95       	ret

0000097c <__vector_7>:
	 * count is incremented after the context is saved.
	 */
	void  TIMER1_COMPA_vect( void ) __attribute__ ( ( signal, naked ) );
	void  TIMER1_COMPA_vect( void )
	{
		vPortYieldFromTick();
     97c:	0e 94 63 04 	call	0x8c6	; 0x8c6 <vPortYieldFromTick>
		asm volatile ( "reti" );
     980:	18 95       	reti

00000982 <prvCopyDataFromQueue>:
	++( pxQueue->uxMessagesWaiting );
}
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( xQUEUE * const pxQueue, const void *pvBuffer )
{
     982:	cf 93       	push	r28
     984:	df 93       	push	r29
     986:	dc 01       	movw	r26, r24
	if( pxQueue->uxQueueType != queueQUEUE_IS_MUTEX )
     988:	cd 91       	ld	r28, X+
     98a:	dc 91       	ld	r29, X
     98c:	11 97       	sbiw	r26, 0x01	; 1
     98e:	20 97       	sbiw	r28, 0x00	; 0
     990:	21 f1       	breq	.+72     	; 0x9da <prvCopyDataFromQueue+0x58>
	{
		pxQueue->pcReadFrom += pxQueue->uxItemSize;
     992:	5c 96       	adiw	r26, 0x1c	; 28
     994:	4c 91       	ld	r20, X
     996:	5c 97       	sbiw	r26, 0x1c	; 28
     998:	16 96       	adiw	r26, 0x06	; 6
     99a:	2d 91       	ld	r18, X+
     99c:	3c 91       	ld	r19, X
     99e:	17 97       	sbiw	r26, 0x07	; 7
     9a0:	24 0f       	add	r18, r20
     9a2:	31 1d       	adc	r19, r1
     9a4:	17 96       	adiw	r26, 0x07	; 7
     9a6:	3c 93       	st	X, r19
     9a8:	2e 93       	st	-X, r18
     9aa:	16 97       	sbiw	r26, 0x06	; 6
		if( pxQueue->pcReadFrom >= pxQueue->pcTail )
     9ac:	12 96       	adiw	r26, 0x02	; 2
     9ae:	ed 91       	ld	r30, X+
     9b0:	fc 91       	ld	r31, X
     9b2:	13 97       	sbiw	r26, 0x03	; 3
     9b4:	2e 17       	cp	r18, r30
     9b6:	3f 07       	cpc	r19, r31
     9b8:	20 f0       	brcs	.+8      	; 0x9c2 <prvCopyDataFromQueue+0x40>
		{
			pxQueue->pcReadFrom = pxQueue->pcHead;
     9ba:	17 96       	adiw	r26, 0x07	; 7
     9bc:	dc 93       	st	X, r29
     9be:	ce 93       	st	-X, r28
     9c0:	16 97       	sbiw	r26, 0x06	; 6
		}
		memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
     9c2:	16 96       	adiw	r26, 0x06	; 6
     9c4:	3c 91       	ld	r19, X
     9c6:	16 97       	sbiw	r26, 0x06	; 6
     9c8:	17 96       	adiw	r26, 0x07	; 7
     9ca:	2c 91       	ld	r18, X
     9cc:	86 2f       	mov	r24, r22
     9ce:	97 2f       	mov	r25, r23
     9d0:	63 2f       	mov	r22, r19
     9d2:	72 2f       	mov	r23, r18
     9d4:	50 e0       	ldi	r21, 0x00	; 0
     9d6:	0e 94 15 0d 	call	0x1a2a	; 0x1a2a <memcpy>
	}
}
     9da:	df 91       	pop	r29
     9dc:	cf 91       	pop	r28
     9de:	08 95       	ret

000009e0 <prvCopyDataToQueue>:
	vPortFree( pxQueue );
}
/*-----------------------------------------------------------*/

static void prvCopyDataToQueue( xQUEUE *pxQueue, const void *pvItemToQueue, portBASE_TYPE xPosition )
{
     9e0:	cf 93       	push	r28
     9e2:	df 93       	push	r29
     9e4:	ec 01       	movw	r28, r24
	if( pxQueue->uxItemSize == ( unsigned portBASE_TYPE ) 0 )
     9e6:	2c 8d       	ldd	r18, Y+28	; 0x1c
     9e8:	22 23       	and	r18, r18
     9ea:	a9 f1       	breq	.+106    	; 0xa56 <prvCopyDataToQueue+0x76>
				pxQueue->pxMutexHolder = NULL;
			}
		}
		#endif
	}
	else if( xPosition == queueSEND_TO_BACK )
     9ec:	44 23       	and	r20, r20
     9ee:	b9 f4       	brne	.+46     	; 0xa1e <prvCopyDataToQueue+0x3e>
	{
		memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
     9f0:	8c 81       	ldd	r24, Y+4	; 0x04
     9f2:	9d 81       	ldd	r25, Y+5	; 0x05
     9f4:	42 2f       	mov	r20, r18
     9f6:	50 e0       	ldi	r21, 0x00	; 0
     9f8:	0e 94 15 0d 	call	0x1a2a	; 0x1a2a <memcpy>
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
     9fc:	2c 8d       	ldd	r18, Y+28	; 0x1c
     9fe:	8c 81       	ldd	r24, Y+4	; 0x04
     a00:	9d 81       	ldd	r25, Y+5	; 0x05
     a02:	82 0f       	add	r24, r18
     a04:	91 1d       	adc	r25, r1
     a06:	9d 83       	std	Y+5, r25	; 0x05
     a08:	8c 83       	std	Y+4, r24	; 0x04
		if( pxQueue->pcWriteTo >= pxQueue->pcTail )
     a0a:	2a 81       	ldd	r18, Y+2	; 0x02
     a0c:	3b 81       	ldd	r19, Y+3	; 0x03
     a0e:	82 17       	cp	r24, r18
     a10:	93 07       	cpc	r25, r19
     a12:	08 f1       	brcs	.+66     	; 0xa56 <prvCopyDataToQueue+0x76>
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
     a14:	88 81       	ld	r24, Y
     a16:	99 81       	ldd	r25, Y+1	; 0x01
     a18:	9d 83       	std	Y+5, r25	; 0x05
     a1a:	8c 83       	std	Y+4, r24	; 0x04
     a1c:	1c c0       	rjmp	.+56     	; 0xa56 <prvCopyDataToQueue+0x76>
		}
	}
	else
	{
		memcpy( ( void * ) pxQueue->pcReadFrom, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
     a1e:	8e 81       	ldd	r24, Y+6	; 0x06
     a20:	9f 81       	ldd	r25, Y+7	; 0x07
     a22:	42 2f       	mov	r20, r18
     a24:	50 e0       	ldi	r21, 0x00	; 0
     a26:	0e 94 15 0d 	call	0x1a2a	; 0x1a2a <memcpy>
		pxQueue->pcReadFrom -= pxQueue->uxItemSize;
     a2a:	4c 8d       	ldd	r20, Y+28	; 0x1c
     a2c:	50 e0       	ldi	r21, 0x00	; 0
     a2e:	50 95       	com	r21
     a30:	41 95       	neg	r20
     a32:	5f 4f       	sbci	r21, 0xFF	; 255
     a34:	8e 81       	ldd	r24, Y+6	; 0x06
     a36:	9f 81       	ldd	r25, Y+7	; 0x07
     a38:	84 0f       	add	r24, r20
     a3a:	95 1f       	adc	r25, r21
     a3c:	9f 83       	std	Y+7, r25	; 0x07
     a3e:	8e 83       	std	Y+6, r24	; 0x06
		if( pxQueue->pcReadFrom < pxQueue->pcHead )
     a40:	28 81       	ld	r18, Y
     a42:	39 81       	ldd	r19, Y+1	; 0x01
     a44:	82 17       	cp	r24, r18
     a46:	93 07       	cpc	r25, r19
     a48:	30 f4       	brcc	.+12     	; 0xa56 <prvCopyDataToQueue+0x76>
		{
			pxQueue->pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
     a4a:	8a 81       	ldd	r24, Y+2	; 0x02
     a4c:	9b 81       	ldd	r25, Y+3	; 0x03
     a4e:	48 0f       	add	r20, r24
     a50:	59 1f       	adc	r21, r25
     a52:	5f 83       	std	Y+7, r21	; 0x07
     a54:	4e 83       	std	Y+6, r20	; 0x06
		}
	}

	++( pxQueue->uxMessagesWaiting );
     a56:	8a 8d       	ldd	r24, Y+26	; 0x1a
     a58:	8f 5f       	subi	r24, 0xFF	; 255
     a5a:	8a 8f       	std	Y+26, r24	; 0x1a
}
     a5c:	df 91       	pop	r29
     a5e:	cf 91       	pop	r28
     a60:	08 95       	ret

00000a62 <prvUnlockQueue>:
	}
}
/*-----------------------------------------------------------*/

static void prvUnlockQueue( xQueueHandle pxQueue )
{
     a62:	0f 93       	push	r16
     a64:	1f 93       	push	r17
     a66:	cf 93       	push	r28
     a68:	df 93       	push	r29
     a6a:	ec 01       	movw	r28, r24

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
     a6c:	0f b6       	in	r0, 0x3f	; 63
     a6e:	f8 94       	cli
     a70:	0f 92       	push	r0
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
     a72:	8e 8d       	ldd	r24, Y+30	; 0x1e
     a74:	18 16       	cp	r1, r24
     a76:	bc f4       	brge	.+46     	; 0xaa6 <prvUnlockQueue+0x44>
		{
			/* Data was posted while the queue was locked.  Are any tasks
			blocked waiting for data to become available? */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
     a78:	89 89       	ldd	r24, Y+17	; 0x11
     a7a:	88 23       	and	r24, r24
     a7c:	29 f4       	brne	.+10     	; 0xa88 <prvUnlockQueue+0x26>
     a7e:	13 c0       	rjmp	.+38     	; 0xaa6 <prvUnlockQueue+0x44>
     a80:	89 89       	ldd	r24, Y+17	; 0x11
     a82:	88 23       	and	r24, r24
     a84:	21 f4       	brne	.+8      	; 0xa8e <prvUnlockQueue+0x2c>
     a86:	0f c0       	rjmp	.+30     	; 0xaa6 <prvUnlockQueue+0x44>
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
     a88:	8e 01       	movw	r16, r28
     a8a:	0f 5e       	subi	r16, 0xEF	; 239
     a8c:	1f 4f       	sbci	r17, 0xFF	; 255
     a8e:	c8 01       	movw	r24, r16
     a90:	0e 94 88 0c 	call	0x1910	; 0x1910 <xTaskRemoveFromEventList>
     a94:	88 23       	and	r24, r24
     a96:	11 f0       	breq	.+4      	; 0xa9c <prvUnlockQueue+0x3a>
				{
					/* The task waiting has a higher priority so record that a
					context	switch is required. */
					vTaskMissedYield();
     a98:	0e 94 11 0d 	call	0x1a22	; 0x1a22 <vTaskMissedYield>
				}

				--( pxQueue->xTxLock );
     a9c:	8e 8d       	ldd	r24, Y+30	; 0x1e
     a9e:	81 50       	subi	r24, 0x01	; 1
     aa0:	8e 8f       	std	Y+30, r24	; 0x1e
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
     aa2:	18 16       	cp	r1, r24
     aa4:	6c f3       	brlt	.-38     	; 0xa80 <prvUnlockQueue+0x1e>
			{
				break;
			}
		}

		pxQueue->xTxLock = queueUNLOCKED;
     aa6:	8f ef       	ldi	r24, 0xFF	; 255
     aa8:	8e 8f       	std	Y+30, r24	; 0x1e
	}
	taskEXIT_CRITICAL();
     aaa:	0f 90       	pop	r0
     aac:	0f be       	out	0x3f, r0	; 63

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
     aae:	0f b6       	in	r0, 0x3f	; 63
     ab0:	f8 94       	cli
     ab2:	0f 92       	push	r0
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
     ab4:	8d 8d       	ldd	r24, Y+29	; 0x1d
     ab6:	18 16       	cp	r1, r24
     ab8:	bc f4       	brge	.+46     	; 0xae8 <prvUnlockQueue+0x86>
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
     aba:	88 85       	ldd	r24, Y+8	; 0x08
     abc:	88 23       	and	r24, r24
     abe:	29 f4       	brne	.+10     	; 0xaca <prvUnlockQueue+0x68>
     ac0:	13 c0       	rjmp	.+38     	; 0xae8 <prvUnlockQueue+0x86>
     ac2:	88 85       	ldd	r24, Y+8	; 0x08
     ac4:	88 23       	and	r24, r24
     ac6:	21 f4       	brne	.+8      	; 0xad0 <prvUnlockQueue+0x6e>
     ac8:	0f c0       	rjmp	.+30     	; 0xae8 <prvUnlockQueue+0x86>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
     aca:	8e 01       	movw	r16, r28
     acc:	08 5f       	subi	r16, 0xF8	; 248
     ace:	1f 4f       	sbci	r17, 0xFF	; 255
     ad0:	c8 01       	movw	r24, r16
     ad2:	0e 94 88 0c 	call	0x1910	; 0x1910 <xTaskRemoveFromEventList>
     ad6:	88 23       	and	r24, r24
     ad8:	11 f0       	breq	.+4      	; 0xade <prvUnlockQueue+0x7c>
				{
					vTaskMissedYield();
     ada:	0e 94 11 0d 	call	0x1a22	; 0x1a22 <vTaskMissedYield>
				}

				--( pxQueue->xRxLock );
     ade:	8d 8d       	ldd	r24, Y+29	; 0x1d
     ae0:	81 50       	subi	r24, 0x01	; 1
     ae2:	8d 8f       	std	Y+29, r24	; 0x1d
	taskEXIT_CRITICAL();

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
     ae4:	18 16       	cp	r1, r24
     ae6:	6c f3       	brlt	.-38     	; 0xac2 <prvUnlockQueue+0x60>
			{
				break;
			}
		}

		pxQueue->xRxLock = queueUNLOCKED;
     ae8:	8f ef       	ldi	r24, 0xFF	; 255
     aea:	8d 8f       	std	Y+29, r24	; 0x1d
	}
	taskEXIT_CRITICAL();
     aec:	0f 90       	pop	r0
     aee:	0f be       	out	0x3f, r0	; 63
}
     af0:	df 91       	pop	r29
     af2:	cf 91       	pop	r28
     af4:	1f 91       	pop	r17
     af6:	0f 91       	pop	r16
     af8:	08 95       	ret

00000afa <xQueueCreate>:
/*-----------------------------------------------------------
 * PUBLIC QUEUE MANAGEMENT API documented in queue.h
 *----------------------------------------------------------*/

xQueueHandle xQueueCreate( unsigned portBASE_TYPE uxQueueLength, unsigned portBASE_TYPE uxItemSize )
{
     afa:	af 92       	push	r10
     afc:	bf 92       	push	r11
     afe:	cf 92       	push	r12
     b00:	df 92       	push	r13
     b02:	ef 92       	push	r14
     b04:	ff 92       	push	r15
     b06:	0f 93       	push	r16
     b08:	1f 93       	push	r17
     b0a:	cf 93       	push	r28
     b0c:	df 93       	push	r29
     b0e:	f8 2e       	mov	r15, r24
     b10:	e6 2e       	mov	r14, r22
xQUEUE *pxNewQueue;
size_t xQueueSizeInBytes;
xQueueHandle xReturn = NULL;

	/* Allocate the new queue structure. */
	if( uxQueueLength > ( unsigned portBASE_TYPE ) 0 )
     b12:	88 23       	and	r24, r24
     b14:	09 f4       	brne	.+2      	; 0xb18 <xQueueCreate+0x1e>
     b16:	46 c0       	rjmp	.+140    	; 0xba4 <xQueueCreate+0xaa>
	{
		pxNewQueue = ( xQUEUE * ) pvPortMalloc( sizeof( xQUEUE ) );
     b18:	8f e1       	ldi	r24, 0x1F	; 31
     b1a:	90 e0       	ldi	r25, 0x00	; 0
     b1c:	0e 94 6e 02 	call	0x4dc	; 0x4dc <pvPortMalloc>
     b20:	8c 01       	movw	r16, r24
		if( pxNewQueue != NULL )
     b22:	00 97       	sbiw	r24, 0x00	; 0
     b24:	09 f4       	brne	.+2      	; 0xb28 <xQueueCreate+0x2e>
     b26:	41 c0       	rjmp	.+130    	; 0xbaa <xQueueCreate+0xb0>
		{
			/* Create the list of pointers to queue items.  The queue is one byte
			longer than asked for to make wrap checking easier/faster. */
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ) + ( size_t ) 1;
     b28:	cf 2c       	mov	r12, r15
     b2a:	dd 24       	eor	r13, r13
     b2c:	ae 2c       	mov	r10, r14
     b2e:	bb 24       	eor	r11, r11
     b30:	ca 9c       	mul	r12, r10
     b32:	e0 01       	movw	r28, r0
     b34:	cb 9c       	mul	r12, r11
     b36:	d0 0d       	add	r29, r0
     b38:	da 9c       	mul	r13, r10
     b3a:	d0 0d       	add	r29, r0
     b3c:	11 24       	eor	r1, r1

			pxNewQueue->pcHead = ( signed char * ) pvPortMalloc( xQueueSizeInBytes );
     b3e:	ce 01       	movw	r24, r28
     b40:	01 96       	adiw	r24, 0x01	; 1
     b42:	0e 94 6e 02 	call	0x4dc	; 0x4dc <pvPortMalloc>
     b46:	ac 01       	movw	r20, r24
     b48:	f8 01       	movw	r30, r16
     b4a:	91 83       	std	Z+1, r25	; 0x01
     b4c:	80 83       	st	Z, r24
			if( pxNewQueue->pcHead != NULL )
     b4e:	00 97       	sbiw	r24, 0x00	; 0
     b50:	19 f1       	breq	.+70     	; 0xb98 <xQueueCreate+0x9e>
			{
				/* Initialise the queue members as described above where the
				queue type is defined. */
				pxNewQueue->pcTail = pxNewQueue->pcHead + ( uxQueueLength * uxItemSize );
     b52:	c8 0f       	add	r28, r24
     b54:	d9 1f       	adc	r29, r25
     b56:	d3 83       	std	Z+3, r29	; 0x03
     b58:	c2 83       	std	Z+2, r28	; 0x02
				pxNewQueue->uxMessagesWaiting = ( unsigned portBASE_TYPE ) 0U;
     b5a:	12 8e       	std	Z+26, r1	; 0x1a
				pxNewQueue->pcWriteTo = pxNewQueue->pcHead;
     b5c:	95 83       	std	Z+5, r25	; 0x05
     b5e:	84 83       	std	Z+4, r24	; 0x04
				pxNewQueue->pcReadFrom = pxNewQueue->pcHead + ( ( uxQueueLength - ( unsigned portBASE_TYPE ) 1U ) * uxItemSize );
     b60:	c6 01       	movw	r24, r12
     b62:	01 97       	sbiw	r24, 0x01	; 1
     b64:	a8 9e       	mul	r10, r24
     b66:	90 01       	movw	r18, r0
     b68:	a9 9e       	mul	r10, r25
     b6a:	30 0d       	add	r19, r0
     b6c:	b8 9e       	mul	r11, r24
     b6e:	30 0d       	add	r19, r0
     b70:	11 24       	eor	r1, r1
     b72:	24 0f       	add	r18, r20
     b74:	35 1f       	adc	r19, r21
     b76:	37 83       	std	Z+7, r19	; 0x07
     b78:	26 83       	std	Z+6, r18	; 0x06
				pxNewQueue->uxLength = uxQueueLength;
     b7a:	f3 8e       	std	Z+27, r15	; 0x1b
				pxNewQueue->uxItemSize = uxItemSize;
     b7c:	e4 8e       	std	Z+28, r14	; 0x1c
				pxNewQueue->xRxLock = queueUNLOCKED;
     b7e:	8f ef       	ldi	r24, 0xFF	; 255
     b80:	85 8f       	std	Z+29, r24	; 0x1d
				pxNewQueue->xTxLock = queueUNLOCKED;
     b82:	86 8f       	std	Z+30, r24	; 0x1e

				/* Likewise ensure the event queues start with the correct state. */
				vListInitialise( &( pxNewQueue->xTasksWaitingToSend ) );
     b84:	c8 01       	movw	r24, r16
     b86:	08 96       	adiw	r24, 0x08	; 8
     b88:	0e 94 a6 02 	call	0x54c	; 0x54c <vListInitialise>
				vListInitialise( &( pxNewQueue->xTasksWaitingToReceive ) );
     b8c:	c8 01       	movw	r24, r16
     b8e:	41 96       	adiw	r24, 0x11	; 17
     b90:	0e 94 a6 02 	call	0x54c	; 0x54c <vListInitialise>

				traceQUEUE_CREATE( pxNewQueue );
				xReturn = pxNewQueue;
     b94:	c8 01       	movw	r24, r16
     b96:	0b c0       	rjmp	.+22     	; 0xbae <xQueueCreate+0xb4>
			}
			else
			{
				traceQUEUE_CREATE_FAILED();
				vPortFree( pxNewQueue );
     b98:	c8 01       	movw	r24, r16
     b9a:	0e 94 97 02 	call	0x52e	; 0x52e <vPortFree>

xQueueHandle xQueueCreate( unsigned portBASE_TYPE uxQueueLength, unsigned portBASE_TYPE uxItemSize )
{
xQUEUE *pxNewQueue;
size_t xQueueSizeInBytes;
xQueueHandle xReturn = NULL;
     b9e:	80 e0       	ldi	r24, 0x00	; 0
     ba0:	90 e0       	ldi	r25, 0x00	; 0
     ba2:	05 c0       	rjmp	.+10     	; 0xbae <xQueueCreate+0xb4>
     ba4:	80 e0       	ldi	r24, 0x00	; 0
     ba6:	90 e0       	ldi	r25, 0x00	; 0
     ba8:	02 c0       	rjmp	.+4      	; 0xbae <xQueueCreate+0xb4>
     baa:	80 e0       	ldi	r24, 0x00	; 0
     bac:	90 e0       	ldi	r25, 0x00	; 0
	}

	configASSERT( xReturn );

	return xReturn;
}
     bae:	df 91       	pop	r29
     bb0:	cf 91       	pop	r28
     bb2:	1f 91       	pop	r17
     bb4:	0f 91       	pop	r16
     bb6:	ff 90       	pop	r15
     bb8:	ef 90       	pop	r14
     bba:	df 90       	pop	r13
     bbc:	cf 90       	pop	r12
     bbe:	bf 90       	pop	r11
     bc0:	af 90       	pop	r10
     bc2:	08 95       	ret

00000bc4 <xQueueGenericSend>:

#endif /* configUSE_COUNTING_SEMAPHORES */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSend( xQueueHandle pxQueue, const void * const pvItemToQueue, portTickType xTicksToWait, portBASE_TYPE xCopyPosition )
{
     bc4:	8f 92       	push	r8
     bc6:	9f 92       	push	r9
     bc8:	bf 92       	push	r11
     bca:	cf 92       	push	r12
     bcc:	df 92       	push	r13
     bce:	ef 92       	push	r14
     bd0:	ff 92       	push	r15
     bd2:	0f 93       	push	r16
     bd4:	1f 93       	push	r17
     bd6:	cf 93       	push	r28
     bd8:	df 93       	push	r29
     bda:	00 d0       	rcall	.+0      	; 0xbdc <xQueueGenericSend+0x18>
     bdc:	00 d0       	rcall	.+0      	; 0xbde <xQueueGenericSend+0x1a>
     bde:	0f 92       	push	r0
     be0:	cd b7       	in	r28, 0x3d	; 61
     be2:	de b7       	in	r29, 0x3e	; 62
     be4:	8c 01       	movw	r16, r24
     be6:	4b 01       	movw	r8, r22
     be8:	5d 83       	std	Y+5, r21	; 0x05
     bea:	4c 83       	std	Y+4, r20	; 0x04
     bec:	b2 2e       	mov	r11, r18
signed portBASE_TYPE xEntryTimeSet = pdFALSE;
     bee:	ff 24       	eor	r15, r15
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
					xEntryTimeSet = pdTRUE;
     bf0:	ee 24       	eor	r14, r14
     bf2:	e3 94       	inc	r14
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
     bf4:	cc 24       	eor	r12, r12
     bf6:	dd 24       	eor	r13, r13
     bf8:	68 94       	set
     bfa:	c3 f8       	bld	r12, 3
     bfc:	c8 0e       	add	r12, r24
     bfe:	d9 1e       	adc	r13, r25
	/* This function relaxes the coding standard somewhat to allow return
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
     c00:	0f b6       	in	r0, 0x3f	; 63
     c02:	f8 94       	cli
     c04:	0f 92       	push	r0
		{
			/* Is there room on the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
     c06:	f8 01       	movw	r30, r16
     c08:	92 8d       	ldd	r25, Z+26	; 0x1a
     c0a:	83 8d       	ldd	r24, Z+27	; 0x1b
     c0c:	98 17       	cp	r25, r24
     c0e:	a8 f4       	brcc	.+42     	; 0xc3a <xQueueGenericSend+0x76>
			{
				traceQUEUE_SEND( pxQueue );
				prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
     c10:	c8 01       	movw	r24, r16
     c12:	b4 01       	movw	r22, r8
     c14:	4b 2d       	mov	r20, r11
     c16:	0e 94 f0 04 	call	0x9e0	; 0x9e0 <prvCopyDataToQueue>

				/* If there was a task waiting for data to arrive on the
				queue then unblock it now. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
     c1a:	f8 01       	movw	r30, r16
     c1c:	81 89       	ldd	r24, Z+17	; 0x11
     c1e:	88 23       	and	r24, r24
     c20:	41 f0       	breq	.+16     	; 0xc32 <xQueueGenericSend+0x6e>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) == pdTRUE )
     c22:	c8 01       	movw	r24, r16
     c24:	41 96       	adiw	r24, 0x11	; 17
     c26:	0e 94 88 0c 	call	0x1910	; 0x1910 <xTaskRemoveFromEventList>
     c2a:	81 30       	cpi	r24, 0x01	; 1
     c2c:	11 f4       	brne	.+4      	; 0xc32 <xQueueGenericSend+0x6e>
					{
						/* The unblocked task has a priority higher than
						our own so yield immediately.  Yes it is ok to do
						this from within the critical section - the kernel
						takes care of that. */
						portYIELD_WITHIN_API();
     c2e:	0e 94 0a 04 	call	0x814	; 0x814 <vPortYield>
					}
				}

				taskEXIT_CRITICAL();
     c32:	0f 90       	pop	r0
     c34:	0f be       	out	0x3f, r0	; 63

				/* Return to the original privilege level before exiting the
				function. */
				return pdPASS;
     c36:	81 e0       	ldi	r24, 0x01	; 1
     c38:	52 c0       	rjmp	.+164    	; 0xcde <xQueueGenericSend+0x11a>
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
     c3a:	8c 81       	ldd	r24, Y+4	; 0x04
     c3c:	9d 81       	ldd	r25, Y+5	; 0x05
     c3e:	00 97       	sbiw	r24, 0x00	; 0
     c40:	21 f4       	brne	.+8      	; 0xc4a <xQueueGenericSend+0x86>
				{
					/* The queue was full and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
     c42:	0f 90       	pop	r0
     c44:	0f be       	out	0x3f, r0	; 63

					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED( pxQueue );
					return errQUEUE_FULL;
     c46:	80 e0       	ldi	r24, 0x00	; 0
     c48:	4a c0       	rjmp	.+148    	; 0xcde <xQueueGenericSend+0x11a>
				}
				else if( xEntryTimeSet == pdFALSE )
     c4a:	ff 20       	and	r15, r15
     c4c:	29 f4       	brne	.+10     	; 0xc58 <xQueueGenericSend+0x94>
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
     c4e:	ce 01       	movw	r24, r28
     c50:	01 96       	adiw	r24, 0x01	; 1
     c52:	0e 94 d0 0c 	call	0x19a0	; 0x19a0 <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
     c56:	fe 2c       	mov	r15, r14
				}
			}
		}
		taskEXIT_CRITICAL();
     c58:	0f 90       	pop	r0
     c5a:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
     c5c:	0e 94 02 0a 	call	0x1404	; 0x1404 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
     c60:	0f b6       	in	r0, 0x3f	; 63
     c62:	f8 94       	cli
     c64:	0f 92       	push	r0
     c66:	f8 01       	movw	r30, r16
     c68:	85 8d       	ldd	r24, Z+29	; 0x1d
     c6a:	8f 3f       	cpi	r24, 0xFF	; 255
     c6c:	09 f4       	brne	.+2      	; 0xc70 <xQueueGenericSend+0xac>
     c6e:	15 8e       	std	Z+29, r1	; 0x1d
     c70:	f8 01       	movw	r30, r16
     c72:	86 8d       	ldd	r24, Z+30	; 0x1e
     c74:	8f 3f       	cpi	r24, 0xFF	; 255
     c76:	09 f4       	brne	.+2      	; 0xc7a <xQueueGenericSend+0xb6>
     c78:	16 8e       	std	Z+30, r1	; 0x1e
     c7a:	0f 90       	pop	r0
     c7c:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
     c7e:	ce 01       	movw	r24, r28
     c80:	01 96       	adiw	r24, 0x01	; 1
     c82:	be 01       	movw	r22, r28
     c84:	6c 5f       	subi	r22, 0xFC	; 252
     c86:	7f 4f       	sbci	r23, 0xFF	; 255
     c88:	0e 94 db 0c 	call	0x19b6	; 0x19b6 <xTaskCheckForTimeOut>
     c8c:	88 23       	and	r24, r24
     c8e:	09 f5       	brne	.+66     	; 0xcd2 <xQueueGenericSend+0x10e>

static signed portBASE_TYPE prvIsQueueFull( const xQueueHandle pxQueue )
{
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
     c90:	0f b6       	in	r0, 0x3f	; 63
     c92:	f8 94       	cli
     c94:	0f 92       	push	r0
		xReturn = ( pxQueue->uxMessagesWaiting == pxQueue->uxLength );
     c96:	f8 01       	movw	r30, r16
     c98:	92 8d       	ldd	r25, Z+26	; 0x1a
	taskEXIT_CRITICAL();
     c9a:	0f 90       	pop	r0
     c9c:	0f be       	out	0x3f, r0	; 63
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
     c9e:	f8 01       	movw	r30, r16
     ca0:	83 8d       	ldd	r24, Z+27	; 0x1b
     ca2:	98 17       	cp	r25, r24
     ca4:	81 f4       	brne	.+32     	; 0xcc6 <xQueueGenericSend+0x102>
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
     ca6:	6c 81       	ldd	r22, Y+4	; 0x04
     ca8:	7d 81       	ldd	r23, Y+5	; 0x05
     caa:	c6 01       	movw	r24, r12
     cac:	0e 94 6b 0c 	call	0x18d6	; 0x18d6 <vTaskPlaceOnEventList>
				/* Unlocking the queue means queue events can effect the
				event list.  It is possible	that interrupts occurring now
				remove this task from the event	list again - but as the
				scheduler is suspended the task will go onto the pending
				ready last instead of the actual ready list. */
				prvUnlockQueue( pxQueue );
     cb0:	c8 01       	movw	r24, r16
     cb2:	0e 94 31 05 	call	0xa62	; 0xa62 <prvUnlockQueue>
				/* Resuming the scheduler will move tasks from the pending
				ready list into the ready list - so it is feasible that this
				task is already in a ready list before it yields - in which
				case the yield will not cause a context switch unless there
				is also a higher priority task in the pending ready list. */
				if( xTaskResumeAll() == pdFALSE )
     cb6:	0e 94 e0 0a 	call	0x15c0	; 0x15c0 <xTaskResumeAll>
     cba:	88 23       	and	r24, r24
     cbc:	09 f0       	breq	.+2      	; 0xcc0 <xQueueGenericSend+0xfc>
     cbe:	a0 cf       	rjmp	.-192    	; 0xc00 <xQueueGenericSend+0x3c>
				{
					portYIELD_WITHIN_API();
     cc0:	0e 94 0a 04 	call	0x814	; 0x814 <vPortYield>
     cc4:	9d cf       	rjmp	.-198    	; 0xc00 <xQueueGenericSend+0x3c>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
     cc6:	c8 01       	movw	r24, r16
     cc8:	0e 94 31 05 	call	0xa62	; 0xa62 <prvUnlockQueue>
				( void ) xTaskResumeAll();
     ccc:	0e 94 e0 0a 	call	0x15c0	; 0x15c0 <xTaskResumeAll>
     cd0:	97 cf       	rjmp	.-210    	; 0xc00 <xQueueGenericSend+0x3c>
			}
		}
		else
		{
			/* The timeout has expired. */
			prvUnlockQueue( pxQueue );
     cd2:	c8 01       	movw	r24, r16
     cd4:	0e 94 31 05 	call	0xa62	; 0xa62 <prvUnlockQueue>
			( void ) xTaskResumeAll();
     cd8:	0e 94 e0 0a 	call	0x15c0	; 0x15c0 <xTaskResumeAll>

			/* Return to the original privilege level before exiting the
			function. */
			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
     cdc:	80 e0       	ldi	r24, 0x00	; 0
		}
	}
}
     cde:	0f 90       	pop	r0
     ce0:	0f 90       	pop	r0
     ce2:	0f 90       	pop	r0
     ce4:	0f 90       	pop	r0
     ce6:	0f 90       	pop	r0
     ce8:	df 91       	pop	r29
     cea:	cf 91       	pop	r28
     cec:	1f 91       	pop	r17
     cee:	0f 91       	pop	r16
     cf0:	ff 90       	pop	r15
     cf2:	ef 90       	pop	r14
     cf4:	df 90       	pop	r13
     cf6:	cf 90       	pop	r12
     cf8:	bf 90       	pop	r11
     cfa:	9f 90       	pop	r9
     cfc:	8f 90       	pop	r8
     cfe:	08 95       	ret

00000d00 <xQueueGenericSendFromISR>:

#endif /* configUSE_ALTERNATIVE_API */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSendFromISR( xQueueHandle pxQueue, const void * const pvItemToQueue, signed portBASE_TYPE *pxHigherPriorityTaskWoken, portBASE_TYPE xCopyPosition )
{
     d00:	0f 93       	push	r16
     d02:	1f 93       	push	r17
     d04:	cf 93       	push	r28
     d06:	df 93       	push	r29
     d08:	ec 01       	movw	r28, r24
     d0a:	8a 01       	movw	r16, r20
	queue read, instead we return a flag to say whether a context switch is
	required or not (i.e. has a task with a higher priority than us been woken
	by this	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
     d0c:	9a 8d       	ldd	r25, Y+26	; 0x1a
     d0e:	8b 8d       	ldd	r24, Y+27	; 0x1b
     d10:	98 17       	cp	r25, r24
     d12:	c0 f4       	brcc	.+48     	; 0xd44 <xQueueGenericSendFromISR+0x44>
		{
			traceQUEUE_SEND_FROM_ISR( pxQueue );

			prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
     d14:	ce 01       	movw	r24, r28
     d16:	42 2f       	mov	r20, r18
     d18:	0e 94 f0 04 	call	0x9e0	; 0x9e0 <prvCopyDataToQueue>

			/* If the queue is locked we do not alter the event list.  This will
			be done when the queue is unlocked later. */
			if( pxQueue->xTxLock == queueUNLOCKED )
     d1c:	8e 8d       	ldd	r24, Y+30	; 0x1e
     d1e:	8f 3f       	cpi	r24, 0xFF	; 255
     d20:	69 f4       	brne	.+26     	; 0xd3c <xQueueGenericSendFromISR+0x3c>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
     d22:	89 89       	ldd	r24, Y+17	; 0x11
     d24:	88 23       	and	r24, r24
     d26:	81 f0       	breq	.+32     	; 0xd48 <xQueueGenericSendFromISR+0x48>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
     d28:	ce 01       	movw	r24, r28
     d2a:	41 96       	adiw	r24, 0x11	; 17
     d2c:	0e 94 88 0c 	call	0x1910	; 0x1910 <xTaskRemoveFromEventList>
     d30:	88 23       	and	r24, r24
     d32:	61 f0       	breq	.+24     	; 0xd4c <xQueueGenericSendFromISR+0x4c>
					{
						/* The task waiting has a higher priority so record that a
						context	switch is required. */
						*pxHigherPriorityTaskWoken = pdTRUE;
     d34:	81 e0       	ldi	r24, 0x01	; 1
     d36:	f8 01       	movw	r30, r16
     d38:	80 83       	st	Z, r24
     d3a:	09 c0       	rjmp	.+18     	; 0xd4e <xQueueGenericSendFromISR+0x4e>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
     d3c:	8f 5f       	subi	r24, 0xFF	; 255
     d3e:	8e 8f       	std	Y+30, r24	; 0x1e
			}

			xReturn = pdPASS;
     d40:	81 e0       	ldi	r24, 0x01	; 1
     d42:	05 c0       	rjmp	.+10     	; 0xd4e <xQueueGenericSendFromISR+0x4e>
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
     d44:	80 e0       	ldi	r24, 0x00	; 0
     d46:	03 c0       	rjmp	.+6      	; 0xd4e <xQueueGenericSendFromISR+0x4e>
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
			}

			xReturn = pdPASS;
     d48:	81 e0       	ldi	r24, 0x01	; 1
     d4a:	01 c0       	rjmp	.+2      	; 0xd4e <xQueueGenericSendFromISR+0x4e>
     d4c:	81 e0       	ldi	r24, 0x01	; 1
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
     d4e:	df 91       	pop	r29
     d50:	cf 91       	pop	r28
     d52:	1f 91       	pop	r17
     d54:	0f 91       	pop	r16
     d56:	08 95       	ret

00000d58 <xQueueGenericReceive>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericReceive( xQueueHandle pxQueue, void * const pvBuffer, portTickType xTicksToWait, portBASE_TYPE xJustPeeking )
{
     d58:	8f 92       	push	r8
     d5a:	9f 92       	push	r9
     d5c:	bf 92       	push	r11
     d5e:	cf 92       	push	r12
     d60:	df 92       	push	r13
     d62:	ef 92       	push	r14
     d64:	ff 92       	push	r15
     d66:	0f 93       	push	r16
     d68:	1f 93       	push	r17
     d6a:	cf 93       	push	r28
     d6c:	df 93       	push	r29
     d6e:	00 d0       	rcall	.+0      	; 0xd70 <xQueueGenericReceive+0x18>
     d70:	00 d0       	rcall	.+0      	; 0xd72 <xQueueGenericReceive+0x1a>
     d72:	0f 92       	push	r0
     d74:	cd b7       	in	r28, 0x3d	; 61
     d76:	de b7       	in	r29, 0x3e	; 62
     d78:	8c 01       	movw	r16, r24
     d7a:	4b 01       	movw	r8, r22
     d7c:	5d 83       	std	Y+5, r21	; 0x05
     d7e:	4c 83       	std	Y+4, r20	; 0x04
     d80:	b2 2e       	mov	r11, r18
signed portBASE_TYPE xEntryTimeSet = pdFALSE;
     d82:	ff 24       	eor	r15, r15
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
					xEntryTimeSet = pdTRUE;
     d84:	ee 24       	eor	r14, r14
     d86:	e3 94       	inc	r14
						portEXIT_CRITICAL();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
     d88:	0f 2e       	mov	r0, r31
     d8a:	f1 e1       	ldi	r31, 0x11	; 17
     d8c:	cf 2e       	mov	r12, r31
     d8e:	dd 24       	eor	r13, r13
     d90:	f0 2d       	mov	r31, r0
     d92:	c8 0e       	add	r12, r24
     d94:	d9 1e       	adc	r13, r25
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
     d96:	0f b6       	in	r0, 0x3f	; 63
     d98:	f8 94       	cli
     d9a:	0f 92       	push	r0
		{
			/* Is there data in the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
     d9c:	f8 01       	movw	r30, r16
     d9e:	82 8d       	ldd	r24, Z+26	; 0x1a
     da0:	88 23       	and	r24, r24
     da2:	51 f1       	breq	.+84     	; 0xdf8 <xQueueGenericReceive+0xa0>
			{
				/* Remember our read position in case we are just peeking. */
				pcOriginalReadPosition = pxQueue->pcReadFrom;
     da4:	e6 80       	ldd	r14, Z+6	; 0x06
     da6:	f7 80       	ldd	r15, Z+7	; 0x07

				prvCopyDataFromQueue( pxQueue, pvBuffer );
     da8:	c8 01       	movw	r24, r16
     daa:	b4 01       	movw	r22, r8
     dac:	0e 94 c1 04 	call	0x982	; 0x982 <prvCopyDataFromQueue>

				if( xJustPeeking == pdFALSE )
     db0:	bb 20       	and	r11, r11
     db2:	81 f4       	brne	.+32     	; 0xdd4 <xQueueGenericReceive+0x7c>
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* We are actually removing data. */
					--( pxQueue->uxMessagesWaiting );
     db4:	f8 01       	movw	r30, r16
     db6:	82 8d       	ldd	r24, Z+26	; 0x1a
     db8:	81 50       	subi	r24, 0x01	; 1
     dba:	82 8f       	std	Z+26, r24	; 0x1a
							pxQueue->pxMutexHolder = xTaskGetCurrentTaskHandle();
						}
					}
					#endif

					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
     dbc:	80 85       	ldd	r24, Z+8	; 0x08
     dbe:	88 23       	and	r24, r24
     dc0:	b9 f0       	breq	.+46     	; 0xdf0 <xQueueGenericReceive+0x98>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
     dc2:	c8 01       	movw	r24, r16
     dc4:	08 96       	adiw	r24, 0x08	; 8
     dc6:	0e 94 88 0c 	call	0x1910	; 0x1910 <xTaskRemoveFromEventList>
     dca:	81 30       	cpi	r24, 0x01	; 1
     dcc:	89 f4       	brne	.+34     	; 0xdf0 <xQueueGenericReceive+0x98>
						{
							portYIELD_WITHIN_API();
     dce:	0e 94 0a 04 	call	0x814	; 0x814 <vPortYield>
     dd2:	0e c0       	rjmp	.+28     	; 0xdf0 <xQueueGenericReceive+0x98>
				{
					traceQUEUE_PEEK( pxQueue );

					/* We are not removing the data, so reset our read
					pointer. */
					pxQueue->pcReadFrom = pcOriginalReadPosition;
     dd4:	f8 01       	movw	r30, r16
     dd6:	f7 82       	std	Z+7, r15	; 0x07
     dd8:	e6 82       	std	Z+6, r14	; 0x06

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
     dda:	81 89       	ldd	r24, Z+17	; 0x11
     ddc:	88 23       	and	r24, r24
     dde:	41 f0       	breq	.+16     	; 0xdf0 <xQueueGenericReceive+0x98>
					{
						/* Tasks that are removed from the event list will get added to
						the pending ready list as the scheduler is still suspended. */
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
     de0:	c8 01       	movw	r24, r16
     de2:	41 96       	adiw	r24, 0x11	; 17
     de4:	0e 94 88 0c 	call	0x1910	; 0x1910 <xTaskRemoveFromEventList>
     de8:	88 23       	and	r24, r24
     dea:	11 f0       	breq	.+4      	; 0xdf0 <xQueueGenericReceive+0x98>
						{
							/* The task waiting has a higher priority than this task. */
							portYIELD_WITHIN_API();
     dec:	0e 94 0a 04 	call	0x814	; 0x814 <vPortYield>
						}
					}

				}

				taskEXIT_CRITICAL();
     df0:	0f 90       	pop	r0
     df2:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
     df4:	81 e0       	ldi	r24, 0x01	; 1
     df6:	50 c0       	rjmp	.+160    	; 0xe98 <xQueueGenericReceive+0x140>
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
     df8:	8c 81       	ldd	r24, Y+4	; 0x04
     dfa:	9d 81       	ldd	r25, Y+5	; 0x05
     dfc:	00 97       	sbiw	r24, 0x00	; 0
     dfe:	21 f4       	brne	.+8      	; 0xe08 <xQueueGenericReceive+0xb0>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
     e00:	0f 90       	pop	r0
     e02:	0f be       	out	0x3f, r0	; 63
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
     e04:	80 e0       	ldi	r24, 0x00	; 0
     e06:	48 c0       	rjmp	.+144    	; 0xe98 <xQueueGenericReceive+0x140>
				}
				else if( xEntryTimeSet == pdFALSE )
     e08:	ff 20       	and	r15, r15
     e0a:	29 f4       	brne	.+10     	; 0xe16 <xQueueGenericReceive+0xbe>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
     e0c:	ce 01       	movw	r24, r28
     e0e:	01 96       	adiw	r24, 0x01	; 1
     e10:	0e 94 d0 0c 	call	0x19a0	; 0x19a0 <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
     e14:	fe 2c       	mov	r15, r14
				}
			}
		}
		taskEXIT_CRITICAL();
     e16:	0f 90       	pop	r0
     e18:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
     e1a:	0e 94 02 0a 	call	0x1404	; 0x1404 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
     e1e:	0f b6       	in	r0, 0x3f	; 63
     e20:	f8 94       	cli
     e22:	0f 92       	push	r0
     e24:	f8 01       	movw	r30, r16
     e26:	85 8d       	ldd	r24, Z+29	; 0x1d
     e28:	8f 3f       	cpi	r24, 0xFF	; 255
     e2a:	09 f4       	brne	.+2      	; 0xe2e <xQueueGenericReceive+0xd6>
     e2c:	15 8e       	std	Z+29, r1	; 0x1d
     e2e:	f8 01       	movw	r30, r16
     e30:	86 8d       	ldd	r24, Z+30	; 0x1e
     e32:	8f 3f       	cpi	r24, 0xFF	; 255
     e34:	09 f4       	brne	.+2      	; 0xe38 <xQueueGenericReceive+0xe0>
     e36:	16 8e       	std	Z+30, r1	; 0x1e
     e38:	0f 90       	pop	r0
     e3a:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
     e3c:	ce 01       	movw	r24, r28
     e3e:	01 96       	adiw	r24, 0x01	; 1
     e40:	be 01       	movw	r22, r28
     e42:	6c 5f       	subi	r22, 0xFC	; 252
     e44:	7f 4f       	sbci	r23, 0xFF	; 255
     e46:	0e 94 db 0c 	call	0x19b6	; 0x19b6 <xTaskCheckForTimeOut>
     e4a:	88 23       	and	r24, r24
     e4c:	f9 f4       	brne	.+62     	; 0xe8c <xQueueGenericReceive+0x134>

static signed portBASE_TYPE prvIsQueueEmpty( const xQueueHandle pxQueue )
{
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
     e4e:	0f b6       	in	r0, 0x3f	; 63
     e50:	f8 94       	cli
     e52:	0f 92       	push	r0
		xReturn = ( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0 );
     e54:	f8 01       	movw	r30, r16
     e56:	82 8d       	ldd	r24, Z+26	; 0x1a
	taskEXIT_CRITICAL();
     e58:	0f 90       	pop	r0
     e5a:	0f be       	out	0x3f, r0	; 63
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
     e5c:	88 23       	and	r24, r24
     e5e:	81 f4       	brne	.+32     	; 0xe80 <xQueueGenericReceive+0x128>
						portEXIT_CRITICAL();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
     e60:	6c 81       	ldd	r22, Y+4	; 0x04
     e62:	7d 81       	ldd	r23, Y+5	; 0x05
     e64:	c6 01       	movw	r24, r12
     e66:	0e 94 6b 0c 	call	0x18d6	; 0x18d6 <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
     e6a:	c8 01       	movw	r24, r16
     e6c:	0e 94 31 05 	call	0xa62	; 0xa62 <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
     e70:	0e 94 e0 0a 	call	0x15c0	; 0x15c0 <xTaskResumeAll>
     e74:	88 23       	and	r24, r24
     e76:	09 f0       	breq	.+2      	; 0xe7a <xQueueGenericReceive+0x122>
     e78:	8e cf       	rjmp	.-228    	; 0xd96 <xQueueGenericReceive+0x3e>
				{
					portYIELD_WITHIN_API();
     e7a:	0e 94 0a 04 	call	0x814	; 0x814 <vPortYield>
     e7e:	8b cf       	rjmp	.-234    	; 0xd96 <xQueueGenericReceive+0x3e>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
     e80:	c8 01       	movw	r24, r16
     e82:	0e 94 31 05 	call	0xa62	; 0xa62 <prvUnlockQueue>
				( void ) xTaskResumeAll();
     e86:	0e 94 e0 0a 	call	0x15c0	; 0x15c0 <xTaskResumeAll>
     e8a:	85 cf       	rjmp	.-246    	; 0xd96 <xQueueGenericReceive+0x3e>
			}
		}
		else
		{
			prvUnlockQueue( pxQueue );
     e8c:	c8 01       	movw	r24, r16
     e8e:	0e 94 31 05 	call	0xa62	; 0xa62 <prvUnlockQueue>
			( void ) xTaskResumeAll();
     e92:	0e 94 e0 0a 	call	0x15c0	; 0x15c0 <xTaskResumeAll>
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
     e96:	80 e0       	ldi	r24, 0x00	; 0
		}
	}
}
     e98:	0f 90       	pop	r0
     e9a:	0f 90       	pop	r0
     e9c:	0f 90       	pop	r0
     e9e:	0f 90       	pop	r0
     ea0:	0f 90       	pop	r0
     ea2:	df 91       	pop	r29
     ea4:	cf 91       	pop	r28
     ea6:	1f 91       	pop	r17
     ea8:	0f 91       	pop	r16
     eaa:	ff 90       	pop	r15
     eac:	ef 90       	pop	r14
     eae:	df 90       	pop	r13
     eb0:	cf 90       	pop	r12
     eb2:	bf 90       	pop	r11
     eb4:	9f 90       	pop	r9
     eb6:	8f 90       	pop	r8
     eb8:	08 95       	ret

00000eba <xQueueReceiveFromISR>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueReceiveFromISR( xQueueHandle pxQueue, void * const pvBuffer, signed portBASE_TYPE *pxTaskWoken )
{
     eba:	0f 93       	push	r16
     ebc:	1f 93       	push	r17
     ebe:	cf 93       	push	r28
     ec0:	df 93       	push	r29
     ec2:	ec 01       	movw	r28, r24
     ec4:	8a 01       	movw	r16, r20
	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( unsigned portBASE_TYPE ) 0U ) ) );

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		/* We cannot block from an ISR, so check there is data available. */
		if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
     ec6:	8a 8d       	ldd	r24, Y+26	; 0x1a
     ec8:	88 23       	and	r24, r24
     eca:	d1 f0       	breq	.+52     	; 0xf00 <xQueueReceiveFromISR+0x46>
		{
			traceQUEUE_RECEIVE_FROM_ISR( pxQueue );

			prvCopyDataFromQueue( pxQueue, pvBuffer );
     ecc:	ce 01       	movw	r24, r28
     ece:	0e 94 c1 04 	call	0x982	; 0x982 <prvCopyDataFromQueue>
			--( pxQueue->uxMessagesWaiting );
     ed2:	8a 8d       	ldd	r24, Y+26	; 0x1a
     ed4:	81 50       	subi	r24, 0x01	; 1
     ed6:	8a 8f       	std	Y+26, r24	; 0x1a

			/* If the queue is locked we will not modify the event list.  Instead
			we update the lock count so the task that unlocks the queue will know
			that an ISR has removed data while the queue was locked. */
			if( pxQueue->xRxLock == queueUNLOCKED )
     ed8:	8d 8d       	ldd	r24, Y+29	; 0x1d
     eda:	8f 3f       	cpi	r24, 0xFF	; 255
     edc:	69 f4       	brne	.+26     	; 0xef8 <xQueueReceiveFromISR+0x3e>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
     ede:	88 85       	ldd	r24, Y+8	; 0x08
     ee0:	88 23       	and	r24, r24
     ee2:	81 f0       	breq	.+32     	; 0xf04 <xQueueReceiveFromISR+0x4a>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
     ee4:	ce 01       	movw	r24, r28
     ee6:	08 96       	adiw	r24, 0x08	; 8
     ee8:	0e 94 88 0c 	call	0x1910	; 0x1910 <xTaskRemoveFromEventList>
     eec:	88 23       	and	r24, r24
     eee:	61 f0       	breq	.+24     	; 0xf08 <xQueueReceiveFromISR+0x4e>
					{
						/* The task waiting has a higher priority than us so
						force a context switch. */
						*pxTaskWoken = pdTRUE;
     ef0:	81 e0       	ldi	r24, 0x01	; 1
     ef2:	f8 01       	movw	r30, r16
     ef4:	80 83       	st	Z, r24
     ef6:	09 c0       	rjmp	.+18     	; 0xf0a <xQueueReceiveFromISR+0x50>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was removed while it was locked. */
				++( pxQueue->xRxLock );
     ef8:	8f 5f       	subi	r24, 0xFF	; 255
     efa:	8d 8f       	std	Y+29, r24	; 0x1d
			}

			xReturn = pdPASS;
     efc:	81 e0       	ldi	r24, 0x01	; 1
     efe:	05 c0       	rjmp	.+10     	; 0xf0a <xQueueReceiveFromISR+0x50>
		}
		else
		{
			xReturn = pdFAIL;
     f00:	80 e0       	ldi	r24, 0x00	; 0
     f02:	03 c0       	rjmp	.+6      	; 0xf0a <xQueueReceiveFromISR+0x50>
				/* Increment the lock count so the task that unlocks the queue
				knows that data was removed while it was locked. */
				++( pxQueue->xRxLock );
			}

			xReturn = pdPASS;
     f04:	81 e0       	ldi	r24, 0x01	; 1
     f06:	01 c0       	rjmp	.+2      	; 0xf0a <xQueueReceiveFromISR+0x50>
     f08:	81 e0       	ldi	r24, 0x01	; 1
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
     f0a:	df 91       	pop	r29
     f0c:	cf 91       	pop	r28
     f0e:	1f 91       	pop	r17
     f10:	0f 91       	pop	r16
     f12:	08 95       	ret

00000f14 <uxQueueMessagesWaiting>:
{
unsigned portBASE_TYPE uxReturn;

	configASSERT( pxQueue );

	taskENTER_CRITICAL();
     f14:	0f b6       	in	r0, 0x3f	; 63
     f16:	f8 94       	cli
     f18:	0f 92       	push	r0
		uxReturn = pxQueue->uxMessagesWaiting;
     f1a:	fc 01       	movw	r30, r24
     f1c:	82 8d       	ldd	r24, Z+26	; 0x1a
	taskEXIT_CRITICAL();
     f1e:	0f 90       	pop	r0
     f20:	0f be       	out	0x3f, r0	; 63

	return uxReturn;
}
     f22:	08 95       	ret

00000f24 <uxQueueMessagesWaitingFromISR>:
{
unsigned portBASE_TYPE uxReturn;

	configASSERT( pxQueue );

	uxReturn = pxQueue->uxMessagesWaiting;
     f24:	fc 01       	movw	r30, r24
     f26:	82 8d       	ldd	r24, Z+26	; 0x1a

	return uxReturn;
}
     f28:	08 95       	ret

00000f2a <vQueueDelete>:
/*-----------------------------------------------------------*/

void vQueueDelete( xQueueHandle pxQueue )
{
     f2a:	cf 93       	push	r28
     f2c:	df 93       	push	r29
     f2e:	ec 01       	movw	r28, r24
	configASSERT( pxQueue );

	traceQUEUE_DELETE( pxQueue );
	vQueueUnregisterQueue( pxQueue );
	vPortFree( pxQueue->pcHead );
     f30:	88 81       	ld	r24, Y
     f32:	99 81       	ldd	r25, Y+1	; 0x01
     f34:	0e 94 97 02 	call	0x52e	; 0x52e <vPortFree>
	vPortFree( pxQueue );
     f38:	ce 01       	movw	r24, r28
     f3a:	0e 94 97 02 	call	0x52e	; 0x52e <vPortFree>
}
     f3e:	df 91       	pop	r29
     f40:	cf 91       	pop	r28
     f42:	08 95       	ret

00000f44 <xQueueIsQueueEmptyFromISR>:
signed portBASE_TYPE xQueueIsQueueEmptyFromISR( const xQueueHandle pxQueue )
{
signed portBASE_TYPE xReturn;

	configASSERT( pxQueue );
	xReturn = ( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0 );
     f44:	fc 01       	movw	r30, r24
     f46:	92 8d       	ldd	r25, Z+26	; 0x1a
     f48:	81 e0       	ldi	r24, 0x01	; 1
     f4a:	91 11       	cpse	r25, r1
     f4c:	80 e0       	ldi	r24, 0x00	; 0

	return xReturn;
}
     f4e:	08 95       	ret

00000f50 <xQueueIsQueueFullFromISR>:
	return xReturn;
}
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueIsQueueFullFromISR( const xQueueHandle pxQueue )
{
     f50:	fc 01       	movw	r30, r24
signed portBASE_TYPE xReturn;

	configASSERT( pxQueue );
	xReturn = ( pxQueue->uxMessagesWaiting == pxQueue->uxLength );
     f52:	22 8d       	ldd	r18, Z+26	; 0x1a
     f54:	81 e0       	ldi	r24, 0x01	; 1
     f56:	93 8d       	ldd	r25, Z+27	; 0x1b
     f58:	29 13       	cpse	r18, r25
     f5a:	80 e0       	ldi	r24, 0x00	; 0

	return xReturn;
}
     f5c:	08 95       	ret

00000f5e <UART_2_sevenSegmant>:
	sei();  // enable global interrupt
}

//=================[Tasks]=================
void UART_2_sevenSegmant (void *pvParameters)
{
     f5e:	cf 93       	push	r28
     f60:	df 93       	push	r29
     f62:	0f 92       	push	r0
     f64:	cd b7       	in	r28, 0x3d	; 61
     f66:	de b7       	in	r29, 0x3e	; 62
	DDRA = 0xff;
     f68:	8f ef       	ldi	r24, 0xFF	; 255
     f6a:	8a bb       	out	0x1a, r24	; 26
			{
				PORTA = seven_segment_values[rec_data-48]; //ASCII OF '0' = 48
			}
			else // if not a number
			{
				PORTA = NOT_NUM;
     f6c:	ff 24       	eor	r15, r15
     f6e:	f3 94       	inc	r15
		 if(ret == pdTRUE) // if successfully received a message (not time out)
		 {
			  // Print received byte (no from 0 to 9) in seven segment if the received byte is a number
		    if((rec_data >= '0') && (rec_data<= '9'))
			{
				PORTA = seven_segment_values[rec_data-48]; //ASCII OF '0' = 48
     f70:	00 e6       	ldi	r16, 0x60	; 96
     f72:	10 e0       	ldi	r17, 0x00	; 0
	
	
	 while(1)
	 {
		 //Task will be blocked until a new message is received or timeout.
		 ret = xQueueReceive(myQueue, &rec_data, portMAX_DELAY);
     f74:	80 91 06 03 	lds	r24, 0x0306
     f78:	90 91 07 03 	lds	r25, 0x0307
     f7c:	be 01       	movw	r22, r28
     f7e:	6f 5f       	subi	r22, 0xFF	; 255
     f80:	7f 4f       	sbci	r23, 0xFF	; 255
     f82:	4f ef       	ldi	r20, 0xFF	; 255
     f84:	5f ef       	ldi	r21, 0xFF	; 255
     f86:	20 e0       	ldi	r18, 0x00	; 0
     f88:	0e 94 ac 06 	call	0xd58	; 0xd58 <xQueueGenericReceive>
		 
		 if(ret == pdTRUE) // if successfully received a message (not time out)
     f8c:	81 30       	cpi	r24, 0x01	; 1
     f8e:	91 f7       	brne	.-28     	; 0xf74 <UART_2_sevenSegmant+0x16>
		 {
			  // Print received byte (no from 0 to 9) in seven segment if the received byte is a number
		    if((rec_data >= '0') && (rec_data<= '9'))
     f90:	89 81       	ldd	r24, Y+1	; 0x01
     f92:	98 2f       	mov	r25, r24
     f94:	90 53       	subi	r25, 0x30	; 48
     f96:	9a 30       	cpi	r25, 0x0A	; 10
     f98:	38 f4       	brcc	.+14     	; 0xfa8 <UART_2_sevenSegmant+0x4a>
			{
				PORTA = seven_segment_values[rec_data-48]; //ASCII OF '0' = 48
     f9a:	f8 01       	movw	r30, r16
     f9c:	e8 0f       	add	r30, r24
     f9e:	f1 1d       	adc	r31, r1
     fa0:	f0 97       	sbiw	r30, 0x30	; 48
     fa2:	80 81       	ld	r24, Z
     fa4:	8b bb       	out	0x1b, r24	; 27
     fa6:	e6 cf       	rjmp	.-52     	; 0xf74 <UART_2_sevenSegmant+0x16>
			}
			else // if not a number
			{
				PORTA = NOT_NUM;
     fa8:	fb ba       	out	0x1b, r15	; 27
     faa:	e4 cf       	rjmp	.-56     	; 0xf74 <UART_2_sevenSegmant+0x16>

00000fac <__vector_13>:
static xQueueHandle myQueue;
unsigned char my_data;
	
//================= [ISRs]=================
ISR(USART_RXC_vect)
{	
     fac:	1f 92       	push	r1
     fae:	0f 92       	push	r0
     fb0:	0f b6       	in	r0, 0x3f	; 63
     fb2:	0f 92       	push	r0
     fb4:	11 24       	eor	r1, r1
     fb6:	2f 93       	push	r18
     fb8:	3f 93       	push	r19
     fba:	4f 93       	push	r20
     fbc:	5f 93       	push	r21
     fbe:	6f 93       	push	r22
     fc0:	7f 93       	push	r23
     fc2:	8f 93       	push	r24
     fc4:	9f 93       	push	r25
     fc6:	af 93       	push	r26
     fc8:	bf 93       	push	r27
     fca:	ef 93       	push	r30
     fcc:	ff 93       	push	r31
	//save received data
	my_data = UDR; 
     fce:	8c b1       	in	r24, 0x0c	; 12
     fd0:	80 93 59 03 	sts	0x0359, r24
	
	//send data as a message to the queue
	xQueueSendFromISR(myQueue,&my_data,pdTRUE );
     fd4:	80 91 06 03 	lds	r24, 0x0306
     fd8:	90 91 07 03 	lds	r25, 0x0307
     fdc:	69 e5       	ldi	r22, 0x59	; 89
     fde:	73 e0       	ldi	r23, 0x03	; 3
     fe0:	41 e0       	ldi	r20, 0x01	; 1
     fe2:	50 e0       	ldi	r21, 0x00	; 0
     fe4:	20 e0       	ldi	r18, 0x00	; 0
     fe6:	0e 94 80 06 	call	0xd00	; 0xd00 <xQueueGenericSendFromISR>
		
}
     fea:	ff 91       	pop	r31
     fec:	ef 91       	pop	r30
     fee:	bf 91       	pop	r27
     ff0:	af 91       	pop	r26
     ff2:	9f 91       	pop	r25
     ff4:	8f 91       	pop	r24
     ff6:	7f 91       	pop	r23
     ff8:	6f 91       	pop	r22
     ffa:	5f 91       	pop	r21
     ffc:	4f 91       	pop	r20
     ffe:	3f 91       	pop	r19
    1000:	2f 91       	pop	r18
    1002:	0f 90       	pop	r0
    1004:	0f be       	out	0x3f, r0	; 63
    1006:	0f 90       	pop	r0
    1008:	1f 90       	pop	r1
    100a:	18 95       	reti

0000100c <UART_init>:

//================ [Functions]=============
void UART_init()
{
	// Note : Clk = 8 MHz
	UCSRA = 0b00000000;
    100c:	1b b8       	out	0x0b, r1	; 11
	UCSRB = 0b10010000;    // Rec only with interrupt
    100e:	80 e9       	ldi	r24, 0x90	; 144
    1010:	8a b9       	out	0x0a, r24	; 10
	UCSRC = 0b10000110;       // asynchronous mode , No parity , one stop bit , 8 bits
    1012:	86 e8       	ldi	r24, 0x86	; 134
    1014:	80 bd       	out	0x20, r24	; 32
	UBRRH = 0b00000000;
    1016:	10 bc       	out	0x20, r1	; 32
	UBRRL = 51; // baud rate = 9600 bps @ 8MHz
    1018:	83 e3       	ldi	r24, 0x33	; 51
    101a:	89 b9       	out	0x09, r24	; 9
	sei();  // enable global interrupt
    101c:	78 94       	sei
}
    101e:	08 95       	ret

00001020 <main>:
	
}
//================ [Main]==================

int main(void)
{
    1020:	af 92       	push	r10
    1022:	bf 92       	push	r11
    1024:	cf 92       	push	r12
    1026:	df 92       	push	r13
    1028:	ef 92       	push	r14
    102a:	ff 92       	push	r15
    102c:	0f 93       	push	r16
	// UART initialization
  UART_init();
    102e:	0e 94 06 08 	call	0x100c	; 0x100c <UART_init>
  
    // Create task
   xTaskCreate( UART_2_sevenSegmant,NULL, configMINIMAL_STACK_SIZE, NULL, 1, NULL );
    1032:	8f ea       	ldi	r24, 0xAF	; 175
    1034:	97 e0       	ldi	r25, 0x07	; 7
    1036:	60 e0       	ldi	r22, 0x00	; 0
    1038:	70 e0       	ldi	r23, 0x00	; 0
    103a:	45 e5       	ldi	r20, 0x55	; 85
    103c:	50 e0       	ldi	r21, 0x00	; 0
    103e:	20 e0       	ldi	r18, 0x00	; 0
    1040:	30 e0       	ldi	r19, 0x00	; 0
    1042:	01 e0       	ldi	r16, 0x01	; 1
    1044:	ee 24       	eor	r14, r14
    1046:	ff 24       	eor	r15, r15
    1048:	cc 24       	eor	r12, r12
    104a:	dd 24       	eor	r13, r13
    104c:	aa 24       	eor	r10, r10
    104e:	bb 24       	eor	r11, r11
    1050:	0e 94 75 08 	call	0x10ea	; 0x10ea <xTaskGenericCreate>
   
   //Create Queue with size 1
   myQueue = xQueueCreate(1, sizeof(char *));
    1054:	81 e0       	ldi	r24, 0x01	; 1
    1056:	62 e0       	ldi	r22, 0x02	; 2
    1058:	0e 94 7d 05 	call	0xafa	; 0xafa <xQueueCreate>
    105c:	90 93 07 03 	sts	0x0307, r25
    1060:	80 93 06 03 	sts	0x0306, r24
   
   //Start FreeRTOS
   vTaskStartScheduler();
    1064:	0e 94 d1 09 	call	0x13a2	; 0x13a2 <vTaskStartScheduler>
  
    1068:	80 e0       	ldi	r24, 0x00	; 0
    106a:	90 e0       	ldi	r25, 0x00	; 0
    106c:	0f 91       	pop	r16
    106e:	ff 90       	pop	r15
    1070:	ef 90       	pop	r14
    1072:	df 90       	pop	r13
    1074:	cf 90       	pop	r12
    1076:	bf 90       	pop	r11
    1078:	af 90       	pop	r10
    107a:	08 95       	ret

0000107c <prvAddCurrentTaskToDelayedList>:
	#endif
}
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( portTickType xTimeToWake )
{
    107c:	cf 93       	push	r28
    107e:	df 93       	push	r29
    1080:	ec 01       	movw	r28, r24
	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
    1082:	e0 91 08 03 	lds	r30, 0x0308
    1086:	f0 91 09 03 	lds	r31, 0x0309
    108a:	93 83       	std	Z+3, r25	; 0x03
    108c:	82 83       	std	Z+2, r24	; 0x02

	if( xTimeToWake < xTickCount )
    108e:	80 91 10 03 	lds	r24, 0x0310
    1092:	90 91 11 03 	lds	r25, 0x0311
    1096:	c8 17       	cp	r28, r24
    1098:	d9 07       	cpc	r29, r25
    109a:	68 f4       	brcc	.+26     	; 0x10b6 <prvAddCurrentTaskToDelayedList+0x3a>
	{
		/* Wake time has overflowed.  Place this item in the overflow list. */
		vListInsert( ( xList * ) pxOverflowDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    109c:	80 91 14 03 	lds	r24, 0x0314
    10a0:	90 91 15 03 	lds	r25, 0x0315
    10a4:	60 91 08 03 	lds	r22, 0x0308
    10a8:	70 91 09 03 	lds	r23, 0x0309
    10ac:	6e 5f       	subi	r22, 0xFE	; 254
    10ae:	7f 4f       	sbci	r23, 0xFF	; 255
    10b0:	0e 94 e1 02 	call	0x5c2	; 0x5c2 <vListInsert>
    10b4:	17 c0       	rjmp	.+46     	; 0x10e4 <prvAddCurrentTaskToDelayedList+0x68>
	}
	else
	{
		/* The wake time has not overflowed, so we can use the current block list. */
		vListInsert( ( xList * ) pxDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    10b6:	80 91 16 03 	lds	r24, 0x0316
    10ba:	90 91 17 03 	lds	r25, 0x0317
    10be:	60 91 08 03 	lds	r22, 0x0308
    10c2:	70 91 09 03 	lds	r23, 0x0309
    10c6:	6e 5f       	subi	r22, 0xFE	; 254
    10c8:	7f 4f       	sbci	r23, 0xFF	; 255
    10ca:	0e 94 e1 02 	call	0x5c2	; 0x5c2 <vListInsert>

		/* If the task entering the blocked state was placed at the head of the
		list of blocked tasks then xNextTaskUnblockTime needs to be updated
		too. */
		if( xTimeToWake < xNextTaskUnblockTime )
    10ce:	80 91 6f 00 	lds	r24, 0x006F
    10d2:	90 91 70 00 	lds	r25, 0x0070
    10d6:	c8 17       	cp	r28, r24
    10d8:	d9 07       	cpc	r29, r25
    10da:	20 f4       	brcc	.+8      	; 0x10e4 <prvAddCurrentTaskToDelayedList+0x68>
		{
			xNextTaskUnblockTime = xTimeToWake;
    10dc:	d0 93 70 00 	sts	0x0070, r29
    10e0:	c0 93 6f 00 	sts	0x006F, r28
		}
	}
}
    10e4:	df 91       	pop	r29
    10e6:	cf 91       	pop	r28
    10e8:	08 95       	ret

000010ea <xTaskGenericCreate>:
/*-----------------------------------------------------------
 * TASK CREATION API documented in task.h
 *----------------------------------------------------------*/

signed portBASE_TYPE xTaskGenericCreate( pdTASK_CODE pxTaskCode, const signed char * const pcName, unsigned short usStackDepth, void *pvParameters, unsigned portBASE_TYPE uxPriority, xTaskHandle *pxCreatedTask, portSTACK_TYPE *puxStackBuffer, const xMemoryRegion * const xRegions )
{
    10ea:	4f 92       	push	r4
    10ec:	5f 92       	push	r5
    10ee:	6f 92       	push	r6
    10f0:	7f 92       	push	r7
    10f2:	8f 92       	push	r8
    10f4:	9f 92       	push	r9
    10f6:	bf 92       	push	r11
    10f8:	cf 92       	push	r12
    10fa:	df 92       	push	r13
    10fc:	ef 92       	push	r14
    10fe:	ff 92       	push	r15
    1100:	0f 93       	push	r16
    1102:	1f 93       	push	r17
    1104:	cf 93       	push	r28
    1106:	df 93       	push	r29
    1108:	2c 01       	movw	r4, r24
    110a:	4b 01       	movw	r8, r22
    110c:	ea 01       	movw	r28, r20
    110e:	39 01       	movw	r6, r18
    1110:	b0 2e       	mov	r11, r16
{
tskTCB *pxNewTCB;

	/* Allocate space for the TCB.  Where the memory comes from depends on
	the implementation of the port malloc function. */
	pxNewTCB = ( tskTCB * ) pvPortMalloc( sizeof( tskTCB ) );
    1112:	81 e2       	ldi	r24, 0x21	; 33
    1114:	90 e0       	ldi	r25, 0x00	; 0
    1116:	0e 94 6e 02 	call	0x4dc	; 0x4dc <pvPortMalloc>
    111a:	8c 01       	movw	r16, r24

	if( pxNewTCB != NULL )
    111c:	00 97       	sbiw	r24, 0x00	; 0
    111e:	09 f4       	brne	.+2      	; 0x1122 <xTaskGenericCreate+0x38>
    1120:	db c0       	rjmp	.+438    	; 0x12d8 <xTaskGenericCreate+0x1ee>
	{
		/* Allocate space for the stack used by the task being created.
		The base of the stack memory stored in the TCB so the task can
		be deleted later if required. */
		pxNewTCB->pxStack = ( portSTACK_TYPE * ) pvPortMallocAligned( ( ( ( size_t )usStackDepth ) * sizeof( portSTACK_TYPE ) ), puxStackBuffer );
    1122:	c1 14       	cp	r12, r1
    1124:	d1 04       	cpc	r13, r1
    1126:	09 f0       	breq	.+2      	; 0x112a <xTaskGenericCreate+0x40>
    1128:	ec c0       	rjmp	.+472    	; 0x1302 <xTaskGenericCreate+0x218>
    112a:	ce 01       	movw	r24, r28
    112c:	0e 94 6e 02 	call	0x4dc	; 0x4dc <pvPortMalloc>
    1130:	6c 01       	movw	r12, r24
    1132:	f8 01       	movw	r30, r16
    1134:	90 8f       	std	Z+24, r25	; 0x18
    1136:	87 8b       	std	Z+23, r24	; 0x17

		if( pxNewTCB->pxStack == NULL )
    1138:	00 97       	sbiw	r24, 0x00	; 0
    113a:	29 f4       	brne	.+10     	; 0x1146 <xTaskGenericCreate+0x5c>
		{
			/* Could not allocate the stack.  Delete the allocated TCB. */
			vPortFree( pxNewTCB );
    113c:	c8 01       	movw	r24, r16
    113e:	0e 94 97 02 	call	0x52e	; 0x52e <vPortFree>
		}
		taskEXIT_CRITICAL();
	}
	else
	{
		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
    1142:	8f ef       	ldi	r24, 0xFF	; 255
    1144:	ce c0       	rjmp	.+412    	; 0x12e2 <xTaskGenericCreate+0x1f8>
			pxNewTCB = NULL;
		}
		else
		{
			/* Just to help debugging. */
			memset( pxNewTCB->pxStack, ( int ) tskSTACK_FILL_BYTE, ( size_t ) usStackDepth * sizeof( portSTACK_TYPE ) );
    1146:	c6 01       	movw	r24, r12
    1148:	65 ea       	ldi	r22, 0xA5	; 165
    114a:	70 e0       	ldi	r23, 0x00	; 0
    114c:	ae 01       	movw	r20, r28
    114e:	0e 94 1e 0d 	call	0x1a3c	; 0x1a3c <memset>
		stack grows from high memory to low (as per the 80x86) or visa versa.
		portSTACK_GROWTH is used to make the result positive or negative as
		required by the port. */
		#if( portSTACK_GROWTH < 0 )
		{
			pxTopOfStack = pxNewTCB->pxStack + ( usStackDepth - ( unsigned short ) 1 );
    1152:	9e 01       	movw	r18, r28
    1154:	21 50       	subi	r18, 0x01	; 1
    1156:	30 40       	sbci	r19, 0x00	; 0
    1158:	f8 01       	movw	r30, r16
    115a:	87 89       	ldd	r24, Z+23	; 0x17
    115c:	90 8d       	ldd	r25, Z+24	; 0x18
    115e:	6c 01       	movw	r12, r24
    1160:	c2 0e       	add	r12, r18
    1162:	d3 1e       	adc	r13, r19
{
	/* Store the function name in the TCB. */
	#if configMAX_TASK_NAME_LEN > 1
	{
		/* Don't bring strncpy into the build unnecessarily. */
		strncpy( ( char * ) pxTCB->pcTaskName, ( const char * ) pcName, ( unsigned short ) configMAX_TASK_NAME_LEN );
    1164:	c8 01       	movw	r24, r16
    1166:	49 96       	adiw	r24, 0x19	; 25
    1168:	b4 01       	movw	r22, r8
    116a:	48 e0       	ldi	r20, 0x08	; 8
    116c:	50 e0       	ldi	r21, 0x00	; 0
    116e:	0e 94 25 0d 	call	0x1a4a	; 0x1a4a <strncpy>
	}
	#endif
	pxTCB->pcTaskName[ ( unsigned short ) configMAX_TASK_NAME_LEN - ( unsigned short ) 1 ] = ( signed char ) '\0';
    1172:	f8 01       	movw	r30, r16
    1174:	10 a2       	lds	r17, 0x90
    1176:	cb 2d       	mov	r28, r11
    1178:	f2 e0       	ldi	r31, 0x02	; 2
    117a:	fb 15       	cp	r31, r11
    117c:	08 f4       	brcc	.+2      	; 0x1180 <xTaskGenericCreate+0x96>
    117e:	c2 e0       	ldi	r28, 0x02	; 2
	if( uxPriority >= configMAX_PRIORITIES )
	{
		uxPriority = configMAX_PRIORITIES - ( unsigned portBASE_TYPE ) 1U;
	}

	pxTCB->uxPriority = uxPriority;
    1180:	f8 01       	movw	r30, r16
    1182:	c6 8b       	std	Z+22, r28	; 0x16
	{
		pxTCB->uxBasePriority = uxPriority;
	}
	#endif

	vListInitialiseItem( &( pxTCB->xGenericListItem ) );
    1184:	88 24       	eor	r8, r8
    1186:	99 24       	eor	r9, r9
    1188:	68 94       	set
    118a:	81 f8       	bld	r8, 1
    118c:	80 0e       	add	r8, r16
    118e:	91 1e       	adc	r9, r17
    1190:	c4 01       	movw	r24, r8
    1192:	0e 94 b4 02 	call	0x568	; 0x568 <vListInitialiseItem>
	vListInitialiseItem( &( pxTCB->xEventListItem ) );
    1196:	c8 01       	movw	r24, r16
    1198:	0c 96       	adiw	r24, 0x0c	; 12
    119a:	0e 94 b4 02 	call	0x568	; 0x568 <vListInitialiseItem>

	/* Set the pxTCB as a link back from the xListItem.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxTCB->xGenericListItem ), pxTCB );
    119e:	f8 01       	movw	r30, r16
    11a0:	11 87       	std	Z+9, r17	; 0x09
    11a2:	00 87       	std	Z+8, r16	; 0x08

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) uxPriority );
    11a4:	83 e0       	ldi	r24, 0x03	; 3
    11a6:	90 e0       	ldi	r25, 0x00	; 0
    11a8:	8c 1b       	sub	r24, r28
    11aa:	91 09       	sbc	r25, r1
    11ac:	95 87       	std	Z+13, r25	; 0x0d
    11ae:	84 87       	std	Z+12, r24	; 0x0c
	listSET_LIST_ITEM_OWNER( &( pxTCB->xEventListItem ), pxTCB );
    11b0:	13 8b       	std	Z+19, r17	; 0x13
    11b2:	02 8b       	std	Z+18, r16	; 0x12
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged );
		}
		#else
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
    11b4:	c6 01       	movw	r24, r12
    11b6:	b2 01       	movw	r22, r4
    11b8:	a3 01       	movw	r20, r6
    11ba:	0e 94 44 03 	call	0x688	; 0x688 <pxPortInitialiseStack>
    11be:	f8 01       	movw	r30, r16
    11c0:	91 83       	std	Z+1, r25	; 0x01
    11c2:	80 83       	st	Z, r24
		#endif

		/* Check the alignment of the initialised stack. */
		configASSERT( ( ( ( unsigned long ) pxNewTCB->pxTopOfStack & ( unsigned long ) portBYTE_ALIGNMENT_MASK ) == 0UL ) );

		if( ( void * ) pxCreatedTask != NULL )
    11c4:	e1 14       	cp	r14, r1
    11c6:	f1 04       	cpc	r15, r1
    11c8:	19 f0       	breq	.+6      	; 0x11d0 <xTaskGenericCreate+0xe6>
		{
			/* Pass the TCB out - in an anonymous way.  The calling function/
			task can use this as a handle to delete the task later if
			required.*/
			*pxCreatedTask = ( xTaskHandle ) pxNewTCB;
    11ca:	f7 01       	movw	r30, r14
    11cc:	11 83       	std	Z+1, r17	; 0x01
    11ce:	00 83       	st	Z, r16
		}
		
		/* We are going to manipulate the task queues to add this task to a
		ready list, so must make sure no interrupts occur. */
		taskENTER_CRITICAL();
    11d0:	0f b6       	in	r0, 0x3f	; 63
    11d2:	f8 94       	cli
    11d4:	0f 92       	push	r0
		{
			uxCurrentNumberOfTasks++;
    11d6:	80 91 12 03 	lds	r24, 0x0312
    11da:	8f 5f       	subi	r24, 0xFF	; 255
    11dc:	80 93 12 03 	sts	0x0312, r24
			if( pxCurrentTCB == NULL )
    11e0:	80 91 08 03 	lds	r24, 0x0308
    11e4:	90 91 09 03 	lds	r25, 0x0309
    11e8:	00 97       	sbiw	r24, 0x00	; 0
    11ea:	a1 f5       	brne	.+104    	; 0x1254 <xTaskGenericCreate+0x16a>
			{
				/* There are no other tasks, or all the other tasks are in
				the suspended state - make this the current task. */
				pxCurrentTCB =  pxNewTCB;
    11ec:	10 93 09 03 	sts	0x0309, r17
    11f0:	00 93 08 03 	sts	0x0308, r16

				if( uxCurrentNumberOfTasks == ( unsigned portBASE_TYPE ) 1 )
    11f4:	80 91 12 03 	lds	r24, 0x0312
    11f8:	81 30       	cpi	r24, 0x01	; 1
    11fa:	d9 f5       	brne	.+118    	; 0x1272 <xTaskGenericCreate+0x188>
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
    11fc:	ca e1       	ldi	r28, 0x1A	; 26
    11fe:	d3 e0       	ldi	r29, 0x03	; 3
    1200:	ce 01       	movw	r24, r28
    1202:	0e 94 a6 02 	call	0x54c	; 0x54c <vListInitialise>
    1206:	ce 01       	movw	r24, r28
    1208:	09 96       	adiw	r24, 0x09	; 9
    120a:	0e 94 a6 02 	call	0x54c	; 0x54c <vListInitialise>
    120e:	ce 01       	movw	r24, r28
    1210:	42 96       	adiw	r24, 0x12	; 18
    1212:	0e 94 a6 02 	call	0x54c	; 0x54c <vListInitialise>
	}

	vListInitialise( ( xList * ) &xDelayedTaskList1 );
    1216:	c5 e3       	ldi	r28, 0x35	; 53
    1218:	d3 e0       	ldi	r29, 0x03	; 3
    121a:	ce 01       	movw	r24, r28
    121c:	0e 94 a6 02 	call	0x54c	; 0x54c <vListInitialise>
	vListInitialise( ( xList * ) &xDelayedTaskList2 );
    1220:	0f 2e       	mov	r0, r31
    1222:	fe e3       	ldi	r31, 0x3E	; 62
    1224:	ef 2e       	mov	r14, r31
    1226:	f3 e0       	ldi	r31, 0x03	; 3
    1228:	ff 2e       	mov	r15, r31
    122a:	f0 2d       	mov	r31, r0
    122c:	c7 01       	movw	r24, r14
    122e:	0e 94 a6 02 	call	0x54c	; 0x54c <vListInitialise>
	vListInitialise( ( xList * ) &xPendingReadyList );
    1232:	87 e4       	ldi	r24, 0x47	; 71
    1234:	93 e0       	ldi	r25, 0x03	; 3
    1236:	0e 94 a6 02 	call	0x54c	; 0x54c <vListInitialise>

	#if ( INCLUDE_vTaskDelete == 1 )
	{
		vListInitialise( ( xList * ) &xTasksWaitingTermination );
    123a:	80 e5       	ldi	r24, 0x50	; 80
    123c:	93 e0       	ldi	r25, 0x03	; 3
    123e:	0e 94 a6 02 	call	0x54c	; 0x54c <vListInitialise>
	}
	#endif

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
    1242:	d0 93 17 03 	sts	0x0317, r29
    1246:	c0 93 16 03 	sts	0x0316, r28
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
    124a:	f0 92 15 03 	sts	0x0315, r15
    124e:	e0 92 14 03 	sts	0x0314, r14
    1252:	0f c0       	rjmp	.+30     	; 0x1272 <xTaskGenericCreate+0x188>
			else
			{
				/* If the scheduler is not already running, make this task the
				current task if it is the highest priority task to be created
				so far. */
				if( xSchedulerRunning == pdFALSE )
    1254:	80 91 0e 03 	lds	r24, 0x030E
    1258:	88 23       	and	r24, r24
    125a:	59 f4       	brne	.+22     	; 0x1272 <xTaskGenericCreate+0x188>
				{
					if( pxCurrentTCB->uxPriority <= uxPriority )
    125c:	e0 91 08 03 	lds	r30, 0x0308
    1260:	f0 91 09 03 	lds	r31, 0x0309
    1264:	86 89       	ldd	r24, Z+22	; 0x16
    1266:	b8 16       	cp	r11, r24
    1268:	20 f0       	brcs	.+8      	; 0x1272 <xTaskGenericCreate+0x188>
					{
						pxCurrentTCB = pxNewTCB;
    126a:	10 93 09 03 	sts	0x0309, r17
    126e:	00 93 08 03 	sts	0x0308, r16
				}
			}

			/* Remember the top priority to make context switching faster.  Use
			the priority in pxNewTCB as this has been capped to a valid value. */
			if( pxNewTCB->uxPriority > uxTopUsedPriority )
    1272:	f8 01       	movw	r30, r16
    1274:	86 89       	ldd	r24, Z+22	; 0x16
    1276:	90 91 18 03 	lds	r25, 0x0318
    127a:	98 17       	cp	r25, r24
    127c:	10 f4       	brcc	.+4      	; 0x1282 <xTaskGenericCreate+0x198>
			{
				uxTopUsedPriority = pxNewTCB->uxPriority;
    127e:	80 93 18 03 	sts	0x0318, r24
			{
				/* Add a counter into the TCB for tracing only. */
				pxNewTCB->uxTCBNumber = uxTaskNumber;
			}
			#endif
			uxTaskNumber++;
    1282:	90 91 19 03 	lds	r25, 0x0319
    1286:	9f 5f       	subi	r25, 0xFF	; 255
    1288:	90 93 19 03 	sts	0x0319, r25

			prvAddTaskToReadyQueue( pxNewTCB );
    128c:	90 91 0f 03 	lds	r25, 0x030F
    1290:	98 17       	cp	r25, r24
    1292:	10 f4       	brcc	.+4      	; 0x1298 <xTaskGenericCreate+0x1ae>
    1294:	80 93 0f 03 	sts	0x030F, r24
    1298:	90 e0       	ldi	r25, 0x00	; 0
    129a:	9c 01       	movw	r18, r24
    129c:	22 0f       	add	r18, r18
    129e:	33 1f       	adc	r19, r19
    12a0:	22 0f       	add	r18, r18
    12a2:	33 1f       	adc	r19, r19
    12a4:	22 0f       	add	r18, r18
    12a6:	33 1f       	adc	r19, r19
    12a8:	82 0f       	add	r24, r18
    12aa:	93 1f       	adc	r25, r19
    12ac:	86 5e       	subi	r24, 0xE6	; 230
    12ae:	9c 4f       	sbci	r25, 0xFC	; 252
    12b0:	b4 01       	movw	r22, r8
    12b2:	0e 94 b8 02 	call	0x570	; 0x570 <vListInsertEnd>

			xReturn = pdPASS;
			traceTASK_CREATE( pxNewTCB );
		}
		taskEXIT_CRITICAL();
    12b6:	0f 90       	pop	r0
    12b8:	0f be       	out	0x3f, r0	; 63
		traceTASK_CREATE_FAILED();
	}

	if( xReturn == pdPASS )
	{
		if( xSchedulerRunning != pdFALSE )
    12ba:	80 91 0e 03 	lds	r24, 0x030E
    12be:	88 23       	and	r24, r24
    12c0:	69 f0       	breq	.+26     	; 0x12dc <xTaskGenericCreate+0x1f2>
		{
			/* If the created task is of a higher priority than the current task
			then it should run now. */
			if( pxCurrentTCB->uxPriority < uxPriority )
    12c2:	e0 91 08 03 	lds	r30, 0x0308
    12c6:	f0 91 09 03 	lds	r31, 0x0309
    12ca:	86 89       	ldd	r24, Z+22	; 0x16
    12cc:	8b 15       	cp	r24, r11
    12ce:	40 f4       	brcc	.+16     	; 0x12e0 <xTaskGenericCreate+0x1f6>
			{
				portYIELD_WITHIN_API();
    12d0:	0e 94 0a 04 	call	0x814	; 0x814 <vPortYield>
			#endif
			uxTaskNumber++;

			prvAddTaskToReadyQueue( pxNewTCB );

			xReturn = pdPASS;
    12d4:	81 e0       	ldi	r24, 0x01	; 1
    12d6:	05 c0       	rjmp	.+10     	; 0x12e2 <xTaskGenericCreate+0x1f8>
		}
		taskEXIT_CRITICAL();
	}
	else
	{
		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
    12d8:	8f ef       	ldi	r24, 0xFF	; 255
    12da:	03 c0       	rjmp	.+6      	; 0x12e2 <xTaskGenericCreate+0x1f8>
			#endif
			uxTaskNumber++;

			prvAddTaskToReadyQueue( pxNewTCB );

			xReturn = pdPASS;
    12dc:	81 e0       	ldi	r24, 0x01	; 1
    12de:	01 c0       	rjmp	.+2      	; 0x12e2 <xTaskGenericCreate+0x1f8>
    12e0:	81 e0       	ldi	r24, 0x01	; 1
			}
		}
	}

	return xReturn;
}
    12e2:	df 91       	pop	r29
    12e4:	cf 91       	pop	r28
    12e6:	1f 91       	pop	r17
    12e8:	0f 91       	pop	r16
    12ea:	ff 90       	pop	r15
    12ec:	ef 90       	pop	r14
    12ee:	df 90       	pop	r13
    12f0:	cf 90       	pop	r12
    12f2:	bf 90       	pop	r11
    12f4:	9f 90       	pop	r9
    12f6:	8f 90       	pop	r8
    12f8:	7f 90       	pop	r7
    12fa:	6f 90       	pop	r6
    12fc:	5f 90       	pop	r5
    12fe:	4f 90       	pop	r4
    1300:	08 95       	ret
	if( pxNewTCB != NULL )
	{
		/* Allocate space for the stack used by the task being created.
		The base of the stack memory stored in the TCB so the task can
		be deleted later if required. */
		pxNewTCB->pxStack = ( portSTACK_TYPE * ) pvPortMallocAligned( ( ( ( size_t )usStackDepth ) * sizeof( portSTACK_TYPE ) ), puxStackBuffer );
    1302:	fc 01       	movw	r30, r24
    1304:	d0 8e       	std	Z+24, r13	; 0x18
    1306:	c7 8a       	std	Z+23, r12	; 0x17
    1308:	1e cf       	rjmp	.-452    	; 0x1146 <xTaskGenericCreate+0x5c>

0000130a <vTaskDelete>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

	void vTaskDelete( xTaskHandle pxTaskToDelete )
	{
    130a:	ef 92       	push	r14
    130c:	ff 92       	push	r15
    130e:	0f 93       	push	r16
    1310:	1f 93       	push	r17
    1312:	cf 93       	push	r28
    1314:	df 93       	push	r29
    1316:	7c 01       	movw	r14, r24
	tskTCB *pxTCB;

		taskENTER_CRITICAL();
    1318:	0f b6       	in	r0, 0x3f	; 63
    131a:	f8 94       	cli
    131c:	0f 92       	push	r0
		{
			/* Ensure a yield is performed if the current task is being
			deleted. */
			if( pxTaskToDelete == pxCurrentTCB )
    131e:	80 91 08 03 	lds	r24, 0x0308
    1322:	90 91 09 03 	lds	r25, 0x0309
    1326:	e8 16       	cp	r14, r24
    1328:	f9 06       	cpc	r15, r25
    132a:	21 f0       	breq	.+8      	; 0x1334 <vTaskDelete+0x2a>
			{
				pxTaskToDelete = NULL;
			}

			/* If null is passed in here then we are deleting ourselves. */
			pxTCB = prvGetTCBFromHandle( pxTaskToDelete );
    132c:	e1 14       	cp	r14, r1
    132e:	f1 04       	cpc	r15, r1
    1330:	41 f4       	brne	.+16     	; 0x1342 <vTaskDelete+0x38>
    1332:	02 c0       	rjmp	.+4      	; 0x1338 <vTaskDelete+0x2e>
		{
			/* Ensure a yield is performed if the current task is being
			deleted. */
			if( pxTaskToDelete == pxCurrentTCB )
			{
				pxTaskToDelete = NULL;
    1334:	ee 24       	eor	r14, r14
    1336:	ff 24       	eor	r15, r15
			}

			/* If null is passed in here then we are deleting ourselves. */
			pxTCB = prvGetTCBFromHandle( pxTaskToDelete );
    1338:	c0 91 08 03 	lds	r28, 0x0308
    133c:	d0 91 09 03 	lds	r29, 0x0309
    1340:	01 c0       	rjmp	.+2      	; 0x1344 <vTaskDelete+0x3a>
    1342:	e7 01       	movw	r28, r14

			/* Remove task from the ready list and place in the	termination list.
			This will stop the task from be scheduled.  The idle task will check
			the termination list and free up any memory allocated by the
			scheduler for the TCB and stack. */
			vListRemove( &( pxTCB->xGenericListItem ) );
    1344:	8e 01       	movw	r16, r28
    1346:	0e 5f       	subi	r16, 0xFE	; 254
    1348:	1f 4f       	sbci	r17, 0xFF	; 255
    134a:	c8 01       	movw	r24, r16
    134c:	0e 94 1e 03 	call	0x63c	; 0x63c <vListRemove>

			/* Is the task waiting on an event also? */
			if( pxTCB->xEventListItem.pvContainer != NULL )
    1350:	8c 89       	ldd	r24, Y+20	; 0x14
    1352:	9d 89       	ldd	r25, Y+21	; 0x15
    1354:	00 97       	sbiw	r24, 0x00	; 0
    1356:	21 f0       	breq	.+8      	; 0x1360 <vTaskDelete+0x56>
			{
				vListRemove( &( pxTCB->xEventListItem ) );
    1358:	ce 01       	movw	r24, r28
    135a:	0c 96       	adiw	r24, 0x0c	; 12
    135c:	0e 94 1e 03 	call	0x63c	; 0x63c <vListRemove>
			}

			vListInsertEnd( ( xList * ) &xTasksWaitingTermination, &( pxTCB->xGenericListItem ) );
    1360:	80 e5       	ldi	r24, 0x50	; 80
    1362:	93 e0       	ldi	r25, 0x03	; 3
    1364:	b8 01       	movw	r22, r16
    1366:	0e 94 b8 02 	call	0x570	; 0x570 <vListInsertEnd>

			/* Increment the ucTasksDeleted variable so the idle task knows
			there is a task that has been deleted and that it should therefore
			check the xTasksWaitingTermination list. */
			++uxTasksDeleted;
    136a:	80 91 13 03 	lds	r24, 0x0313
    136e:	8f 5f       	subi	r24, 0xFF	; 255
    1370:	80 93 13 03 	sts	0x0313, r24

			/* Increment the uxTaskNumberVariable also so kernel aware debuggers
			can detect that the task lists need re-generating. */
			uxTaskNumber++;
    1374:	80 91 19 03 	lds	r24, 0x0319
    1378:	8f 5f       	subi	r24, 0xFF	; 255
    137a:	80 93 19 03 	sts	0x0319, r24

			traceTASK_DELETE( pxTCB );
		}
		taskEXIT_CRITICAL();
    137e:	0f 90       	pop	r0
    1380:	0f be       	out	0x3f, r0	; 63

		/* Force a reschedule if we have just deleted the current task. */
		if( xSchedulerRunning != pdFALSE )
    1382:	80 91 0e 03 	lds	r24, 0x030E
    1386:	88 23       	and	r24, r24
    1388:	29 f0       	breq	.+10     	; 0x1394 <vTaskDelete+0x8a>
		{
			if( ( void * ) pxTaskToDelete == NULL )
    138a:	e1 14       	cp	r14, r1
    138c:	f1 04       	cpc	r15, r1
    138e:	11 f4       	brne	.+4      	; 0x1394 <vTaskDelete+0x8a>
			{
				portYIELD_WITHIN_API();
    1390:	0e 94 0a 04 	call	0x814	; 0x814 <vPortYield>
			}
		}
	}
    1394:	df 91       	pop	r29
    1396:	cf 91       	pop	r28
    1398:	1f 91       	pop	r17
    139a:	0f 91       	pop	r16
    139c:	ff 90       	pop	r15
    139e:	ef 90       	pop	r14
    13a0:	08 95       	ret

000013a2 <vTaskStartScheduler>:
 * PUBLIC SCHEDULER CONTROL documented in task.h
 *----------------------------------------------------------*/


void vTaskStartScheduler( void )
{
    13a2:	af 92       	push	r10
    13a4:	bf 92       	push	r11
    13a6:	cf 92       	push	r12
    13a8:	df 92       	push	r13
    13aa:	ef 92       	push	r14
    13ac:	ff 92       	push	r15
    13ae:	0f 93       	push	r16
		xReturn = xTaskCreate( prvIdleTask, ( signed char * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), &xIdleTaskHandle );
	}
	#else
	{
		/* Create the idle task without storing its handle. */
		xReturn = xTaskCreate( prvIdleTask, ( signed char * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), NULL );
    13b0:	80 e7       	ldi	r24, 0x70	; 112
    13b2:	9b e0       	ldi	r25, 0x0B	; 11
    13b4:	6a e6       	ldi	r22, 0x6A	; 106
    13b6:	70 e0       	ldi	r23, 0x00	; 0
    13b8:	45 e5       	ldi	r20, 0x55	; 85
    13ba:	50 e0       	ldi	r21, 0x00	; 0
    13bc:	20 e0       	ldi	r18, 0x00	; 0
    13be:	30 e0       	ldi	r19, 0x00	; 0
    13c0:	00 e0       	ldi	r16, 0x00	; 0
    13c2:	ee 24       	eor	r14, r14
    13c4:	ff 24       	eor	r15, r15
    13c6:	cc 24       	eor	r12, r12
    13c8:	dd 24       	eor	r13, r13
    13ca:	aa 24       	eor	r10, r10
    13cc:	bb 24       	eor	r11, r11
    13ce:	0e 94 75 08 	call	0x10ea	; 0x10ea <xTaskGenericCreate>
			xReturn = xTimerCreateTimerTask();
		}
	}
	#endif

	if( xReturn == pdPASS )
    13d2:	81 30       	cpi	r24, 0x01	; 1
    13d4:	49 f4       	brne	.+18     	; 0x13e8 <vTaskStartScheduler+0x46>
		so interrupts will automatically get re-enabled when the first task
		starts to run.

		STEPPING THROUGH HERE USING A DEBUGGER CAN CAUSE BIG PROBLEMS IF THE
		DEBUGGER ALLOWS INTERRUPTS TO BE PROCESSED. */
		portDISABLE_INTERRUPTS();
    13d6:	f8 94       	cli

		xSchedulerRunning = pdTRUE;
    13d8:	80 93 0e 03 	sts	0x030E, r24
		xTickCount = ( portTickType ) 0U;
    13dc:	10 92 11 03 	sts	0x0311, r1
    13e0:	10 92 10 03 	sts	0x0310, r1
		the run time counter time base. */
		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();
		
		/* Setting up the timer tick is hardware specific and thus in the
		portable interface. */
		if( xPortStartScheduler() != pdFALSE )
    13e4:	0e 94 d4 03 	call	0x7a8	; 0x7a8 <xPortStartScheduler>
		}
	}

	/* This line will only be reached if the kernel could not be started. */
	configASSERT( xReturn );
}
    13e8:	0f 91       	pop	r16
    13ea:	ff 90       	pop	r15
    13ec:	ef 90       	pop	r14
    13ee:	df 90       	pop	r13
    13f0:	cf 90       	pop	r12
    13f2:	bf 90       	pop	r11
    13f4:	af 90       	pop	r10
    13f6:	08 95       	ret

000013f8 <vTaskEndScheduler>:
void vTaskEndScheduler( void )
{
	/* Stop the scheduler interrupts and call the portable scheduler end
	routine so the original ISRs can be restored if necessary.  The port
	layer must ensure interrupts enable	bit is left in the correct state. */
	portDISABLE_INTERRUPTS();
    13f8:	f8 94       	cli
	xSchedulerRunning = pdFALSE;
    13fa:	10 92 0e 03 	sts	0x030E, r1
	vPortEndScheduler();
    13fe:	0e 94 09 04 	call	0x812	; 0x812 <vPortEndScheduler>
}
    1402:	08 95       	ret

00001404 <vTaskSuspendAll>:

void vTaskSuspendAll( void )
{
	/* A critical section is not required as the variable is of type
	portBASE_TYPE. */
	++uxSchedulerSuspended;
    1404:	80 91 0d 03 	lds	r24, 0x030D
    1408:	8f 5f       	subi	r24, 0xFF	; 255
    140a:	80 93 0d 03 	sts	0x030D, r24
}
    140e:	08 95       	ret

00001410 <xTaskGetTickCount>:
portTickType xTaskGetTickCount( void )
{
portTickType xTicks;

	/* Critical section required if running on a 16 bit processor. */
	taskENTER_CRITICAL();
    1410:	0f b6       	in	r0, 0x3f	; 63
    1412:	f8 94       	cli
    1414:	0f 92       	push	r0
	{
		xTicks = xTickCount;
    1416:	80 91 10 03 	lds	r24, 0x0310
    141a:	90 91 11 03 	lds	r25, 0x0311
	}
	taskEXIT_CRITICAL();
    141e:	0f 90       	pop	r0
    1420:	0f be       	out	0x3f, r0	; 63

	return xTicks;
}
    1422:	08 95       	ret

00001424 <xTaskGetTickCountFromISR>:
{
portTickType xReturn;
unsigned portBASE_TYPE uxSavedInterruptStatus;

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	xReturn = xTickCount;
    1424:	80 91 10 03 	lds	r24, 0x0310
    1428:	90 91 11 03 	lds	r25, 0x0311
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    142c:	08 95       	ret

0000142e <uxTaskGetNumberOfTasks>:

unsigned portBASE_TYPE uxTaskGetNumberOfTasks( void )
{
	/* A critical section is not required because the variables are of type
	portBASE_TYPE. */
	return uxCurrentNumberOfTasks;
    142e:	80 91 12 03 	lds	r24, 0x0312
}
    1432:	08 95       	ret

00001434 <vTaskIncrementTick>:
 * SCHEDULER INTERNALS AVAILABLE FOR PORTING PURPOSES
 * documented in task.h
 *----------------------------------------------------------*/

void vTaskIncrementTick( void )
{
    1434:	0f 93       	push	r16
    1436:	1f 93       	push	r17
    1438:	cf 93       	push	r28
    143a:	df 93       	push	r29
tskTCB * pxTCB;

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    143c:	80 91 0d 03 	lds	r24, 0x030D
    1440:	88 23       	and	r24, r24
    1442:	09 f0       	breq	.+2      	; 0x1446 <vTaskIncrementTick+0x12>
    1444:	b3 c0       	rjmp	.+358    	; 0x15ac <vTaskIncrementTick+0x178>
	{
		++xTickCount;
    1446:	80 91 10 03 	lds	r24, 0x0310
    144a:	90 91 11 03 	lds	r25, 0x0311
    144e:	01 96       	adiw	r24, 0x01	; 1
    1450:	90 93 11 03 	sts	0x0311, r25
    1454:	80 93 10 03 	sts	0x0310, r24
		if( xTickCount == ( portTickType ) 0U )
    1458:	80 91 10 03 	lds	r24, 0x0310
    145c:	90 91 11 03 	lds	r25, 0x0311
    1460:	00 97       	sbiw	r24, 0x00	; 0
    1462:	99 f5       	brne	.+102    	; 0x14ca <vTaskIncrementTick+0x96>
			/* Tick count has overflowed so we need to swap the delay lists.
			If there are any items in pxDelayedTaskList here then there is
			an error! */
			configASSERT( ( listLIST_IS_EMPTY( pxDelayedTaskList ) ) );
			
			pxTemp = pxDelayedTaskList;
    1464:	80 91 16 03 	lds	r24, 0x0316
    1468:	90 91 17 03 	lds	r25, 0x0317
			pxDelayedTaskList = pxOverflowDelayedTaskList;
    146c:	20 91 14 03 	lds	r18, 0x0314
    1470:	30 91 15 03 	lds	r19, 0x0315
    1474:	30 93 17 03 	sts	0x0317, r19
    1478:	20 93 16 03 	sts	0x0316, r18
			pxOverflowDelayedTaskList = pxTemp;
    147c:	90 93 15 03 	sts	0x0315, r25
    1480:	80 93 14 03 	sts	0x0314, r24
			xNumOfOverflows++;
    1484:	80 91 0a 03 	lds	r24, 0x030A
    1488:	8f 5f       	subi	r24, 0xFF	; 255
    148a:	80 93 0a 03 	sts	0x030A, r24
	
			if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    148e:	e0 91 16 03 	lds	r30, 0x0316
    1492:	f0 91 17 03 	lds	r31, 0x0317
    1496:	80 81       	ld	r24, Z
    1498:	88 23       	and	r24, r24
    149a:	39 f4       	brne	.+14     	; 0x14aa <vTaskIncrementTick+0x76>
				/* The new current delayed list is empty.  Set
				xNextTaskUnblockTime to the maximum possible value so it is
				extremely unlikely that the	
				if( xTickCount >= xNextTaskUnblockTime ) test will pass until
				there is an item in the delayed list. */
				xNextTaskUnblockTime = portMAX_DELAY;
    149c:	8f ef       	ldi	r24, 0xFF	; 255
    149e:	9f ef       	ldi	r25, 0xFF	; 255
    14a0:	90 93 70 00 	sts	0x0070, r25
    14a4:	80 93 6f 00 	sts	0x006F, r24
    14a8:	10 c0       	rjmp	.+32     	; 0x14ca <vTaskIncrementTick+0x96>
			{
				/* The new current delayed list is not empty, get the value of
				the item at the head of the delayed list.  This is the time at
				which the task at the head of the delayed list should be removed
				from the Blocked state. */
				pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
    14aa:	e0 91 16 03 	lds	r30, 0x0316
    14ae:	f0 91 17 03 	lds	r31, 0x0317
    14b2:	05 80       	ldd	r0, Z+5	; 0x05
    14b4:	f6 81       	ldd	r31, Z+6	; 0x06
    14b6:	e0 2d       	mov	r30, r0
    14b8:	06 80       	ldd	r0, Z+6	; 0x06
    14ba:	f7 81       	ldd	r31, Z+7	; 0x07
    14bc:	e0 2d       	mov	r30, r0
				xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( pxTCB->xGenericListItem ) );
    14be:	82 81       	ldd	r24, Z+2	; 0x02
    14c0:	93 81       	ldd	r25, Z+3	; 0x03
    14c2:	90 93 70 00 	sts	0x0070, r25
    14c6:	80 93 6f 00 	sts	0x006F, r24
			}
		}

		/* See if this tick has made a timeout expire. */
		prvCheckDelayedTasks();
    14ca:	20 91 10 03 	lds	r18, 0x0310
    14ce:	30 91 11 03 	lds	r19, 0x0311
    14d2:	80 91 6f 00 	lds	r24, 0x006F
    14d6:	90 91 70 00 	lds	r25, 0x0070
    14da:	28 17       	cp	r18, r24
    14dc:	39 07       	cpc	r19, r25
    14de:	08 f4       	brcc	.+2      	; 0x14e2 <vTaskIncrementTick+0xae>
    14e0:	6a c0       	rjmp	.+212    	; 0x15b6 <vTaskIncrementTick+0x182>
    14e2:	e0 91 16 03 	lds	r30, 0x0316
    14e6:	f0 91 17 03 	lds	r31, 0x0317
    14ea:	80 81       	ld	r24, Z
    14ec:	88 23       	and	r24, r24
    14ee:	99 f0       	breq	.+38     	; 0x1516 <vTaskIncrementTick+0xe2>
    14f0:	e0 91 16 03 	lds	r30, 0x0316
    14f4:	f0 91 17 03 	lds	r31, 0x0317
    14f8:	05 80       	ldd	r0, Z+5	; 0x05
    14fa:	f6 81       	ldd	r31, Z+6	; 0x06
    14fc:	e0 2d       	mov	r30, r0
    14fe:	c6 81       	ldd	r28, Z+6	; 0x06
    1500:	d7 81       	ldd	r29, Z+7	; 0x07
    1502:	8a 81       	ldd	r24, Y+2	; 0x02
    1504:	9b 81       	ldd	r25, Y+3	; 0x03
    1506:	20 91 10 03 	lds	r18, 0x0310
    150a:	30 91 11 03 	lds	r19, 0x0311
    150e:	28 17       	cp	r18, r24
    1510:	39 07       	cpc	r19, r25
    1512:	f8 f4       	brcc	.+62     	; 0x1552 <vTaskIncrementTick+0x11e>
    1514:	19 c0       	rjmp	.+50     	; 0x1548 <vTaskIncrementTick+0x114>
    1516:	8f ef       	ldi	r24, 0xFF	; 255
    1518:	9f ef       	ldi	r25, 0xFF	; 255
    151a:	90 93 70 00 	sts	0x0070, r25
    151e:	80 93 6f 00 	sts	0x006F, r24
    1522:	49 c0       	rjmp	.+146    	; 0x15b6 <vTaskIncrementTick+0x182>
    1524:	e0 91 16 03 	lds	r30, 0x0316
    1528:	f0 91 17 03 	lds	r31, 0x0317
    152c:	05 80       	ldd	r0, Z+5	; 0x05
    152e:	f6 81       	ldd	r31, Z+6	; 0x06
    1530:	e0 2d       	mov	r30, r0
    1532:	c6 81       	ldd	r28, Z+6	; 0x06
    1534:	d7 81       	ldd	r29, Z+7	; 0x07
    1536:	8a 81       	ldd	r24, Y+2	; 0x02
    1538:	9b 81       	ldd	r25, Y+3	; 0x03
    153a:	20 91 10 03 	lds	r18, 0x0310
    153e:	30 91 11 03 	lds	r19, 0x0311
    1542:	28 17       	cp	r18, r24
    1544:	39 07       	cpc	r19, r25
    1546:	28 f4       	brcc	.+10     	; 0x1552 <vTaskIncrementTick+0x11e>
    1548:	90 93 70 00 	sts	0x0070, r25
    154c:	80 93 6f 00 	sts	0x006F, r24
    1550:	32 c0       	rjmp	.+100    	; 0x15b6 <vTaskIncrementTick+0x182>
    1552:	8e 01       	movw	r16, r28
    1554:	0e 5f       	subi	r16, 0xFE	; 254
    1556:	1f 4f       	sbci	r17, 0xFF	; 255
    1558:	c8 01       	movw	r24, r16
    155a:	0e 94 1e 03 	call	0x63c	; 0x63c <vListRemove>
    155e:	8c 89       	ldd	r24, Y+20	; 0x14
    1560:	9d 89       	ldd	r25, Y+21	; 0x15
    1562:	00 97       	sbiw	r24, 0x00	; 0
    1564:	21 f0       	breq	.+8      	; 0x156e <vTaskIncrementTick+0x13a>
    1566:	ce 01       	movw	r24, r28
    1568:	0c 96       	adiw	r24, 0x0c	; 12
    156a:	0e 94 1e 03 	call	0x63c	; 0x63c <vListRemove>
    156e:	8e 89       	ldd	r24, Y+22	; 0x16
    1570:	90 91 0f 03 	lds	r25, 0x030F
    1574:	98 17       	cp	r25, r24
    1576:	10 f4       	brcc	.+4      	; 0x157c <vTaskIncrementTick+0x148>
    1578:	80 93 0f 03 	sts	0x030F, r24
    157c:	90 e0       	ldi	r25, 0x00	; 0
    157e:	9c 01       	movw	r18, r24
    1580:	22 0f       	add	r18, r18
    1582:	33 1f       	adc	r19, r19
    1584:	22 0f       	add	r18, r18
    1586:	33 1f       	adc	r19, r19
    1588:	22 0f       	add	r18, r18
    158a:	33 1f       	adc	r19, r19
    158c:	82 0f       	add	r24, r18
    158e:	93 1f       	adc	r25, r19
    1590:	86 5e       	subi	r24, 0xE6	; 230
    1592:	9c 4f       	sbci	r25, 0xFC	; 252
    1594:	b8 01       	movw	r22, r16
    1596:	0e 94 b8 02 	call	0x570	; 0x570 <vListInsertEnd>
    159a:	e0 91 16 03 	lds	r30, 0x0316
    159e:	f0 91 17 03 	lds	r31, 0x0317
    15a2:	80 81       	ld	r24, Z
    15a4:	88 23       	and	r24, r24
    15a6:	09 f0       	breq	.+2      	; 0x15aa <vTaskIncrementTick+0x176>
    15a8:	bd cf       	rjmp	.-134    	; 0x1524 <vTaskIncrementTick+0xf0>
    15aa:	b5 cf       	rjmp	.-150    	; 0x1516 <vTaskIncrementTick+0xe2>
	}
	else
	{
		++uxMissedTicks;
    15ac:	80 91 0c 03 	lds	r24, 0x030C
    15b0:	8f 5f       	subi	r24, 0xFF	; 255
    15b2:	80 93 0c 03 	sts	0x030C, r24
		}
	}
	#endif

	traceTASK_INCREMENT_TICK( xTickCount );
}
    15b6:	df 91       	pop	r29
    15b8:	cf 91       	pop	r28
    15ba:	1f 91       	pop	r17
    15bc:	0f 91       	pop	r16
    15be:	08 95       	ret

000015c0 <xTaskResumeAll>:
	++uxSchedulerSuspended;
}
/*----------------------------------------------------------*/

signed portBASE_TYPE xTaskResumeAll( void )
{
    15c0:	af 92       	push	r10
    15c2:	bf 92       	push	r11
    15c4:	cf 92       	push	r12
    15c6:	df 92       	push	r13
    15c8:	ef 92       	push	r14
    15ca:	ff 92       	push	r15
    15cc:	0f 93       	push	r16
    15ce:	1f 93       	push	r17
    15d0:	cf 93       	push	r28
    15d2:	df 93       	push	r29
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
    15d4:	0f b6       	in	r0, 0x3f	; 63
    15d6:	f8 94       	cli
    15d8:	0f 92       	push	r0
	{
		--uxSchedulerSuspended;
    15da:	80 91 0d 03 	lds	r24, 0x030D
    15de:	81 50       	subi	r24, 0x01	; 1
    15e0:	80 93 0d 03 	sts	0x030D, r24

		if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    15e4:	80 91 0d 03 	lds	r24, 0x030D
    15e8:	88 23       	and	r24, r24
    15ea:	09 f0       	breq	.+2      	; 0x15ee <xTaskResumeAll+0x2e>
    15ec:	69 c0       	rjmp	.+210    	; 0x16c0 <xTaskResumeAll+0x100>
		{
			if( uxCurrentNumberOfTasks > ( unsigned portBASE_TYPE ) 0U )
    15ee:	80 91 12 03 	lds	r24, 0x0312
    15f2:	88 23       	and	r24, r24
    15f4:	81 f5       	brne	.+96     	; 0x1656 <xTaskResumeAll+0x96>
    15f6:	67 c0       	rjmp	.+206    	; 0x16c6 <xTaskResumeAll+0x106>

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) );
    15f8:	d6 01       	movw	r26, r12
    15fa:	ed 91       	ld	r30, X+
    15fc:	fc 91       	ld	r31, X
    15fe:	c6 81       	ldd	r28, Z+6	; 0x06
    1600:	d7 81       	ldd	r29, Z+7	; 0x07
					vListRemove( &( pxTCB->xEventListItem ) );
    1602:	ce 01       	movw	r24, r28
    1604:	0c 96       	adiw	r24, 0x0c	; 12
    1606:	0e 94 1e 03 	call	0x63c	; 0x63c <vListRemove>
					vListRemove( &( pxTCB->xGenericListItem ) );
    160a:	8e 01       	movw	r16, r28
    160c:	0e 5f       	subi	r16, 0xFE	; 254
    160e:	1f 4f       	sbci	r17, 0xFF	; 255
    1610:	c8 01       	movw	r24, r16
    1612:	0e 94 1e 03 	call	0x63c	; 0x63c <vListRemove>
					prvAddTaskToReadyQueue( pxTCB );
    1616:	8e 89       	ldd	r24, Y+22	; 0x16
    1618:	90 91 0f 03 	lds	r25, 0x030F
    161c:	98 17       	cp	r25, r24
    161e:	10 f4       	brcc	.+4      	; 0x1624 <xTaskResumeAll+0x64>
    1620:	80 93 0f 03 	sts	0x030F, r24
    1624:	90 e0       	ldi	r25, 0x00	; 0
    1626:	9c 01       	movw	r18, r24
    1628:	22 0f       	add	r18, r18
    162a:	33 1f       	adc	r19, r19
    162c:	22 0f       	add	r18, r18
    162e:	33 1f       	adc	r19, r19
    1630:	22 0f       	add	r18, r18
    1632:	33 1f       	adc	r19, r19
    1634:	82 0f       	add	r24, r18
    1636:	93 1f       	adc	r25, r19
    1638:	86 5e       	subi	r24, 0xE6	; 230
    163a:	9c 4f       	sbci	r25, 0xFC	; 252
    163c:	b8 01       	movw	r22, r16
    163e:	0e 94 b8 02 	call	0x570	; 0x570 <vListInsertEnd>

					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    1642:	e0 91 08 03 	lds	r30, 0x0308
    1646:	f0 91 09 03 	lds	r31, 0x0309
    164a:	9e 89       	ldd	r25, Y+22	; 0x16
    164c:	86 89       	ldd	r24, Z+22	; 0x16
    164e:	98 17       	cp	r25, r24
    1650:	88 f0       	brcs	.+34     	; 0x1674 <xTaskResumeAll+0xb4>
					{
						xYieldRequired = pdTRUE;
    1652:	ba 2c       	mov	r11, r10
    1654:	0f c0       	rjmp	.+30     	; 0x1674 <xTaskResumeAll+0xb4>
	{
		--uxSchedulerSuspended;

		if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
		{
			if( uxCurrentNumberOfTasks > ( unsigned portBASE_TYPE ) 0U )
    1656:	bb 24       	eor	r11, r11
			{
				portBASE_TYPE xYieldRequired = pdFALSE;

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
    1658:	0f 2e       	mov	r0, r31
    165a:	f7 e4       	ldi	r31, 0x47	; 71
    165c:	ef 2e       	mov	r14, r31
    165e:	f3 e0       	ldi	r31, 0x03	; 3
    1660:	ff 2e       	mov	r15, r31
    1662:	f0 2d       	mov	r31, r0
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) );
    1664:	0f 2e       	mov	r0, r31
    1666:	fc e4       	ldi	r31, 0x4C	; 76
    1668:	cf 2e       	mov	r12, r31
    166a:	f3 e0       	ldi	r31, 0x03	; 3
    166c:	df 2e       	mov	r13, r31
    166e:	f0 2d       	mov	r31, r0

					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
					{
						xYieldRequired = pdTRUE;
    1670:	aa 24       	eor	r10, r10
    1672:	a3 94       	inc	r10
			{
				portBASE_TYPE xYieldRequired = pdFALSE;

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
    1674:	f7 01       	movw	r30, r14
    1676:	80 81       	ld	r24, Z
    1678:	88 23       	and	r24, r24
    167a:	09 f0       	breq	.+2      	; 0x167e <xTaskResumeAll+0xbe>
    167c:	bd cf       	rjmp	.-134    	; 0x15f8 <xTaskResumeAll+0x38>
				}

				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
    167e:	80 91 0c 03 	lds	r24, 0x030C
    1682:	88 23       	and	r24, r24
    1684:	81 f0       	breq	.+32     	; 0x16a6 <xTaskResumeAll+0xe6>
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
    1686:	80 91 0c 03 	lds	r24, 0x030C
    168a:	88 23       	and	r24, r24
    168c:	99 f0       	breq	.+38     	; 0x16b4 <xTaskResumeAll+0xf4>
					{
						vTaskIncrementTick();
    168e:	0e 94 1a 0a 	call	0x1434	; 0x1434 <vTaskIncrementTick>
						--uxMissedTicks;
    1692:	80 91 0c 03 	lds	r24, 0x030C
    1696:	81 50       	subi	r24, 0x01	; 1
    1698:	80 93 0c 03 	sts	0x030C, r24
				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
    169c:	80 91 0c 03 	lds	r24, 0x030C
    16a0:	88 23       	and	r24, r24
    16a2:	a9 f7       	brne	.-22     	; 0x168e <xTaskResumeAll+0xce>
    16a4:	07 c0       	rjmp	.+14     	; 0x16b4 <xTaskResumeAll+0xf4>
						xYieldRequired = pdTRUE;
					}
					#endif
				}

				if( ( xYieldRequired == pdTRUE ) || ( xMissedYield == pdTRUE ) )
    16a6:	f1 e0       	ldi	r31, 0x01	; 1
    16a8:	bf 16       	cp	r11, r31
    16aa:	21 f0       	breq	.+8      	; 0x16b4 <xTaskResumeAll+0xf4>
    16ac:	80 91 0b 03 	lds	r24, 0x030B
    16b0:	81 30       	cpi	r24, 0x01	; 1
    16b2:	41 f4       	brne	.+16     	; 0x16c4 <xTaskResumeAll+0x104>
				{
					xAlreadyYielded = pdTRUE;
					xMissedYield = pdFALSE;
    16b4:	10 92 0b 03 	sts	0x030B, r1
					portYIELD_WITHIN_API();
    16b8:	0e 94 0a 04 	call	0x814	; 0x814 <vPortYield>
					#endif
				}

				if( ( xYieldRequired == pdTRUE ) || ( xMissedYield == pdTRUE ) )
				{
					xAlreadyYielded = pdTRUE;
    16bc:	81 e0       	ldi	r24, 0x01	; 1
    16be:	03 c0       	rjmp	.+6      	; 0x16c6 <xTaskResumeAll+0x106>
/*----------------------------------------------------------*/

signed portBASE_TYPE xTaskResumeAll( void )
{
register tskTCB *pxTCB;
signed portBASE_TYPE xAlreadyYielded = pdFALSE;
    16c0:	80 e0       	ldi	r24, 0x00	; 0
    16c2:	01 c0       	rjmp	.+2      	; 0x16c6 <xTaskResumeAll+0x106>
    16c4:	80 e0       	ldi	r24, 0x00	; 0
					portYIELD_WITHIN_API();
				}
			}
		}
	}
	taskEXIT_CRITICAL();
    16c6:	0f 90       	pop	r0
    16c8:	0f be       	out	0x3f, r0	; 63

	return xAlreadyYielded;
}
    16ca:	df 91       	pop	r29
    16cc:	cf 91       	pop	r28
    16ce:	1f 91       	pop	r17
    16d0:	0f 91       	pop	r16
    16d2:	ff 90       	pop	r15
    16d4:	ef 90       	pop	r14
    16d6:	df 90       	pop	r13
    16d8:	cf 90       	pop	r12
    16da:	bf 90       	pop	r11
    16dc:	af 90       	pop	r10
    16de:	08 95       	ret

000016e0 <prvIdleTask>:
		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		if( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0U )
		{
			vTaskSuspendAll();
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
    16e0:	00 e5       	ldi	r16, 0x50	; 80
    16e2:	13 e0       	ldi	r17, 0x03	; 3
			{
				tskTCB *pxTCB;

				taskENTER_CRITICAL();
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( ( ( xList * ) &xTasksWaitingTermination ) );
    16e4:	0f 2e       	mov	r0, r31
    16e6:	f5 e5       	ldi	r31, 0x55	; 85
    16e8:	ef 2e       	mov	r14, r31
    16ea:	f3 e0       	ldi	r31, 0x03	; 3
    16ec:	ff 2e       	mov	r15, r31
    16ee:	f0 2d       	mov	r31, r0
	{
		portBASE_TYPE xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		if( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0U )
    16f0:	80 91 13 03 	lds	r24, 0x0313
    16f4:	88 23       	and	r24, r24
    16f6:	e1 f3       	breq	.-8      	; 0x16f0 <prvIdleTask+0x10>
		{
			vTaskSuspendAll();
    16f8:	0e 94 02 0a 	call	0x1404	; 0x1404 <vTaskSuspendAll>
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
    16fc:	d8 01       	movw	r26, r16
    16fe:	cc 91       	ld	r28, X
			xTaskResumeAll();
    1700:	0e 94 e0 0a 	call	0x15c0	; 0x15c0 <xTaskResumeAll>

			if( xListIsEmpty == pdFALSE )
    1704:	cc 23       	and	r28, r28
    1706:	a1 f3       	breq	.-24     	; 0x16f0 <prvIdleTask+0x10>
			{
				tskTCB *pxTCB;

				taskENTER_CRITICAL();
    1708:	0f b6       	in	r0, 0x3f	; 63
    170a:	f8 94       	cli
    170c:	0f 92       	push	r0
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( ( ( xList * ) &xTasksWaitingTermination ) );
    170e:	d7 01       	movw	r26, r14
    1710:	ed 91       	ld	r30, X+
    1712:	fc 91       	ld	r31, X
    1714:	c6 81       	ldd	r28, Z+6	; 0x06
    1716:	d7 81       	ldd	r29, Z+7	; 0x07
					vListRemove( &( pxTCB->xGenericListItem ) );
    1718:	ce 01       	movw	r24, r28
    171a:	02 96       	adiw	r24, 0x02	; 2
    171c:	0e 94 1e 03 	call	0x63c	; 0x63c <vListRemove>
					--uxCurrentNumberOfTasks;
    1720:	80 91 12 03 	lds	r24, 0x0312
    1724:	81 50       	subi	r24, 0x01	; 1
    1726:	80 93 12 03 	sts	0x0312, r24
					--uxTasksDeleted;
    172a:	80 91 13 03 	lds	r24, 0x0313
    172e:	81 50       	subi	r24, 0x01	; 1
    1730:	80 93 13 03 	sts	0x0313, r24
				}
				taskEXIT_CRITICAL();
    1734:	0f 90       	pop	r0
    1736:	0f be       	out	0x3f, r0	; 63

	static void prvDeleteTCB( tskTCB *pxTCB )
	{
		/* Free up the memory allocated by the scheduler for the task.  It is up to
		the task to free any memory allocated at the application level. */
		vPortFreeAligned( pxTCB->pxStack );
    1738:	8f 89       	ldd	r24, Y+23	; 0x17
    173a:	98 8d       	ldd	r25, Y+24	; 0x18
    173c:	0e 94 97 02 	call	0x52e	; 0x52e <vPortFree>
		vPortFree( pxTCB );
    1740:	ce 01       	movw	r24, r28
    1742:	0e 94 97 02 	call	0x52e	; 0x52e <vPortFree>
    1746:	d4 cf       	rjmp	.-88     	; 0x16f0 <prvIdleTask+0x10>

00001748 <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( portTickType xTicksToDelay )
	{
    1748:	cf 93       	push	r28
    174a:	df 93       	push	r29
    174c:	ec 01       	movw	r28, r24
	portTickType xTimeToWake;
	signed portBASE_TYPE xAlreadyYielded = pdFALSE;

		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( portTickType ) 0U )
    174e:	00 97       	sbiw	r24, 0x00	; 0
    1750:	b1 f0       	breq	.+44     	; 0x177e <vTaskDelay+0x36>
		{
			vTaskSuspendAll();
    1752:	0e 94 02 0a 	call	0x1404	; 0x1404 <vTaskSuspendAll>
				This task cannot be in an event list as it is the currently
				executing task. */

				/* Calculate the time to wake - this may overflow but this is
				not a problem. */
				xTimeToWake = xTickCount + xTicksToDelay;
    1756:	80 91 10 03 	lds	r24, 0x0310
    175a:	90 91 11 03 	lds	r25, 0x0311
    175e:	c8 0f       	add	r28, r24
    1760:	d9 1f       	adc	r29, r25

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    1762:	80 91 08 03 	lds	r24, 0x0308
    1766:	90 91 09 03 	lds	r25, 0x0309
    176a:	02 96       	adiw	r24, 0x02	; 2
    176c:	0e 94 1e 03 	call	0x63c	; 0x63c <vListRemove>
				prvAddCurrentTaskToDelayedList( xTimeToWake );
    1770:	ce 01       	movw	r24, r28
    1772:	0e 94 3e 08 	call	0x107c	; 0x107c <prvAddCurrentTaskToDelayedList>
			}
			xAlreadyYielded = xTaskResumeAll();
    1776:	0e 94 e0 0a 	call	0x15c0	; 0x15c0 <xTaskResumeAll>
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    177a:	88 23       	and	r24, r24
    177c:	11 f4       	brne	.+4      	; 0x1782 <vTaskDelay+0x3a>
		{
			portYIELD_WITHIN_API();
    177e:	0e 94 0a 04 	call	0x814	; 0x814 <vPortYield>
		}
	}
    1782:	df 91       	pop	r29
    1784:	cf 91       	pop	r28
    1786:	08 95       	ret

00001788 <vTaskDelayUntil>:
 *----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelayUntil == 1 )

	void vTaskDelayUntil( portTickType * const pxPreviousWakeTime, portTickType xTimeIncrement )
	{
    1788:	0f 93       	push	r16
    178a:	1f 93       	push	r17
    178c:	cf 93       	push	r28
    178e:	df 93       	push	r29
    1790:	8c 01       	movw	r16, r24
    1792:	eb 01       	movw	r28, r22
	portBASE_TYPE xAlreadyYielded, xShouldDelay = pdFALSE;

		configASSERT( pxPreviousWakeTime );
		configASSERT( ( xTimeIncrement > 0U ) );

		vTaskSuspendAll();
    1794:	0e 94 02 0a 	call	0x1404	; 0x1404 <vTaskSuspendAll>
		{
			/* Generate the tick time at which the task wants to wake. */
			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
    1798:	f8 01       	movw	r30, r16
    179a:	80 81       	ld	r24, Z
    179c:	91 81       	ldd	r25, Z+1	; 0x01
    179e:	c8 0f       	add	r28, r24
    17a0:	d9 1f       	adc	r29, r25

			if( xTickCount < *pxPreviousWakeTime )
    17a2:	20 91 10 03 	lds	r18, 0x0310
    17a6:	30 91 11 03 	lds	r19, 0x0311
    17aa:	28 17       	cp	r18, r24
    17ac:	39 07       	cpc	r19, r25
    17ae:	68 f4       	brcc	.+26     	; 0x17ca <vTaskDelayUntil+0x42>
				/* The tick count has overflowed since this function was
				lasted called.  In this case the only time we should ever
				actually delay is if the wake time has also	overflowed,
				and the wake time is greater than the tick time.  When this
				is the case it is as if neither time had overflowed. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xTickCount ) )
    17b0:	c8 17       	cp	r28, r24
    17b2:	d9 07       	cpc	r29, r25
    17b4:	50 f5       	brcc	.+84     	; 0x180a <vTaskDelayUntil+0x82>
    17b6:	80 91 10 03 	lds	r24, 0x0310
    17ba:	90 91 11 03 	lds	r25, 0x0311
					xShouldDelay = pdTRUE;
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
    17be:	d1 83       	std	Z+1, r29	; 0x01
    17c0:	c0 83       	st	Z, r28

			if( xShouldDelay != pdFALSE )
    17c2:	8c 17       	cp	r24, r28
    17c4:	9d 07       	cpc	r25, r29
    17c6:	b0 f4       	brcc	.+44     	; 0x17f4 <vTaskDelayUntil+0x6c>
    17c8:	0b c0       	rjmp	.+22     	; 0x17e0 <vTaskDelayUntil+0x58>
			else
			{
				/* The tick time has not overflowed.  In this case we will
				delay if either the wake time has overflowed, and/or the
				tick time is less than the wake time. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xTickCount ) )
    17ca:	c8 17       	cp	r28, r24
    17cc:	d9 07       	cpc	r29, r25
    17ce:	c8 f0       	brcs	.+50     	; 0x1802 <vTaskDelayUntil+0x7a>
    17d0:	80 91 10 03 	lds	r24, 0x0310
    17d4:	90 91 11 03 	lds	r25, 0x0311
    17d8:	8c 17       	cp	r24, r28
    17da:	9d 07       	cpc	r25, r29
    17dc:	90 f0       	brcs	.+36     	; 0x1802 <vTaskDelayUntil+0x7a>
    17de:	15 c0       	rjmp	.+42     	; 0x180a <vTaskDelayUntil+0x82>
				traceTASK_DELAY_UNTIL();

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    17e0:	80 91 08 03 	lds	r24, 0x0308
    17e4:	90 91 09 03 	lds	r25, 0x0309
    17e8:	02 96       	adiw	r24, 0x02	; 2
    17ea:	0e 94 1e 03 	call	0x63c	; 0x63c <vListRemove>
				prvAddCurrentTaskToDelayedList( xTimeToWake );
    17ee:	ce 01       	movw	r24, r28
    17f0:	0e 94 3e 08 	call	0x107c	; 0x107c <prvAddCurrentTaskToDelayedList>
			}
		}
		xAlreadyYielded = xTaskResumeAll();
    17f4:	0e 94 e0 0a 	call	0x15c0	; 0x15c0 <xTaskResumeAll>

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    17f8:	88 23       	and	r24, r24
    17fa:	59 f4       	brne	.+22     	; 0x1812 <vTaskDelayUntil+0x8a>
		{
			portYIELD_WITHIN_API();
    17fc:	0e 94 0a 04 	call	0x814	; 0x814 <vPortYield>
    1800:	08 c0       	rjmp	.+16     	; 0x1812 <vTaskDelayUntil+0x8a>
					xShouldDelay = pdTRUE;
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
    1802:	f8 01       	movw	r30, r16
    1804:	d1 83       	std	Z+1, r29	; 0x01
    1806:	c0 83       	st	Z, r28
    1808:	eb cf       	rjmp	.-42     	; 0x17e0 <vTaskDelayUntil+0x58>
    180a:	f8 01       	movw	r30, r16
    180c:	d1 83       	std	Z+1, r29	; 0x01
    180e:	c0 83       	st	Z, r28
    1810:	f1 cf       	rjmp	.-30     	; 0x17f4 <vTaskDelayUntil+0x6c>
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
		{
			portYIELD_WITHIN_API();
		}
	}
    1812:	df 91       	pop	r29
    1814:	cf 91       	pop	r28
    1816:	1f 91       	pop	r17
    1818:	0f 91       	pop	r16
    181a:	08 95       	ret

0000181c <vTaskSwitchContext>:
#endif
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
    181c:	80 91 0d 03 	lds	r24, 0x030D
    1820:	88 23       	and	r24, r24
    1822:	99 f4       	brne	.+38     	; 0x184a <vTaskSwitchContext+0x2e>
	
		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();
	
		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
    1824:	80 91 0f 03 	lds	r24, 0x030F
    1828:	90 e0       	ldi	r25, 0x00	; 0
    182a:	fc 01       	movw	r30, r24
    182c:	ee 0f       	add	r30, r30
    182e:	ff 1f       	adc	r31, r31
    1830:	ee 0f       	add	r30, r30
    1832:	ff 1f       	adc	r31, r31
    1834:	ee 0f       	add	r30, r30
    1836:	ff 1f       	adc	r31, r31
    1838:	8e 0f       	add	r24, r30
    183a:	9f 1f       	adc	r25, r31
    183c:	fc 01       	movw	r30, r24
    183e:	e6 5e       	subi	r30, 0xE6	; 230
    1840:	fc 4f       	sbci	r31, 0xFC	; 252
    1842:	80 81       	ld	r24, Z
    1844:	88 23       	and	r24, r24
    1846:	29 f0       	breq	.+10     	; 0x1852 <vTaskSwitchContext+0x36>
    1848:	1b c0       	rjmp	.+54     	; 0x1880 <vTaskSwitchContext+0x64>
{
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xMissedYield = pdTRUE;
    184a:	81 e0       	ldi	r24, 0x01	; 1
    184c:	80 93 0b 03 	sts	0x030B, r24
    1850:	08 95       	ret
	
		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
		{
			configASSERT( uxTopReadyPriority );
			--uxTopReadyPriority;
    1852:	80 91 0f 03 	lds	r24, 0x030F
    1856:	81 50       	subi	r24, 0x01	; 1
    1858:	80 93 0f 03 	sts	0x030F, r24
	
		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();
	
		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
    185c:	80 91 0f 03 	lds	r24, 0x030F
    1860:	90 e0       	ldi	r25, 0x00	; 0
    1862:	fc 01       	movw	r30, r24
    1864:	ee 0f       	add	r30, r30
    1866:	ff 1f       	adc	r31, r31
    1868:	ee 0f       	add	r30, r30
    186a:	ff 1f       	adc	r31, r31
    186c:	ee 0f       	add	r30, r30
    186e:	ff 1f       	adc	r31, r31
    1870:	8e 0f       	add	r24, r30
    1872:	9f 1f       	adc	r25, r31
    1874:	fc 01       	movw	r30, r24
    1876:	e6 5e       	subi	r30, 0xE6	; 230
    1878:	fc 4f       	sbci	r31, 0xFC	; 252
    187a:	80 81       	ld	r24, Z
    187c:	88 23       	and	r24, r24
    187e:	49 f3       	breq	.-46     	; 0x1852 <vTaskSwitchContext+0x36>
			--uxTopReadyPriority;
		}
	
		/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the tasks of the
		same priority get an equal share of the processor time. */
		listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopReadyPriority ] ) );
    1880:	80 91 0f 03 	lds	r24, 0x030F
    1884:	90 e0       	ldi	r25, 0x00	; 0
    1886:	fc 01       	movw	r30, r24
    1888:	ee 0f       	add	r30, r30
    188a:	ff 1f       	adc	r31, r31
    188c:	ee 0f       	add	r30, r30
    188e:	ff 1f       	adc	r31, r31
    1890:	ee 0f       	add	r30, r30
    1892:	ff 1f       	adc	r31, r31
    1894:	e8 0f       	add	r30, r24
    1896:	f9 1f       	adc	r31, r25
    1898:	e6 5e       	subi	r30, 0xE6	; 230
    189a:	fc 4f       	sbci	r31, 0xFC	; 252
    189c:	a1 81       	ldd	r26, Z+1	; 0x01
    189e:	b2 81       	ldd	r27, Z+2	; 0x02
    18a0:	12 96       	adiw	r26, 0x02	; 2
    18a2:	0d 90       	ld	r0, X+
    18a4:	bc 91       	ld	r27, X
    18a6:	a0 2d       	mov	r26, r0
    18a8:	b2 83       	std	Z+2, r27	; 0x02
    18aa:	a1 83       	std	Z+1, r26	; 0x01
    18ac:	cf 01       	movw	r24, r30
    18ae:	03 96       	adiw	r24, 0x03	; 3
    18b0:	a8 17       	cp	r26, r24
    18b2:	b9 07       	cpc	r27, r25
    18b4:	31 f4       	brne	.+12     	; 0x18c2 <vTaskSwitchContext+0xa6>
    18b6:	12 96       	adiw	r26, 0x02	; 2
    18b8:	8d 91       	ld	r24, X+
    18ba:	9c 91       	ld	r25, X
    18bc:	13 97       	sbiw	r26, 0x03	; 3
    18be:	92 83       	std	Z+2, r25	; 0x02
    18c0:	81 83       	std	Z+1, r24	; 0x01
    18c2:	01 80       	ldd	r0, Z+1	; 0x01
    18c4:	f2 81       	ldd	r31, Z+2	; 0x02
    18c6:	e0 2d       	mov	r30, r0
    18c8:	86 81       	ldd	r24, Z+6	; 0x06
    18ca:	97 81       	ldd	r25, Z+7	; 0x07
    18cc:	90 93 09 03 	sts	0x0309, r25
    18d0:	80 93 08 03 	sts	0x0308, r24
    18d4:	08 95       	ret

000018d6 <vTaskPlaceOnEventList>:
	}
}
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( const xList * const pxEventList, portTickType xTicksToWait )
{
    18d6:	cf 93       	push	r28
    18d8:	df 93       	push	r29
    18da:	eb 01       	movw	r28, r22
	SCHEDULER SUSPENDED. */

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event. */
	vListInsert( ( xList * ) pxEventList, ( xListItem * ) &( pxCurrentTCB->xEventListItem ) );
    18dc:	60 91 08 03 	lds	r22, 0x0308
    18e0:	70 91 09 03 	lds	r23, 0x0309
    18e4:	64 5f       	subi	r22, 0xF4	; 244
    18e6:	7f 4f       	sbci	r23, 0xFF	; 255
    18e8:	0e 94 e1 02 	call	0x5c2	; 0x5c2 <vListInsert>

	/* We must remove ourselves from the ready list before adding ourselves
	to the blocked list as the same list item is used for both lists.  We have
	exclusive access to the ready lists as the scheduler is locked. */
	vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    18ec:	80 91 08 03 	lds	r24, 0x0308
    18f0:	90 91 09 03 	lds	r25, 0x0309
    18f4:	02 96       	adiw	r24, 0x02	; 2
    18f6:	0e 94 1e 03 	call	0x63c	; 0x63c <vListRemove>
	}
	#else
	{
			/* Calculate the time at which the task should be woken if the event does
			not occur.  This may overflow but this doesn't matter. */
			xTimeToWake = xTickCount + xTicksToWait;
    18fa:	80 91 10 03 	lds	r24, 0x0310
    18fe:	90 91 11 03 	lds	r25, 0x0311
			prvAddCurrentTaskToDelayedList( xTimeToWake );
    1902:	8c 0f       	add	r24, r28
    1904:	9d 1f       	adc	r25, r29
    1906:	0e 94 3e 08 	call	0x107c	; 0x107c <prvAddCurrentTaskToDelayedList>
	}
	#endif
}
    190a:	df 91       	pop	r29
    190c:	cf 91       	pop	r28
    190e:	08 95       	ret

00001910 <xTaskRemoveFromEventList>:
	
#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xTaskRemoveFromEventList( const xList * const pxEventList )
{
    1910:	0f 93       	push	r16
    1912:	1f 93       	push	r17
    1914:	cf 93       	push	r28
    1916:	df 93       	push	r29
	get called - the lock count on the queue will get modified instead.  This
	means we can always expect exclusive access to the event list here.
	
	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
    1918:	dc 01       	movw	r26, r24
    191a:	15 96       	adiw	r26, 0x05	; 5
    191c:	ed 91       	ld	r30, X+
    191e:	fc 91       	ld	r31, X
    1920:	16 97       	sbiw	r26, 0x06	; 6
    1922:	06 81       	ldd	r16, Z+6	; 0x06
    1924:	17 81       	ldd	r17, Z+7	; 0x07
	configASSERT( pxUnblockedTCB );
	vListRemove( &( pxUnblockedTCB->xEventListItem ) );
    1926:	e8 01       	movw	r28, r16
    1928:	2c 96       	adiw	r28, 0x0c	; 12
    192a:	ce 01       	movw	r24, r28
    192c:	0e 94 1e 03 	call	0x63c	; 0x63c <vListRemove>

	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    1930:	80 91 0d 03 	lds	r24, 0x030D
    1934:	88 23       	and	r24, r24
    1936:	e9 f4       	brne	.+58     	; 0x1972 <xTaskRemoveFromEventList+0x62>
	{
		vListRemove( &( pxUnblockedTCB->xGenericListItem ) );
    1938:	e8 01       	movw	r28, r16
    193a:	22 96       	adiw	r28, 0x02	; 2
    193c:	ce 01       	movw	r24, r28
    193e:	0e 94 1e 03 	call	0x63c	; 0x63c <vListRemove>
		prvAddTaskToReadyQueue( pxUnblockedTCB );
    1942:	f8 01       	movw	r30, r16
    1944:	86 89       	ldd	r24, Z+22	; 0x16
    1946:	90 91 0f 03 	lds	r25, 0x030F
    194a:	98 17       	cp	r25, r24
    194c:	10 f4       	brcc	.+4      	; 0x1952 <xTaskRemoveFromEventList+0x42>
    194e:	80 93 0f 03 	sts	0x030F, r24
    1952:	90 e0       	ldi	r25, 0x00	; 0
    1954:	9c 01       	movw	r18, r24
    1956:	22 0f       	add	r18, r18
    1958:	33 1f       	adc	r19, r19
    195a:	22 0f       	add	r18, r18
    195c:	33 1f       	adc	r19, r19
    195e:	22 0f       	add	r18, r18
    1960:	33 1f       	adc	r19, r19
    1962:	82 0f       	add	r24, r18
    1964:	93 1f       	adc	r25, r19
    1966:	86 5e       	subi	r24, 0xE6	; 230
    1968:	9c 4f       	sbci	r25, 0xFC	; 252
    196a:	be 01       	movw	r22, r28
    196c:	0e 94 b8 02 	call	0x570	; 0x570 <vListInsertEnd>
    1970:	05 c0       	rjmp	.+10     	; 0x197c <xTaskRemoveFromEventList+0x6c>
	}
	else
	{
		/* We cannot access the delayed or ready lists, so will hold this
		task pending until the scheduler is resumed. */
		vListInsertEnd( ( xList * ) &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
    1972:	87 e4       	ldi	r24, 0x47	; 71
    1974:	93 e0       	ldi	r25, 0x03	; 3
    1976:	be 01       	movw	r22, r28
    1978:	0e 94 b8 02 	call	0x570	; 0x570 <vListInsertEnd>
	}

	if( pxUnblockedTCB->uxPriority >= pxCurrentTCB->uxPriority )
    197c:	e0 91 08 03 	lds	r30, 0x0308
    1980:	f0 91 09 03 	lds	r31, 0x0309
	else
	{
		xReturn = pdFALSE;
	}

	return xReturn;
    1984:	81 e0       	ldi	r24, 0x01	; 1
    1986:	d8 01       	movw	r26, r16
    1988:	56 96       	adiw	r26, 0x16	; 22
    198a:	2c 91       	ld	r18, X
    198c:	56 97       	sbiw	r26, 0x16	; 22
    198e:	96 89       	ldd	r25, Z+22	; 0x16
    1990:	29 17       	cp	r18, r25
    1992:	08 f4       	brcc	.+2      	; 0x1996 <xTaskRemoveFromEventList+0x86>
    1994:	80 e0       	ldi	r24, 0x00	; 0
}
    1996:	df 91       	pop	r29
    1998:	cf 91       	pop	r28
    199a:	1f 91       	pop	r17
    199c:	0f 91       	pop	r16
    199e:	08 95       	ret

000019a0 <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( xTimeOutType * const pxTimeOut )
{
    19a0:	fc 01       	movw	r30, r24
	configASSERT( pxTimeOut );
	pxTimeOut->xOverflowCount = xNumOfOverflows;
    19a2:	80 91 0a 03 	lds	r24, 0x030A
    19a6:	80 83       	st	Z, r24
	pxTimeOut->xTimeOnEntering = xTickCount;
    19a8:	80 91 10 03 	lds	r24, 0x0310
    19ac:	90 91 11 03 	lds	r25, 0x0311
    19b0:	92 83       	std	Z+2, r25	; 0x02
    19b2:	81 83       	std	Z+1, r24	; 0x01
}
    19b4:	08 95       	ret

000019b6 <xTaskCheckForTimeOut>:
/*-----------------------------------------------------------*/

portBASE_TYPE xTaskCheckForTimeOut( xTimeOutType * const pxTimeOut, portTickType * const pxTicksToWait )
{
    19b6:	fc 01       	movw	r30, r24
portBASE_TYPE xReturn;

	configASSERT( pxTimeOut );
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
    19b8:	0f b6       	in	r0, 0x3f	; 63
    19ba:	f8 94       	cli
    19bc:	0f 92       	push	r0
				xReturn = pdFALSE;
			}
			else /* We are not blocking indefinitely, perform the checks below. */
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( ( portTickType ) xTickCount >= ( portTickType ) pxTimeOut->xTimeOnEntering ) )
    19be:	80 91 0a 03 	lds	r24, 0x030A
    19c2:	90 81       	ld	r25, Z
    19c4:	98 17       	cp	r25, r24
    19c6:	49 f0       	breq	.+18     	; 0x19da <xTaskCheckForTimeOut+0x24>
    19c8:	80 91 10 03 	lds	r24, 0x0310
    19cc:	90 91 11 03 	lds	r25, 0x0311
    19d0:	21 81       	ldd	r18, Z+1	; 0x01
    19d2:	32 81       	ldd	r19, Z+2	; 0x02
    19d4:	82 17       	cp	r24, r18
    19d6:	93 07       	cpc	r25, r19
    19d8:	f0 f4       	brcc	.+60     	; 0x1a16 <xTaskCheckForTimeOut+0x60>
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
		}
		else if( ( ( portTickType ) ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering ) ) < ( portTickType ) *pxTicksToWait )
    19da:	80 91 10 03 	lds	r24, 0x0310
    19de:	90 91 11 03 	lds	r25, 0x0311
    19e2:	21 81       	ldd	r18, Z+1	; 0x01
    19e4:	32 81       	ldd	r19, Z+2	; 0x02
    19e6:	db 01       	movw	r26, r22
    19e8:	4d 91       	ld	r20, X+
    19ea:	5c 91       	ld	r21, X
    19ec:	11 97       	sbiw	r26, 0x01	; 1
    19ee:	82 1b       	sub	r24, r18
    19f0:	93 0b       	sbc	r25, r19
    19f2:	84 17       	cp	r24, r20
    19f4:	95 07       	cpc	r25, r21
    19f6:	88 f4       	brcc	.+34     	; 0x1a1a <xTaskCheckForTimeOut+0x64>
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering );
    19f8:	80 91 10 03 	lds	r24, 0x0310
    19fc:	90 91 11 03 	lds	r25, 0x0311
    1a00:	28 1b       	sub	r18, r24
    1a02:	39 0b       	sbc	r19, r25
    1a04:	24 0f       	add	r18, r20
    1a06:	35 1f       	adc	r19, r21
    1a08:	2d 93       	st	X+, r18
    1a0a:	3c 93       	st	X, r19
			vTaskSetTimeOutState( pxTimeOut );
    1a0c:	cf 01       	movw	r24, r30
    1a0e:	0e 94 d0 0c 	call	0x19a0	; 0x19a0 <vTaskSetTimeOutState>
			xReturn = pdFALSE;
    1a12:	80 e0       	ldi	r24, 0x00	; 0
    1a14:	03 c0       	rjmp	.+6      	; 0x1a1c <xTaskCheckForTimeOut+0x66>
		{
			/* The tick count is greater than the time at which vTaskSetTimeout()
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
    1a16:	81 e0       	ldi	r24, 0x01	; 1
    1a18:	01 c0       	rjmp	.+2      	; 0x1a1c <xTaskCheckForTimeOut+0x66>
			vTaskSetTimeOutState( pxTimeOut );
			xReturn = pdFALSE;
		}
		else
		{
			xReturn = pdTRUE;
    1a1a:	81 e0       	ldi	r24, 0x01	; 1
		}
	}
	taskEXIT_CRITICAL();
    1a1c:	0f 90       	pop	r0
    1a1e:	0f be       	out	0x3f, r0	; 63

	return xReturn;
}
    1a20:	08 95       	ret

00001a22 <vTaskMissedYield>:
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
	xMissedYield = pdTRUE;
    1a22:	81 e0       	ldi	r24, 0x01	; 1
    1a24:	80 93 0b 03 	sts	0x030B, r24
}
    1a28:	08 95       	ret

00001a2a <memcpy>:
    1a2a:	fb 01       	movw	r30, r22
    1a2c:	dc 01       	movw	r26, r24
    1a2e:	02 c0       	rjmp	.+4      	; 0x1a34 <memcpy+0xa>
    1a30:	01 90       	ld	r0, Z+
    1a32:	0d 92       	st	X+, r0
    1a34:	41 50       	subi	r20, 0x01	; 1
    1a36:	50 40       	sbci	r21, 0x00	; 0
    1a38:	d8 f7       	brcc	.-10     	; 0x1a30 <memcpy+0x6>
    1a3a:	08 95       	ret

00001a3c <memset>:
    1a3c:	dc 01       	movw	r26, r24
    1a3e:	01 c0       	rjmp	.+2      	; 0x1a42 <memset+0x6>
    1a40:	6d 93       	st	X+, r22
    1a42:	41 50       	subi	r20, 0x01	; 1
    1a44:	50 40       	sbci	r21, 0x00	; 0
    1a46:	e0 f7       	brcc	.-8      	; 0x1a40 <memset+0x4>
    1a48:	08 95       	ret

00001a4a <strncpy>:
    1a4a:	fb 01       	movw	r30, r22
    1a4c:	dc 01       	movw	r26, r24
    1a4e:	41 50       	subi	r20, 0x01	; 1
    1a50:	50 40       	sbci	r21, 0x00	; 0
    1a52:	48 f0       	brcs	.+18     	; 0x1a66 <strncpy+0x1c>
    1a54:	01 90       	ld	r0, Z+
    1a56:	0d 92       	st	X+, r0
    1a58:	00 20       	and	r0, r0
    1a5a:	c9 f7       	brne	.-14     	; 0x1a4e <strncpy+0x4>
    1a5c:	01 c0       	rjmp	.+2      	; 0x1a60 <strncpy+0x16>
    1a5e:	1d 92       	st	X+, r1
    1a60:	41 50       	subi	r20, 0x01	; 1
    1a62:	50 40       	sbci	r21, 0x00	; 0
    1a64:	e0 f7       	brcc	.-8      	; 0x1a5e <strncpy+0x14>
    1a66:	08 95       	ret

00001a68 <_exit>:
    1a68:	f8 94       	cli

00001a6a <__stop_program>:
    1a6a:	ff cf       	rjmp	.-2      	; 0x1a6a <__stop_program>
