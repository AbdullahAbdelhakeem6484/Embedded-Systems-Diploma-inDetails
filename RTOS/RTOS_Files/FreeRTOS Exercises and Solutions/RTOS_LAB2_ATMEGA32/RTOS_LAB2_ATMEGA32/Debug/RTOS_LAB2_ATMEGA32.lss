
RTOS_LAB2_ATMEGA32.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00001de6  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         0000001e  00800060  00001de6  00001e7a  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          000002e7  0080007e  0080007e  00001e98  2**0
                  ALLOC
  3 .stab         00000888  00000000  00000000  00001e98  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      000001d8  00000000  00000000  00002720  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_aranges 00000100  00000000  00000000  000028f8  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_pubnames 00000623  00000000  00000000  000029f8  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_info   000024e3  00000000  00000000  0000301b  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_abbrev 00000ba0  00000000  00000000  000054fe  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_line   000021e7  00000000  00000000  0000609e  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_frame  000004c0  00000000  00000000  00008288  2**2
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_str    00000fe1  00000000  00000000  00008748  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_loc    000017ee  00000000  00000000  00009729  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_pubtypes 0000044b  00000000  00000000  0000af17  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_ranges 00000090  00000000  00000000  0000b362  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 2a 00 	jmp	0x54	; 0x54 <__ctors_end>
       4:	0c 94 8c 08 	jmp	0x1118	; 0x1118 <__vector_1>
       8:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
       c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      10:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      14:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      18:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      1c:	0c 94 1f 05 	jmp	0xa3e	; 0xa3e <__vector_7>
      20:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      24:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      28:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      2c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      30:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      34:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      38:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      3c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      40:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      44:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      48:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      4c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      50:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>

00000054 <__ctors_end>:
      54:	11 24       	eor	r1, r1
      56:	1f be       	out	0x3f, r1	; 63
      58:	cf e5       	ldi	r28, 0x5F	; 95
      5a:	d8 e0       	ldi	r29, 0x08	; 8
      5c:	de bf       	out	0x3e, r29	; 62
      5e:	cd bf       	out	0x3d, r28	; 61

00000060 <__do_copy_data>:
      60:	10 e0       	ldi	r17, 0x00	; 0
      62:	a0 e6       	ldi	r26, 0x60	; 96
      64:	b0 e0       	ldi	r27, 0x00	; 0
      66:	e6 ee       	ldi	r30, 0xE6	; 230
      68:	fd e1       	ldi	r31, 0x1D	; 29
      6a:	02 c0       	rjmp	.+4      	; 0x70 <__do_copy_data+0x10>
      6c:	05 90       	lpm	r0, Z+
      6e:	0d 92       	st	X+, r0
      70:	ae 37       	cpi	r26, 0x7E	; 126
      72:	b1 07       	cpc	r27, r17
      74:	d9 f7       	brne	.-10     	; 0x6c <__do_copy_data+0xc>

00000076 <__do_clear_bss>:
      76:	13 e0       	ldi	r17, 0x03	; 3
      78:	ae e7       	ldi	r26, 0x7E	; 126
      7a:	b0 e0       	ldi	r27, 0x00	; 0
      7c:	01 c0       	rjmp	.+2      	; 0x80 <.do_clear_bss_start>

0000007e <.do_clear_bss_loop>:
      7e:	1d 92       	st	X+, r1

00000080 <.do_clear_bss_start>:
      80:	a5 36       	cpi	r26, 0x65	; 101
      82:	b1 07       	cpc	r27, r17
      84:	e1 f7       	brne	.-8      	; 0x7e <.do_clear_bss_loop>
      86:	0e 94 53 08 	call	0x10a6	; 0x10a6 <main>
      8a:	0c 94 f1 0e 	jmp	0x1de2	; 0x1de2 <_exit>

0000008e <__bad_interrupt>:
      8e:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000092 <xCoRoutineCreate>:
static void prvCheckDelayedList( void );

/*-----------------------------------------------------------*/

signed portBASE_TYPE xCoRoutineCreate( crCOROUTINE_CODE pxCoRoutineCode, unsigned portBASE_TYPE uxPriority, unsigned portBASE_TYPE uxIndex )
{
      92:	af 92       	push	r10
      94:	bf 92       	push	r11
      96:	cf 92       	push	r12
      98:	df 92       	push	r13
      9a:	ef 92       	push	r14
      9c:	ff 92       	push	r15
      9e:	0f 93       	push	r16
      a0:	1f 93       	push	r17
      a2:	cf 93       	push	r28
      a4:	df 93       	push	r29
      a6:	6c 01       	movw	r12, r24
      a8:	f6 2e       	mov	r15, r22
      aa:	e4 2e       	mov	r14, r20
signed portBASE_TYPE xReturn;
corCRCB *pxCoRoutine;

	/* Allocate the memory that will store the co-routine control block. */
	pxCoRoutine = ( corCRCB * ) pvPortMalloc( sizeof( corCRCB ) );
      ac:	8a e1       	ldi	r24, 0x1A	; 26
      ae:	90 e0       	ldi	r25, 0x00	; 0
      b0:	0e 94 80 02 	call	0x500	; 0x500 <pvPortMalloc>
      b4:	08 2f       	mov	r16, r24
      b6:	19 2f       	mov	r17, r25
	if( pxCoRoutine )
      b8:	01 15       	cp	r16, r1
      ba:	11 05       	cpc	r17, r1
      bc:	09 f4       	brne	.+2      	; 0xc0 <xCoRoutineCreate+0x2e>
      be:	63 c0       	rjmp	.+198    	; 0x186 <xCoRoutineCreate+0xf4>
	{
		/* If pxCurrentCoRoutine is NULL then this is the first co-routine to
		be created and the co-routine data structures need initialising. */
		if( pxCurrentCoRoutine == NULL )
      c0:	80 91 7e 00 	lds	r24, 0x007E
      c4:	90 91 7f 00 	lds	r25, 0x007F
      c8:	00 97       	sbiw	r24, 0x00	; 0
      ca:	39 f5       	brne	.+78     	; 0x11a <xCoRoutineCreate+0x88>
		{
			pxCurrentCoRoutine = pxCoRoutine;
      cc:	10 93 7f 00 	sts	0x007F, r17
      d0:	00 93 7e 00 	sts	0x007E, r16
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = 0; uxPriority < configMAX_CO_ROUTINE_PRIORITIES; uxPriority++ )
	{
		vListInitialise( ( xList * ) &( pxReadyCoRoutineLists[ uxPriority ] ) );
      d4:	ca e8       	ldi	r28, 0x8A	; 138
      d6:	d0 e0       	ldi	r29, 0x00	; 0
      d8:	ce 01       	movw	r24, r28
      da:	0e 94 4c 03 	call	0x698	; 0x698 <vListInitialise>
      de:	ce 01       	movw	r24, r28
      e0:	09 96       	adiw	r24, 0x09	; 9
      e2:	0e 94 4c 03 	call	0x698	; 0x698 <vListInitialise>
	}

	vListInitialise( ( xList * ) &xDelayedCoRoutineList1 );
      e6:	c6 ea       	ldi	r28, 0xA6	; 166
      e8:	d0 e0       	ldi	r29, 0x00	; 0
      ea:	ce 01       	movw	r24, r28
      ec:	0e 94 4c 03 	call	0x698	; 0x698 <vListInitialise>
	vListInitialise( ( xList * ) &xDelayedCoRoutineList2 );
      f0:	0f 2e       	mov	r0, r31
      f2:	ff ea       	ldi	r31, 0xAF	; 175
      f4:	af 2e       	mov	r10, r31
      f6:	f0 e0       	ldi	r31, 0x00	; 0
      f8:	bf 2e       	mov	r11, r31
      fa:	f0 2d       	mov	r31, r0
      fc:	c5 01       	movw	r24, r10
      fe:	0e 94 4c 03 	call	0x698	; 0x698 <vListInitialise>
	vListInitialise( ( xList * ) &xPendingReadyCoRoutineList );
     102:	80 e8       	ldi	r24, 0x80	; 128
     104:	90 e0       	ldi	r25, 0x00	; 0
     106:	0e 94 4c 03 	call	0x698	; 0x698 <vListInitialise>

	/* Start with pxDelayedCoRoutineList using list1 and the
	pxOverflowDelayedCoRoutineList using list2. */
	pxDelayedCoRoutineList = &xDelayedCoRoutineList1;
     10a:	d0 93 a3 00 	sts	0x00A3, r29
     10e:	c0 93 a2 00 	sts	0x00A2, r28
	pxOverflowDelayedCoRoutineList = &xDelayedCoRoutineList2;
     112:	b0 92 a5 00 	sts	0x00A5, r11
     116:	a0 92 a4 00 	sts	0x00A4, r10
     11a:	ff 20       	and	r15, r15
     11c:	11 f0       	breq	.+4      	; 0x122 <xCoRoutineCreate+0x90>
     11e:	ff 24       	eor	r15, r15
     120:	f3 94       	inc	r15
		{
			uxPriority = configMAX_CO_ROUTINE_PRIORITIES - 1;
		}

		/* Fill out the co-routine control block from the function parameters. */
		pxCoRoutine->uxState = corINITIAL_STATE;
     122:	f8 01       	movw	r30, r16
     124:	11 8e       	std	Z+25, r1	; 0x19
     126:	10 8e       	std	Z+24, r1	; 0x18
		pxCoRoutine->uxPriority = uxPriority;
     128:	f6 8a       	std	Z+22, r15	; 0x16
		pxCoRoutine->uxIndex = uxIndex;
     12a:	e7 8a       	std	Z+23, r14	; 0x17
		pxCoRoutine->pxCoRoutineFunction = pxCoRoutineCode;
     12c:	e8 01       	movw	r28, r16
     12e:	c9 92       	st	Y+, r12
     130:	d9 92       	st	Y+, r13

		/* Initialise all the other co-routine control block parameters. */
		vListInitialiseItem( &( pxCoRoutine->xGenericListItem ) );
     132:	ce 01       	movw	r24, r28
     134:	0e 94 5a 03 	call	0x6b4	; 0x6b4 <vListInitialiseItem>
		vListInitialiseItem( &( pxCoRoutine->xEventListItem ) );
     138:	c8 01       	movw	r24, r16
     13a:	0c 96       	adiw	r24, 0x0c	; 12
     13c:	0e 94 5a 03 	call	0x6b4	; 0x6b4 <vListInitialiseItem>

		/* Set the co-routine control block as a link back from the xListItem.
		This is so we can get back to the containing CRCB from a generic item
		in a list. */
		listSET_LIST_ITEM_OWNER( &( pxCoRoutine->xGenericListItem ), pxCoRoutine );
     140:	f8 01       	movw	r30, r16
     142:	11 87       	std	Z+9, r17	; 0x09
     144:	00 87       	std	Z+8, r16	; 0x08
		listSET_LIST_ITEM_OWNER( &( pxCoRoutine->xEventListItem ), pxCoRoutine );
     146:	13 8b       	std	Z+19, r17	; 0x13
     148:	02 8b       	std	Z+18, r16	; 0x12
	
		/* Event lists are always in priority order. */
		listSET_LIST_ITEM_VALUE( &( pxCoRoutine->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) uxPriority );
     14a:	82 e0       	ldi	r24, 0x02	; 2
     14c:	90 e0       	ldi	r25, 0x00	; 0
     14e:	8f 19       	sub	r24, r15
     150:	91 09       	sbc	r25, r1
     152:	95 87       	std	Z+13, r25	; 0x0d
     154:	84 87       	std	Z+12, r24	; 0x0c
		
		/* Now the co-routine has been initialised it can be added to the ready
		list at the correct priority. */
		prvAddCoRoutineToReadyQueue( pxCoRoutine );
     156:	86 89       	ldd	r24, Z+22	; 0x16
     158:	90 91 89 00 	lds	r25, 0x0089
     15c:	98 17       	cp	r25, r24
     15e:	10 f4       	brcc	.+4      	; 0x164 <xCoRoutineCreate+0xd2>
     160:	80 93 89 00 	sts	0x0089, r24
     164:	90 e0       	ldi	r25, 0x00	; 0
     166:	9c 01       	movw	r18, r24
     168:	22 0f       	add	r18, r18
     16a:	33 1f       	adc	r19, r19
     16c:	22 0f       	add	r18, r18
     16e:	33 1f       	adc	r19, r19
     170:	22 0f       	add	r18, r18
     172:	33 1f       	adc	r19, r19
     174:	82 0f       	add	r24, r18
     176:	93 1f       	adc	r25, r19
     178:	86 57       	subi	r24, 0x76	; 118
     17a:	9f 4f       	sbci	r25, 0xFF	; 255
     17c:	be 01       	movw	r22, r28
     17e:	0e 94 5e 03 	call	0x6bc	; 0x6bc <vListInsertEnd>

		xReturn = pdPASS;
     182:	81 e0       	ldi	r24, 0x01	; 1
     184:	01 c0       	rjmp	.+2      	; 0x188 <xCoRoutineCreate+0xf6>
	}
	else
	{		
		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
     186:	8f ef       	ldi	r24, 0xFF	; 255
	}
	
	return xReturn;	
}
     188:	df 91       	pop	r29
     18a:	cf 91       	pop	r28
     18c:	1f 91       	pop	r17
     18e:	0f 91       	pop	r16
     190:	ff 90       	pop	r15
     192:	ef 90       	pop	r14
     194:	df 90       	pop	r13
     196:	cf 90       	pop	r12
     198:	bf 90       	pop	r11
     19a:	af 90       	pop	r10
     19c:	08 95       	ret

0000019e <vCoRoutineAddToDelayedList>:
/*-----------------------------------------------------------*/

void vCoRoutineAddToDelayedList( portTickType xTicksToDelay, xList *pxEventList )
{
     19e:	0f 93       	push	r16
     1a0:	1f 93       	push	r17
     1a2:	cf 93       	push	r28
     1a4:	df 93       	push	r29
     1a6:	8b 01       	movw	r16, r22
portTickType xTimeToWake;

	/* Calculate the time to wake - this may overflow but this is
	not a problem. */
	xTimeToWake = xCoRoutineTickCount + xTicksToDelay;
     1a8:	c0 91 a0 00 	lds	r28, 0x00A0
     1ac:	d0 91 a1 00 	lds	r29, 0x00A1
     1b0:	c8 0f       	add	r28, r24
     1b2:	d9 1f       	adc	r29, r25

	/* We must remove ourselves from the ready list before adding
	ourselves to the blocked list as the same list item is used for
	both lists. */
	vListRemove( ( xListItem * ) &( pxCurrentCoRoutine->xGenericListItem ) );
     1b4:	80 91 7e 00 	lds	r24, 0x007E
     1b8:	90 91 7f 00 	lds	r25, 0x007F
     1bc:	02 96       	adiw	r24, 0x02	; 2
     1be:	0e 94 c4 03 	call	0x788	; 0x788 <vListRemove>

	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentCoRoutine->xGenericListItem ), xTimeToWake );
     1c2:	60 91 7e 00 	lds	r22, 0x007E
     1c6:	70 91 7f 00 	lds	r23, 0x007F
     1ca:	fb 01       	movw	r30, r22
     1cc:	d3 83       	std	Z+3, r29	; 0x03
     1ce:	c2 83       	std	Z+2, r28	; 0x02

	if( xTimeToWake < xCoRoutineTickCount )
     1d0:	80 91 a0 00 	lds	r24, 0x00A0
     1d4:	90 91 a1 00 	lds	r25, 0x00A1
     1d8:	c8 17       	cp	r28, r24
     1da:	d9 07       	cpc	r29, r25
     1dc:	48 f4       	brcc	.+18     	; 0x1f0 <vCoRoutineAddToDelayedList+0x52>
	{
		/* Wake time has overflowed.  Place this item in the
		overflow list. */
		vListInsert( ( xList * ) pxOverflowDelayedCoRoutineList, ( xListItem * ) &( pxCurrentCoRoutine->xGenericListItem ) );
     1de:	6e 5f       	subi	r22, 0xFE	; 254
     1e0:	7f 4f       	sbci	r23, 0xFF	; 255
     1e2:	80 91 a4 00 	lds	r24, 0x00A4
     1e6:	90 91 a5 00 	lds	r25, 0x00A5
     1ea:	0e 94 85 03 	call	0x70a	; 0x70a <vListInsert>
     1ee:	08 c0       	rjmp	.+16     	; 0x200 <vCoRoutineAddToDelayedList+0x62>
	}
	else
	{
		/* The wake time has not overflowed, so we can use the
		current block list. */
		vListInsert( ( xList * ) pxDelayedCoRoutineList, ( xListItem * ) &( pxCurrentCoRoutine->xGenericListItem ) );
     1f0:	6e 5f       	subi	r22, 0xFE	; 254
     1f2:	7f 4f       	sbci	r23, 0xFF	; 255
     1f4:	80 91 a2 00 	lds	r24, 0x00A2
     1f8:	90 91 a3 00 	lds	r25, 0x00A3
     1fc:	0e 94 85 03 	call	0x70a	; 0x70a <vListInsert>
	}

	if( pxEventList )
     200:	01 15       	cp	r16, r1
     202:	11 05       	cpc	r17, r1
     204:	49 f0       	breq	.+18     	; 0x218 <vCoRoutineAddToDelayedList+0x7a>
	{
		/* Also add the co-routine to an event list.  If this is done then the
		function must be called with interrupts disabled. */
		vListInsert( pxEventList, &( pxCurrentCoRoutine->xEventListItem ) );
     206:	60 91 7e 00 	lds	r22, 0x007E
     20a:	70 91 7f 00 	lds	r23, 0x007F
     20e:	64 5f       	subi	r22, 0xF4	; 244
     210:	7f 4f       	sbci	r23, 0xFF	; 255
     212:	c8 01       	movw	r24, r16
     214:	0e 94 85 03 	call	0x70a	; 0x70a <vListInsert>
	}
}
     218:	df 91       	pop	r29
     21a:	cf 91       	pop	r28
     21c:	1f 91       	pop	r17
     21e:	0f 91       	pop	r16
     220:	08 95       	ret

00000222 <vCoRoutineSchedule>:
	xLastTickCount = xCoRoutineTickCount;
}
/*-----------------------------------------------------------*/

void vCoRoutineSchedule( void )
{
     222:	cf 92       	push	r12
     224:	df 92       	push	r13
     226:	ef 92       	push	r14
     228:	ff 92       	push	r15
     22a:	0f 93       	push	r16
     22c:	1f 93       	push	r17
     22e:	cf 93       	push	r28
     230:	df 93       	push	r29
static void prvCheckPendingReadyList( void )
{
	/* Are there any co-routines waiting to get moved to the ready list?  These
	are co-routines that have been readied by an ISR.  The ISR cannot access
	the	ready lists itself. */
	while( listLIST_IS_EMPTY( &xPendingReadyCoRoutineList ) == pdFALSE )
     232:	80 91 80 00 	lds	r24, 0x0080
     236:	88 23       	and	r24, r24
     238:	b9 f1       	breq	.+110    	; 0x2a8 <vCoRoutineSchedule+0x86>
		corCRCB *pxUnblockedCRCB;

		/* The pending ready list can be accessed by an ISR. */
		portDISABLE_INTERRUPTS();
		{	
			pxUnblockedCRCB = ( corCRCB * ) listGET_OWNER_OF_HEAD_ENTRY( (&xPendingReadyCoRoutineList) );			
     23a:	0f 2e       	mov	r0, r31
     23c:	f5 e8       	ldi	r31, 0x85	; 133
     23e:	ef 2e       	mov	r14, r31
     240:	f0 e0       	ldi	r31, 0x00	; 0
     242:	ff 2e       	mov	r15, r31
     244:	f0 2d       	mov	r31, r0
static void prvCheckPendingReadyList( void )
{
	/* Are there any co-routines waiting to get moved to the ready list?  These
	are co-routines that have been readied by an ISR.  The ISR cannot access
	the	ready lists itself. */
	while( listLIST_IS_EMPTY( &xPendingReadyCoRoutineList ) == pdFALSE )
     246:	0f 2e       	mov	r0, r31
     248:	f0 e8       	ldi	r31, 0x80	; 128
     24a:	cf 2e       	mov	r12, r31
     24c:	f0 e0       	ldi	r31, 0x00	; 0
     24e:	df 2e       	mov	r13, r31
     250:	f0 2d       	mov	r31, r0
	{
		corCRCB *pxUnblockedCRCB;

		/* The pending ready list can be accessed by an ISR. */
		portDISABLE_INTERRUPTS();
     252:	f8 94       	cli
		{	
			pxUnblockedCRCB = ( corCRCB * ) listGET_OWNER_OF_HEAD_ENTRY( (&xPendingReadyCoRoutineList) );			
     254:	d7 01       	movw	r26, r14
     256:	ed 91       	ld	r30, X+
     258:	fc 91       	ld	r31, X
     25a:	c6 81       	ldd	r28, Z+6	; 0x06
     25c:	d7 81       	ldd	r29, Z+7	; 0x07
			vListRemove( &( pxUnblockedCRCB->xEventListItem ) );
     25e:	ce 01       	movw	r24, r28
     260:	0c 96       	adiw	r24, 0x0c	; 12
     262:	0e 94 c4 03 	call	0x788	; 0x788 <vListRemove>
		}
		portENABLE_INTERRUPTS();
     266:	78 94       	sei

		vListRemove( &( pxUnblockedCRCB->xGenericListItem ) );
     268:	8e 01       	movw	r16, r28
     26a:	0e 5f       	subi	r16, 0xFE	; 254
     26c:	1f 4f       	sbci	r17, 0xFF	; 255
     26e:	c8 01       	movw	r24, r16
     270:	0e 94 c4 03 	call	0x788	; 0x788 <vListRemove>
		prvAddCoRoutineToReadyQueue( pxUnblockedCRCB );	
     274:	8e 89       	ldd	r24, Y+22	; 0x16
     276:	90 91 89 00 	lds	r25, 0x0089
     27a:	98 17       	cp	r25, r24
     27c:	10 f4       	brcc	.+4      	; 0x282 <vCoRoutineSchedule+0x60>
     27e:	80 93 89 00 	sts	0x0089, r24
     282:	90 e0       	ldi	r25, 0x00	; 0
     284:	9c 01       	movw	r18, r24
     286:	22 0f       	add	r18, r18
     288:	33 1f       	adc	r19, r19
     28a:	22 0f       	add	r18, r18
     28c:	33 1f       	adc	r19, r19
     28e:	22 0f       	add	r18, r18
     290:	33 1f       	adc	r19, r19
     292:	82 0f       	add	r24, r18
     294:	93 1f       	adc	r25, r19
     296:	86 57       	subi	r24, 0x76	; 118
     298:	9f 4f       	sbci	r25, 0xFF	; 255
     29a:	b8 01       	movw	r22, r16
     29c:	0e 94 5e 03 	call	0x6bc	; 0x6bc <vListInsertEnd>
static void prvCheckPendingReadyList( void )
{
	/* Are there any co-routines waiting to get moved to the ready list?  These
	are co-routines that have been readied by an ISR.  The ISR cannot access
	the	ready lists itself. */
	while( listLIST_IS_EMPTY( &xPendingReadyCoRoutineList ) == pdFALSE )
     2a0:	f6 01       	movw	r30, r12
     2a2:	80 81       	ld	r24, Z
     2a4:	88 23       	and	r24, r24
     2a6:	a9 f6       	brne	.-86     	; 0x252 <vCoRoutineSchedule+0x30>

static void prvCheckDelayedList( void )
{
corCRCB *pxCRCB;

	xPassedTicks = xTaskGetTickCount() - xLastTickCount;
     2a8:	0e 94 40 0b 	call	0x1680	; 0x1680 <xTaskGetTickCount>
     2ac:	20 91 9c 00 	lds	r18, 0x009C
     2b0:	30 91 9d 00 	lds	r19, 0x009D
     2b4:	82 1b       	sub	r24, r18
     2b6:	93 0b       	sbc	r25, r19
     2b8:	90 93 9f 00 	sts	0x009F, r25
     2bc:	80 93 9e 00 	sts	0x009E, r24
     2c0:	74 c0       	rjmp	.+232    	; 0x3aa <vCoRoutineSchedule+0x188>
	while( xPassedTicks )
	{
		xCoRoutineTickCount++;
     2c2:	20 91 a0 00 	lds	r18, 0x00A0
     2c6:	30 91 a1 00 	lds	r19, 0x00A1
     2ca:	2f 5f       	subi	r18, 0xFF	; 255
     2cc:	3f 4f       	sbci	r19, 0xFF	; 255
     2ce:	30 93 a1 00 	sts	0x00A1, r19
     2d2:	20 93 a0 00 	sts	0x00A0, r18
		xPassedTicks--;
     2d6:	01 97       	sbiw	r24, 0x01	; 1
     2d8:	90 93 9f 00 	sts	0x009F, r25
     2dc:	80 93 9e 00 	sts	0x009E, r24

		/* If the tick count has overflowed we need to swap the ready lists. */
		if( xCoRoutineTickCount == 0 )
     2e0:	21 15       	cp	r18, r1
     2e2:	31 05       	cpc	r19, r1
     2e4:	81 f4       	brne	.+32     	; 0x306 <vCoRoutineSchedule+0xe4>
		{
			xList * pxTemp;

			/* Tick count has overflowed so we need to swap the delay lists.  If there are
			any items in pxDelayedCoRoutineList here then there is an error! */
			pxTemp = pxDelayedCoRoutineList;
     2e6:	80 91 a2 00 	lds	r24, 0x00A2
     2ea:	90 91 a3 00 	lds	r25, 0x00A3
			pxDelayedCoRoutineList = pxOverflowDelayedCoRoutineList;
     2ee:	20 91 a4 00 	lds	r18, 0x00A4
     2f2:	30 91 a5 00 	lds	r19, 0x00A5
     2f6:	30 93 a3 00 	sts	0x00A3, r19
     2fa:	20 93 a2 00 	sts	0x00A2, r18
			pxOverflowDelayedCoRoutineList = pxTemp;
     2fe:	90 93 a5 00 	sts	0x00A5, r25
     302:	80 93 a4 00 	sts	0x00A4, r24
		}

		/* See if this tick has made a timeout expire. */
		while( listLIST_IS_EMPTY( pxDelayedCoRoutineList ) == pdFALSE )
     306:	e0 91 a2 00 	lds	r30, 0x00A2
     30a:	f0 91 a3 00 	lds	r31, 0x00A3
     30e:	80 81       	ld	r24, Z
     310:	88 23       	and	r24, r24
     312:	09 f4       	brne	.+2      	; 0x316 <vCoRoutineSchedule+0xf4>
     314:	4a c0       	rjmp	.+148    	; 0x3aa <vCoRoutineSchedule+0x188>
		{
			pxCRCB = ( corCRCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedCoRoutineList );
     316:	05 80       	ldd	r0, Z+5	; 0x05
     318:	f6 81       	ldd	r31, Z+6	; 0x06
     31a:	e0 2d       	mov	r30, r0
     31c:	c6 81       	ldd	r28, Z+6	; 0x06
     31e:	d7 81       	ldd	r29, Z+7	; 0x07

			if( xCoRoutineTickCount < listGET_LIST_ITEM_VALUE( &( pxCRCB->xGenericListItem ) ) )				
     320:	2a 81       	ldd	r18, Y+2	; 0x02
     322:	3b 81       	ldd	r19, Y+3	; 0x03
     324:	80 91 a0 00 	lds	r24, 0x00A0
     328:	90 91 a1 00 	lds	r25, 0x00A1
     32c:	82 17       	cp	r24, r18
     32e:	93 07       	cpc	r25, r19
     330:	78 f4       	brcc	.+30     	; 0x350 <vCoRoutineSchedule+0x12e>
     332:	3b c0       	rjmp	.+118    	; 0x3aa <vCoRoutineSchedule+0x188>
		}

		/* See if this tick has made a timeout expire. */
		while( listLIST_IS_EMPTY( pxDelayedCoRoutineList ) == pdFALSE )
		{
			pxCRCB = ( corCRCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedCoRoutineList );
     334:	05 80       	ldd	r0, Z+5	; 0x05
     336:	f6 81       	ldd	r31, Z+6	; 0x06
     338:	e0 2d       	mov	r30, r0
     33a:	c6 81       	ldd	r28, Z+6	; 0x06
     33c:	d7 81       	ldd	r29, Z+7	; 0x07

			if( xCoRoutineTickCount < listGET_LIST_ITEM_VALUE( &( pxCRCB->xGenericListItem ) ) )				
     33e:	2a 81       	ldd	r18, Y+2	; 0x02
     340:	3b 81       	ldd	r19, Y+3	; 0x03
     342:	80 91 a0 00 	lds	r24, 0x00A0
     346:	90 91 a1 00 	lds	r25, 0x00A1
     34a:	82 17       	cp	r24, r18
     34c:	93 07       	cpc	r25, r19
     34e:	68 f1       	brcs	.+90     	; 0x3aa <vCoRoutineSchedule+0x188>
			{			
				/* Timeout not yet expired. */																			
				break;																				
			}																						

			portDISABLE_INTERRUPTS();
     350:	f8 94       	cli
				/* The event could have occurred just before this critical
				section.  If this is the case then the generic list item will
				have been moved to the pending ready list and the following
				line is still valid.  Also the pvContainer parameter will have
				been set to NULL so the following lines are also valid. */
				vListRemove( &( pxCRCB->xGenericListItem ) );											
     352:	8e 01       	movw	r16, r28
     354:	0e 5f       	subi	r16, 0xFE	; 254
     356:	1f 4f       	sbci	r17, 0xFF	; 255
     358:	c8 01       	movw	r24, r16
     35a:	0e 94 c4 03 	call	0x788	; 0x788 <vListRemove>

				/* Is the co-routine waiting on an event also? */												
				if( pxCRCB->xEventListItem.pvContainer )													
     35e:	8c 89       	ldd	r24, Y+20	; 0x14
     360:	9d 89       	ldd	r25, Y+21	; 0x15
     362:	00 97       	sbiw	r24, 0x00	; 0
     364:	21 f0       	breq	.+8      	; 0x36e <vCoRoutineSchedule+0x14c>
				{															
					vListRemove( &( pxCRCB->xEventListItem ) );											
     366:	ce 01       	movw	r24, r28
     368:	0c 96       	adiw	r24, 0x0c	; 12
     36a:	0e 94 c4 03 	call	0x788	; 0x788 <vListRemove>
				}
			}
			portENABLE_INTERRUPTS();
     36e:	78 94       	sei

			prvAddCoRoutineToReadyQueue( pxCRCB );													
     370:	8e 89       	ldd	r24, Y+22	; 0x16
     372:	90 91 89 00 	lds	r25, 0x0089
     376:	98 17       	cp	r25, r24
     378:	10 f4       	brcc	.+4      	; 0x37e <vCoRoutineSchedule+0x15c>
     37a:	80 93 89 00 	sts	0x0089, r24
     37e:	90 e0       	ldi	r25, 0x00	; 0
     380:	9c 01       	movw	r18, r24
     382:	22 0f       	add	r18, r18
     384:	33 1f       	adc	r19, r19
     386:	22 0f       	add	r18, r18
     388:	33 1f       	adc	r19, r19
     38a:	22 0f       	add	r18, r18
     38c:	33 1f       	adc	r19, r19
     38e:	82 0f       	add	r24, r18
     390:	93 1f       	adc	r25, r19
     392:	86 57       	subi	r24, 0x76	; 118
     394:	9f 4f       	sbci	r25, 0xFF	; 255
     396:	b8 01       	movw	r22, r16
     398:	0e 94 5e 03 	call	0x6bc	; 0x6bc <vListInsertEnd>
			pxDelayedCoRoutineList = pxOverflowDelayedCoRoutineList;
			pxOverflowDelayedCoRoutineList = pxTemp;
		}

		/* See if this tick has made a timeout expire. */
		while( listLIST_IS_EMPTY( pxDelayedCoRoutineList ) == pdFALSE )
     39c:	e0 91 a2 00 	lds	r30, 0x00A2
     3a0:	f0 91 a3 00 	lds	r31, 0x00A3
     3a4:	80 81       	ld	r24, Z
     3a6:	88 23       	and	r24, r24
     3a8:	29 f6       	brne	.-118    	; 0x334 <vCoRoutineSchedule+0x112>
static void prvCheckDelayedList( void )
{
corCRCB *pxCRCB;

	xPassedTicks = xTaskGetTickCount() - xLastTickCount;
	while( xPassedTicks )
     3aa:	80 91 9e 00 	lds	r24, 0x009E
     3ae:	90 91 9f 00 	lds	r25, 0x009F
     3b2:	00 97       	sbiw	r24, 0x00	; 0
     3b4:	09 f0       	breq	.+2      	; 0x3b8 <vCoRoutineSchedule+0x196>
     3b6:	85 cf       	rjmp	.-246    	; 0x2c2 <vCoRoutineSchedule+0xa0>

			prvAddCoRoutineToReadyQueue( pxCRCB );													
		}																									
	}

	xLastTickCount = xCoRoutineTickCount;
     3b8:	80 91 a0 00 	lds	r24, 0x00A0
     3bc:	90 91 a1 00 	lds	r25, 0x00A1
     3c0:	90 93 9d 00 	sts	0x009D, r25
     3c4:	80 93 9c 00 	sts	0x009C, r24

	/* See if any delayed co-routines have timed out. */
	prvCheckDelayedList();

	/* Find the highest priority queue that contains ready co-routines. */
	while( listLIST_IS_EMPTY( &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) ) )
     3c8:	40 91 89 00 	lds	r20, 0x0089
     3cc:	84 2f       	mov	r24, r20
     3ce:	90 e0       	ldi	r25, 0x00	; 0
     3d0:	fc 01       	movw	r30, r24
     3d2:	ee 0f       	add	r30, r30
     3d4:	ff 1f       	adc	r31, r31
     3d6:	ee 0f       	add	r30, r30
     3d8:	ff 1f       	adc	r31, r31
     3da:	ee 0f       	add	r30, r30
     3dc:	ff 1f       	adc	r31, r31
     3de:	e8 0f       	add	r30, r24
     3e0:	f9 1f       	adc	r31, r25
     3e2:	e6 57       	subi	r30, 0x76	; 118
     3e4:	ff 4f       	sbci	r31, 0xFF	; 255
     3e6:	20 81       	ld	r18, Z
     3e8:	22 23       	and	r18, r18
     3ea:	e9 f4       	brne	.+58     	; 0x426 <vCoRoutineSchedule+0x204>
	{
		if( uxTopCoRoutineReadyPriority == 0 )
     3ec:	44 23       	and	r20, r20
     3ee:	31 f4       	brne	.+12     	; 0x3fc <vCoRoutineSchedule+0x1da>
     3f0:	57 c0       	rjmp	.+174    	; 0x4a0 <vCoRoutineSchedule+0x27e>
     3f2:	44 23       	and	r20, r20
     3f4:	29 f4       	brne	.+10     	; 0x400 <vCoRoutineSchedule+0x1de>
     3f6:	40 93 89 00 	sts	0x0089, r20
     3fa:	52 c0       	rjmp	.+164    	; 0x4a0 <vCoRoutineSchedule+0x27e>

	/* See if any delayed co-routines have timed out. */
	prvCheckDelayedList();

	/* Find the highest priority queue that contains ready co-routines. */
	while( listLIST_IS_EMPTY( &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) ) )
     3fc:	2a e8       	ldi	r18, 0x8A	; 138
     3fe:	30 e0       	ldi	r19, 0x00	; 0
		if( uxTopCoRoutineReadyPriority == 0 )
		{
			/* No more co-routines to check. */
			return;
		}
		--uxTopCoRoutineReadyPriority;
     400:	41 50       	subi	r20, 0x01	; 1

	/* See if any delayed co-routines have timed out. */
	prvCheckDelayedList();

	/* Find the highest priority queue that contains ready co-routines. */
	while( listLIST_IS_EMPTY( &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) ) )
     402:	84 2f       	mov	r24, r20
     404:	90 e0       	ldi	r25, 0x00	; 0
     406:	fc 01       	movw	r30, r24
     408:	ee 0f       	add	r30, r30
     40a:	ff 1f       	adc	r31, r31
     40c:	ee 0f       	add	r30, r30
     40e:	ff 1f       	adc	r31, r31
     410:	ee 0f       	add	r30, r30
     412:	ff 1f       	adc	r31, r31
     414:	e8 0f       	add	r30, r24
     416:	f9 1f       	adc	r31, r25
     418:	e2 0f       	add	r30, r18
     41a:	f3 1f       	adc	r31, r19
     41c:	50 81       	ld	r21, Z
     41e:	55 23       	and	r21, r21
     420:	41 f3       	breq	.-48     	; 0x3f2 <vCoRoutineSchedule+0x1d0>
     422:	40 93 89 00 	sts	0x0089, r20
		--uxTopCoRoutineReadyPriority;
	}

	/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the co-routines
	 of the	same priority get an equal share of the processor time. */
	listGET_OWNER_OF_NEXT_ENTRY( pxCurrentCoRoutine, &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) );
     426:	9c 01       	movw	r18, r24
     428:	22 0f       	add	r18, r18
     42a:	33 1f       	adc	r19, r19
     42c:	22 0f       	add	r18, r18
     42e:	33 1f       	adc	r19, r19
     430:	22 0f       	add	r18, r18
     432:	33 1f       	adc	r19, r19
     434:	28 0f       	add	r18, r24
     436:	39 1f       	adc	r19, r25
     438:	d9 01       	movw	r26, r18
     43a:	a6 57       	subi	r26, 0x76	; 118
     43c:	bf 4f       	sbci	r27, 0xFF	; 255
     43e:	11 96       	adiw	r26, 0x01	; 1
     440:	ed 91       	ld	r30, X+
     442:	fc 91       	ld	r31, X
     444:	12 97       	sbiw	r26, 0x02	; 2
     446:	02 80       	ldd	r0, Z+2	; 0x02
     448:	f3 81       	ldd	r31, Z+3	; 0x03
     44a:	e0 2d       	mov	r30, r0
     44c:	12 96       	adiw	r26, 0x02	; 2
     44e:	fc 93       	st	X, r31
     450:	ee 93       	st	-X, r30
     452:	11 97       	sbiw	r26, 0x01	; 1
     454:	23 57       	subi	r18, 0x73	; 115
     456:	3f 4f       	sbci	r19, 0xFF	; 255
     458:	e2 17       	cp	r30, r18
     45a:	f3 07       	cpc	r31, r19
     45c:	29 f4       	brne	.+10     	; 0x468 <vCoRoutineSchedule+0x246>
     45e:	22 81       	ldd	r18, Z+2	; 0x02
     460:	33 81       	ldd	r19, Z+3	; 0x03
     462:	fd 01       	movw	r30, r26
     464:	32 83       	std	Z+2, r19	; 0x02
     466:	21 83       	std	Z+1, r18	; 0x01
     468:	fc 01       	movw	r30, r24
     46a:	ee 0f       	add	r30, r30
     46c:	ff 1f       	adc	r31, r31
     46e:	ee 0f       	add	r30, r30
     470:	ff 1f       	adc	r31, r31
     472:	ee 0f       	add	r30, r30
     474:	ff 1f       	adc	r31, r31
     476:	8e 0f       	add	r24, r30
     478:	9f 1f       	adc	r25, r31
     47a:	fc 01       	movw	r30, r24
     47c:	e6 57       	subi	r30, 0x76	; 118
     47e:	ff 4f       	sbci	r31, 0xFF	; 255
     480:	01 80       	ldd	r0, Z+1	; 0x01
     482:	f2 81       	ldd	r31, Z+2	; 0x02
     484:	e0 2d       	mov	r30, r0
     486:	a6 81       	ldd	r26, Z+6	; 0x06
     488:	b7 81       	ldd	r27, Z+7	; 0x07
     48a:	b0 93 7f 00 	sts	0x007F, r27
     48e:	a0 93 7e 00 	sts	0x007E, r26

	/* Call the co-routine. */
	( pxCurrentCoRoutine->pxCoRoutineFunction )( pxCurrentCoRoutine, pxCurrentCoRoutine->uxIndex );
     492:	ed 91       	ld	r30, X+
     494:	fc 91       	ld	r31, X
     496:	11 97       	sbiw	r26, 0x01	; 1
     498:	cd 01       	movw	r24, r26
     49a:	57 96       	adiw	r26, 0x17	; 23
     49c:	6c 91       	ld	r22, X
     49e:	09 95       	icall

	return;
}
     4a0:	df 91       	pop	r29
     4a2:	cf 91       	pop	r28
     4a4:	1f 91       	pop	r17
     4a6:	0f 91       	pop	r16
     4a8:	ff 90       	pop	r15
     4aa:	ef 90       	pop	r14
     4ac:	df 90       	pop	r13
     4ae:	cf 90       	pop	r12
     4b0:	08 95       	ret

000004b2 <xCoRoutineRemoveFromEventList>:
	pxOverflowDelayedCoRoutineList = &xDelayedCoRoutineList2;
}
/*-----------------------------------------------------------*/

signed portBASE_TYPE xCoRoutineRemoveFromEventList( const xList *pxEventList )
{
     4b2:	0f 93       	push	r16
     4b4:	1f 93       	push	r17
     4b6:	cf 93       	push	r28
     4b8:	df 93       	push	r29
signed portBASE_TYPE xReturn;

	/* This function is called from within an interrupt.  It can only access
	event lists and the pending ready list.  This function assumes that a
	check has already been made to ensure pxEventList is not empty. */
	pxUnblockedCRCB = ( corCRCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
     4ba:	dc 01       	movw	r26, r24
     4bc:	15 96       	adiw	r26, 0x05	; 5
     4be:	ed 91       	ld	r30, X+
     4c0:	fc 91       	ld	r31, X
     4c2:	16 97       	sbiw	r26, 0x06	; 6
     4c4:	06 81       	ldd	r16, Z+6	; 0x06
     4c6:	17 81       	ldd	r17, Z+7	; 0x07
	vListRemove( &( pxUnblockedCRCB->xEventListItem ) );
     4c8:	e8 01       	movw	r28, r16
     4ca:	2c 96       	adiw	r28, 0x0c	; 12
     4cc:	ce 01       	movw	r24, r28
     4ce:	0e 94 c4 03 	call	0x788	; 0x788 <vListRemove>
	vListInsertEnd( ( xList * ) &( xPendingReadyCoRoutineList ), &( pxUnblockedCRCB->xEventListItem ) );
     4d2:	80 e8       	ldi	r24, 0x80	; 128
     4d4:	90 e0       	ldi	r25, 0x00	; 0
     4d6:	be 01       	movw	r22, r28
     4d8:	0e 94 5e 03 	call	0x6bc	; 0x6bc <vListInsertEnd>

	if( pxUnblockedCRCB->uxPriority >= pxCurrentCoRoutine->uxPriority )
     4dc:	e0 91 7e 00 	lds	r30, 0x007E
     4e0:	f0 91 7f 00 	lds	r31, 0x007F
	{
		xReturn = pdTRUE;
     4e4:	81 e0       	ldi	r24, 0x01	; 1
     4e6:	d8 01       	movw	r26, r16
     4e8:	56 96       	adiw	r26, 0x16	; 22
     4ea:	2c 91       	ld	r18, X
     4ec:	56 97       	sbiw	r26, 0x16	; 22
     4ee:	96 89       	ldd	r25, Z+22	; 0x16
     4f0:	29 17       	cp	r18, r25
     4f2:	08 f4       	brcc	.+2      	; 0x4f6 <xCoRoutineRemoveFromEventList+0x44>
     4f4:	80 e0       	ldi	r24, 0x00	; 0
	{
		xReturn = pdFALSE;
	}

	return xReturn;
}
     4f6:	df 91       	pop	r29
     4f8:	cf 91       	pop	r28
     4fa:	1f 91       	pop	r17
     4fc:	0f 91       	pop	r16
     4fe:	08 95       	ret

00000500 <pvPortMalloc>:

static size_t xNextFreeByte = ( size_t ) 0;
/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
     500:	ef 92       	push	r14
     502:	ff 92       	push	r15
     504:	0f 93       	push	r16
     506:	1f 93       	push	r17
     508:	cf 93       	push	r28
     50a:	df 93       	push	r29
     50c:	8c 01       	movw	r16, r24
			/* Byte alignment required. */
			xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
		}
	#endif

	vTaskSuspendAll();
     50e:	0e 94 3a 0b 	call	0x1674	; 0x1674 <vTaskSuspendAll>
	{
		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configTOTAL_HEAP_SIZE ) &&
     512:	c0 91 b8 00 	lds	r28, 0x00B8
     516:	d0 91 b9 00 	lds	r29, 0x00B9
     51a:	0c 0f       	add	r16, r28
     51c:	1d 1f       	adc	r17, r29
     51e:	22 e0       	ldi	r18, 0x02	; 2
     520:	08 35       	cpi	r16, 0x58	; 88
     522:	12 07       	cpc	r17, r18
     524:	50 f4       	brcc	.+20     	; 0x53a <pvPortMalloc+0x3a>
     526:	c0 17       	cp	r28, r16
     528:	d1 07       	cpc	r29, r17
     52a:	50 f4       	brcc	.+20     	; 0x540 <pvPortMalloc+0x40>
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
		{
			/* Return the next free byte then increment the index past this
			block. */
			pvReturn = &( xHeap.ucHeap[ xNextFreeByte ] );
     52c:	c6 54       	subi	r28, 0x46	; 70
     52e:	df 4f       	sbci	r29, 0xFF	; 255
			xNextFreeByte += xWantedSize;			
     530:	10 93 b9 00 	sts	0x00B9, r17
     534:	00 93 b8 00 	sts	0x00B8, r16
     538:	05 c0       	rjmp	.+10     	; 0x544 <pvPortMalloc+0x44>
static size_t xNextFreeByte = ( size_t ) 0;
/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
void *pvReturn = NULL; 
     53a:	c0 e0       	ldi	r28, 0x00	; 0
     53c:	d0 e0       	ldi	r29, 0x00	; 0
     53e:	02 c0       	rjmp	.+4      	; 0x544 <pvPortMalloc+0x44>
     540:	c0 e0       	ldi	r28, 0x00	; 0
     542:	d0 e0       	ldi	r29, 0x00	; 0
			block. */
			pvReturn = &( xHeap.ucHeap[ xNextFreeByte ] );
			xNextFreeByte += xWantedSize;			
		}	
	}
	xTaskResumeAll();
     544:	0e 94 1c 0c 	call	0x1838	; 0x1838 <xTaskResumeAll>
		}
	}
	#endif	

	return pvReturn;
}
     548:	7e 01       	movw	r14, r28
     54a:	8c 2f       	mov	r24, r28
     54c:	9f 2d       	mov	r25, r15
     54e:	df 91       	pop	r29
     550:	cf 91       	pop	r28
     552:	1f 91       	pop	r17
     554:	0f 91       	pop	r16
     556:	ff 90       	pop	r15
     558:	ef 90       	pop	r14
     55a:	08 95       	ret

0000055c <vPortFree>:
{
	/* Memory cannot be freed using this scheme.  See heap_2.c and heap_3.c 
	for alternative implementations, and the memory management pages of 
	http://www.FreeRTOS.org for more information. */
	( void ) pv;
}
     55c:	08 95       	ret

0000055e <vPortInitialiseBlocks>:
/*-----------------------------------------------------------*/

void vPortInitialiseBlocks( void )
{
	/* Only required when static memory is not cleared. */
	xNextFreeByte = ( size_t ) 0;
     55e:	10 92 b9 00 	sts	0x00B9, r1
     562:	10 92 b8 00 	sts	0x00B8, r1
}
     566:	08 95       	ret

00000568 <xPortGetFreeHeapSize>:
/*-----------------------------------------------------------*/

size_t xPortGetFreeHeapSize( void )
{
	return ( configTOTAL_HEAP_SIZE - xNextFreeByte );
     568:	80 91 b8 00 	lds	r24, 0x00B8
     56c:	90 91 b9 00 	lds	r25, 0x00B9
     570:	28 e5       	ldi	r18, 0x58	; 88
     572:	32 e0       	ldi	r19, 0x02	; 2
     574:	28 1b       	sub	r18, r24
     576:	39 0b       	sbc	r19, r25
}
     578:	82 2f       	mov	r24, r18
     57a:	93 2f       	mov	r25, r19
     57c:	08 95       	ret

0000057e <enableTrigger>:
//   data changes.
////////////////////////////////////////////////////////////////////
void enableTrigger(void)
{

	CLR_BIT(PORTB,2);
     57e:	c2 98       	cbi	0x18, 2	; 24
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
     580:	89 ef       	ldi	r24, 0xF9	; 249
     582:	90 e0       	ldi	r25, 0x00	; 0
     584:	01 97       	sbiw	r24, 0x01	; 1
     586:	f1 f7       	brne	.-4      	; 0x584 <enableTrigger+0x6>
     588:	00 c0       	rjmp	.+0      	; 0x58a <enableTrigger+0xc>
     58a:	00 00       	nop
	
	_delay_ms(1);

	SET_BIT(PORTB,2);
     58c:	c2 9a       	sbi	0x18, 2	; 24
     58e:	8b ed       	ldi	r24, 0xDB	; 219
     590:	95 e0       	ldi	r25, 0x05	; 5
     592:	01 97       	sbiw	r24, 0x01	; 1
     594:	f1 f7       	brne	.-4      	; 0x592 <enableTrigger+0x14>
     596:	00 c0       	rjmp	.+0      	; 0x598 <enableTrigger+0x1a>
     598:	00 00       	nop
	_delay_ms(6);


}
     59a:	08 95       	ret

0000059c <lcd_sendCommand>:
		
}


void lcd_sendCommand(unsigned char cmd)
{
     59c:	1f 93       	push	r17
     59e:	18 2f       	mov	r17, r24
	unsigned char high_nibble , low_nibble ; 		
	
	HIGH_NIBBLE(high_nibble,cmd);
	LOW_NIBBLE(low_nibble,cmd);

	CLR_BIT(PORTB,0); // to enable command mode 
     5a0:	c0 98       	cbi	0x18, 0	; 24
	CLR_BIT(PORTB,1); // write signal to lcd 
     5a2:	c1 98       	cbi	0x18, 1	; 24

	PORTB &=0x0f;
     5a4:	88 b3       	in	r24, 0x18	; 24
     5a6:	8f 70       	andi	r24, 0x0F	; 15
     5a8:	88 bb       	out	0x18, r24	; 24
	PORTB |=high_nibble;// to send high nibble command  
     5aa:	88 b3       	in	r24, 0x18	; 24
void lcd_sendCommand(unsigned char cmd)
{

	unsigned char high_nibble , low_nibble ; 		
	
	HIGH_NIBBLE(high_nibble,cmd);
     5ac:	91 2f       	mov	r25, r17
     5ae:	90 7f       	andi	r25, 0xF0	; 240

	CLR_BIT(PORTB,0); // to enable command mode 
	CLR_BIT(PORTB,1); // write signal to lcd 

	PORTB &=0x0f;
	PORTB |=high_nibble;// to send high nibble command  
     5b0:	89 2b       	or	r24, r25
     5b2:	88 bb       	out	0x18, r24	; 24
	enableTrigger(); // triggre lcd enable 
     5b4:	0e 94 bf 02 	call	0x57e	; 0x57e <enableTrigger>

	PORTB &=0x0f;
     5b8:	88 b3       	in	r24, 0x18	; 24
     5ba:	8f 70       	andi	r24, 0x0F	; 15
     5bc:	88 bb       	out	0x18, r24	; 24
	PORTB |=low_nibble; // to send low nibble command 
     5be:	88 b3       	in	r24, 0x18	; 24
{

	unsigned char high_nibble , low_nibble ; 		
	
	HIGH_NIBBLE(high_nibble,cmd);
	LOW_NIBBLE(low_nibble,cmd);
     5c0:	12 95       	swap	r17
     5c2:	10 7f       	andi	r17, 0xF0	; 240
	PORTB &=0x0f;
	PORTB |=high_nibble;// to send high nibble command  
	enableTrigger(); // triggre lcd enable 

	PORTB &=0x0f;
	PORTB |=low_nibble; // to send low nibble command 
     5c4:	18 2b       	or	r17, r24
     5c6:	18 bb       	out	0x18, r17	; 24
	enableTrigger();
     5c8:	0e 94 bf 02 	call	0x57e	; 0x57e <enableTrigger>

}
     5cc:	1f 91       	pop	r17
     5ce:	08 95       	ret

000005d0 <lcd_init>:
//							 and pinB.0 to pinB.2 o/p for control pins 
//////////////////////////////////////////////////////////////////////////////////////
void lcd_init(void)
{

	DDRB=0xff; // init port B as O/P port 
     5d0:	8f ef       	ldi	r24, 0xFF	; 255
     5d2:	87 bb       	out	0x17, r24	; 23
	PORTB=0x04; // activate LCD enable 
     5d4:	84 e0       	ldi	r24, 0x04	; 4
     5d6:	88 bb       	out	0x18, r24	; 24

	lcd_sendCommand(0x33); // 4-bit mode 
     5d8:	83 e3       	ldi	r24, 0x33	; 51
     5da:	0e 94 ce 02 	call	0x59c	; 0x59c <lcd_sendCommand>
	lcd_sendCommand (0x32);
     5de:	82 e3       	ldi	r24, 0x32	; 50
     5e0:	0e 94 ce 02 	call	0x59c	; 0x59c <lcd_sendCommand>
	lcd_sendCommand (0x28);
     5e4:	88 e2       	ldi	r24, 0x28	; 40
     5e6:	0e 94 ce 02 	call	0x59c	; 0x59c <lcd_sendCommand>



	lcd_sendCommand(0x0c); // turn on lcd 
     5ea:	8c e0       	ldi	r24, 0x0C	; 12
     5ec:	0e 94 ce 02 	call	0x59c	; 0x59c <lcd_sendCommand>

		
}
     5f0:	08 95       	ret

000005f2 <lcd_displayChar>:
	enableTrigger();

}

void lcd_displayChar (unsigned char data)
{
     5f2:	1f 93       	push	r17
     5f4:	18 2f       	mov	r17, r24

	unsigned char high_nibble , low_nibble ;

	SET_BIT(PORTB,0); //  enable data mode 
     5f6:	c0 9a       	sbi	0x18, 0	; 24
	CLR_BIT(PORTB,1); // activate lcd write 
     5f8:	c1 98       	cbi	0x18, 1	; 24

	HIGH_NIBBLE(high_nibble,data); // get high nibble data 
	LOW_NIBBLE(low_nibble,data); // get low nibble data 
	
	PORTB &= 0x0f;
     5fa:	88 b3       	in	r24, 0x18	; 24
     5fc:	8f 70       	andi	r24, 0x0F	; 15
     5fe:	88 bb       	out	0x18, r24	; 24
	PORTB |=high_nibble;// to send high nibble data  
     600:	88 b3       	in	r24, 0x18	; 24
	unsigned char high_nibble , low_nibble ;

	SET_BIT(PORTB,0); //  enable data mode 
	CLR_BIT(PORTB,1); // activate lcd write 

	HIGH_NIBBLE(high_nibble,data); // get high nibble data 
     602:	91 2f       	mov	r25, r17
     604:	90 7f       	andi	r25, 0xF0	; 240
	LOW_NIBBLE(low_nibble,data); // get low nibble data 
	
	PORTB &= 0x0f;
	PORTB |=high_nibble;// to send high nibble data  
     606:	89 2b       	or	r24, r25
     608:	88 bb       	out	0x18, r24	; 24
	enableTrigger(); // triggre lcd enable 
     60a:	0e 94 bf 02 	call	0x57e	; 0x57e <enableTrigger>
	
	PORTB &=0x0f;
     60e:	88 b3       	in	r24, 0x18	; 24
     610:	8f 70       	andi	r24, 0x0F	; 15
     612:	88 bb       	out	0x18, r24	; 24
	PORTB |=low_nibble; // to send low nibble data 
     614:	88 b3       	in	r24, 0x18	; 24

	SET_BIT(PORTB,0); //  enable data mode 
	CLR_BIT(PORTB,1); // activate lcd write 

	HIGH_NIBBLE(high_nibble,data); // get high nibble data 
	LOW_NIBBLE(low_nibble,data); // get low nibble data 
     616:	12 95       	swap	r17
     618:	10 7f       	andi	r17, 0xF0	; 240
	PORTB &= 0x0f;
	PORTB |=high_nibble;// to send high nibble data  
	enableTrigger(); // triggre lcd enable 
	
	PORTB &=0x0f;
	PORTB |=low_nibble; // to send low nibble data 
     61a:	18 2b       	or	r17, r24
     61c:	18 bb       	out	0x18, r17	; 24
	enableTrigger();
     61e:	0e 94 bf 02 	call	0x57e	; 0x57e <enableTrigger>
	

}
     622:	1f 91       	pop	r17
     624:	08 95       	ret

00000626 <lcd_gotoxy>:

void lcd_gotoxy(unsigned char y , unsigned char x )
{
	unsigned char position = 0x80;
	 
	switch(y)
     626:	81 30       	cpi	r24, 0x01	; 1
     628:	51 f0       	breq	.+20     	; 0x63e <lcd_gotoxy+0x18>
     62a:	81 30       	cpi	r24, 0x01	; 1
     62c:	28 f0       	brcs	.+10     	; 0x638 <lcd_gotoxy+0x12>
     62e:	82 30       	cpi	r24, 0x02	; 2
     630:	49 f0       	breq	.+18     	; 0x644 <lcd_gotoxy+0x1e>
     632:	83 30       	cpi	r24, 0x03	; 3
     634:	69 f4       	brne	.+26     	; 0x650 <lcd_gotoxy+0x2a>
     636:	09 c0       	rjmp	.+18     	; 0x64a <lcd_gotoxy+0x24>
	{
		case 0:

			position=position+x;
     638:	86 2f       	mov	r24, r22
     63a:	80 58       	subi	r24, 0x80	; 128
					
		break;
     63c:	0a c0       	rjmp	.+20     	; 0x652 <lcd_gotoxy+0x2c>

		case 1:

			position=0xc0;
			position=position+x;
     63e:	86 2f       	mov	r24, r22
     640:	80 54       	subi	r24, 0x40	; 64

		break;
     642:	07 c0       	rjmp	.+14     	; 0x652 <lcd_gotoxy+0x2c>

		case 2:

			position=position+x;
     644:	86 2f       	mov	r24, r22
     646:	80 58       	subi	r24, 0x80	; 128

		break;
     648:	04 c0       	rjmp	.+8      	; 0x652 <lcd_gotoxy+0x2c>

		case 3:
			position=position+x;
     64a:	86 2f       	mov	r24, r22
     64c:	80 58       	subi	r24, 0x80	; 128
		break;
     64e:	01 c0       	rjmp	.+2      	; 0x652 <lcd_gotoxy+0x2c>
}


void lcd_gotoxy(unsigned char y , unsigned char x )
{
	unsigned char position = 0x80;
     650:	80 e8       	ldi	r24, 0x80	; 128
		break;
	
	
	}
	
	lcd_sendCommand(position); 	
     652:	0e 94 ce 02 	call	0x59c	; 0x59c <lcd_sendCommand>


}
     656:	08 95       	ret

00000658 <lcd_clrScreen>:


void lcd_clrScreen(void)
{

	lcd_sendCommand(0x01);
     658:	81 e0       	ldi	r24, 0x01	; 1
     65a:	0e 94 ce 02 	call	0x59c	; 0x59c <lcd_sendCommand>


}
     65e:	08 95       	ret

00000660 <lcd_dispString>:


void lcd_dispString(char * ptr)
{
     660:	cf 93       	push	r28
     662:	df 93       	push	r29
     664:	ec 01       	movw	r28, r24

	while(* ptr!= '\0')
     666:	88 81       	ld	r24, Y
     668:	88 23       	and	r24, r24
     66a:	31 f0       	breq	.+12     	; 0x678 <lcd_dispString+0x18>


}


void lcd_dispString(char * ptr)
     66c:	21 96       	adiw	r28, 0x01	; 1
{

	while(* ptr!= '\0')
	{
		lcd_displayChar(* ptr);
     66e:	0e 94 f9 02 	call	0x5f2	; 0x5f2 <lcd_displayChar>


void lcd_dispString(char * ptr)
{

	while(* ptr!= '\0')
     672:	89 91       	ld	r24, Y+
     674:	88 23       	and	r24, r24
     676:	d9 f7       	brne	.-10     	; 0x66e <lcd_dispString+0xe>
	
	}



}
     678:	df 91       	pop	r29
     67a:	cf 91       	pop	r28
     67c:	08 95       	ret

0000067e <lcd_disp_string_xy>:

void lcd_disp_string_xy(char * ptr , int y , int x)
{
     67e:	cf 93       	push	r28
     680:	df 93       	push	r29
     682:	ec 01       	movw	r28, r24
     684:	86 2f       	mov	r24, r22

	lcd_gotoxy(y,x);
     686:	64 2f       	mov	r22, r20
     688:	0e 94 13 03 	call	0x626	; 0x626 <lcd_gotoxy>
	lcd_dispString(ptr);
     68c:	ce 01       	movw	r24, r28
     68e:	0e 94 30 03 	call	0x660	; 0x660 <lcd_dispString>

	


}
     692:	df 91       	pop	r29
     694:	cf 91       	pop	r28
     696:	08 95       	ret

00000698 <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( xList *pxList )
{
     698:	fc 01       	movw	r30, r24
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( xListItem * ) &( pxList->xListEnd );
     69a:	03 96       	adiw	r24, 0x03	; 3
     69c:	92 83       	std	Z+2, r25	; 0x02
     69e:	81 83       	std	Z+1, r24	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
     6a0:	2f ef       	ldi	r18, 0xFF	; 255
     6a2:	3f ef       	ldi	r19, 0xFF	; 255
     6a4:	34 83       	std	Z+4, r19	; 0x04
     6a6:	23 83       	std	Z+3, r18	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( xListItem * ) &( pxList->xListEnd );
     6a8:	96 83       	std	Z+6, r25	; 0x06
     6aa:	85 83       	std	Z+5, r24	; 0x05
	pxList->xListEnd.pxPrevious = ( xListItem * ) &( pxList->xListEnd );
     6ac:	90 87       	std	Z+8, r25	; 0x08
     6ae:	87 83       	std	Z+7, r24	; 0x07

	pxList->uxNumberOfItems = ( unsigned portBASE_TYPE ) 0U;
     6b0:	10 82       	st	Z, r1
}
     6b2:	08 95       	ret

000006b4 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( xListItem *pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
     6b4:	fc 01       	movw	r30, r24
     6b6:	11 86       	std	Z+9, r1	; 0x09
     6b8:	10 86       	std	Z+8, r1	; 0x08
}
     6ba:	08 95       	ret

000006bc <vListInsertEnd>:
/*-----------------------------------------------------------*/

void vListInsertEnd( xList *pxList, xListItem *pxNewListItem )
{
     6bc:	cf 93       	push	r28
     6be:	df 93       	push	r29
     6c0:	fc 01       	movw	r30, r24
     6c2:	db 01       	movw	r26, r22

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	pvListGetOwnerOfNextEntry.  This means it has to be the item pointed to by
	the pxIndex member. */
	pxIndex = pxList->pxIndex;
     6c4:	21 81       	ldd	r18, Z+1	; 0x01
     6c6:	32 81       	ldd	r19, Z+2	; 0x02

	pxNewListItem->pxNext = pxIndex->pxNext;
     6c8:	e9 01       	movw	r28, r18
     6ca:	8a 81       	ldd	r24, Y+2	; 0x02
     6cc:	9b 81       	ldd	r25, Y+3	; 0x03
     6ce:	13 96       	adiw	r26, 0x03	; 3
     6d0:	9c 93       	st	X, r25
     6d2:	8e 93       	st	-X, r24
     6d4:	12 97       	sbiw	r26, 0x02	; 2
	pxNewListItem->pxPrevious = pxList->pxIndex;
     6d6:	81 81       	ldd	r24, Z+1	; 0x01
     6d8:	92 81       	ldd	r25, Z+2	; 0x02
     6da:	15 96       	adiw	r26, 0x05	; 5
     6dc:	9c 93       	st	X, r25
     6de:	8e 93       	st	-X, r24
     6e0:	14 97       	sbiw	r26, 0x04	; 4
	pxIndex->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
     6e2:	8a 81       	ldd	r24, Y+2	; 0x02
     6e4:	9b 81       	ldd	r25, Y+3	; 0x03
     6e6:	ec 01       	movw	r28, r24
     6e8:	7d 83       	std	Y+5, r23	; 0x05
     6ea:	6c 83       	std	Y+4, r22	; 0x04
	pxIndex->pxNext = ( volatile xListItem * ) pxNewListItem;
     6ec:	e9 01       	movw	r28, r18
     6ee:	7b 83       	std	Y+3, r23	; 0x03
     6f0:	6a 83       	std	Y+2, r22	; 0x02
	pxList->pxIndex = ( volatile xListItem * ) pxNewListItem;
     6f2:	72 83       	std	Z+2, r23	; 0x02
     6f4:	61 83       	std	Z+1, r22	; 0x01

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     6f6:	19 96       	adiw	r26, 0x09	; 9
     6f8:	fc 93       	st	X, r31
     6fa:	ee 93       	st	-X, r30
     6fc:	18 97       	sbiw	r26, 0x08	; 8

	( pxList->uxNumberOfItems )++;
     6fe:	80 81       	ld	r24, Z
     700:	8f 5f       	subi	r24, 0xFF	; 255
     702:	80 83       	st	Z, r24
}
     704:	df 91       	pop	r29
     706:	cf 91       	pop	r28
     708:	08 95       	ret

0000070a <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( xList *pxList, xListItem *pxNewListItem )
{
     70a:	cf 93       	push	r28
     70c:	df 93       	push	r29
     70e:	fc 01       	movw	r30, r24
volatile xListItem *pxIterator;
portTickType xValueOfInsertion;

	/* Insert the new list item into the list, sorted in ulListItem order. */
	xValueOfInsertion = pxNewListItem->xItemValue;
     710:	db 01       	movw	r26, r22
     712:	2d 91       	ld	r18, X+
     714:	3c 91       	ld	r19, X
     716:	11 97       	sbiw	r26, 0x01	; 1
	are stored in ready lists (all of which have the same ulListItem value)
	get an equal share of the CPU.  However, if the xItemValue is the same as
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
     718:	bf ef       	ldi	r27, 0xFF	; 255
     71a:	2f 3f       	cpi	r18, 0xFF	; 255
     71c:	3b 07       	cpc	r19, r27
     71e:	19 f4       	brne	.+6      	; 0x726 <vListInsert+0x1c>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
     720:	a7 81       	ldd	r26, Z+7	; 0x07
     722:	b0 85       	ldd	r27, Z+8	; 0x08
     724:	18 c0       	rjmp	.+48     	; 0x756 <vListInsert+0x4c>
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		See http://www.freertos.org/FAQHelp.html for more tips.
		**********************************************************************/
		
		for( pxIterator = ( xListItem * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext )
     726:	dc 01       	movw	r26, r24
     728:	13 96       	adiw	r26, 0x03	; 3
     72a:	12 96       	adiw	r26, 0x02	; 2
     72c:	cd 91       	ld	r28, X+
     72e:	dc 91       	ld	r29, X
     730:	13 97       	sbiw	r26, 0x03	; 3
     732:	88 81       	ld	r24, Y
     734:	99 81       	ldd	r25, Y+1	; 0x01
     736:	28 17       	cp	r18, r24
     738:	39 07       	cpc	r19, r25
     73a:	68 f0       	brcs	.+26     	; 0x756 <vListInsert+0x4c>
     73c:	12 96       	adiw	r26, 0x02	; 2
     73e:	0d 90       	ld	r0, X+
     740:	bc 91       	ld	r27, X
     742:	a0 2d       	mov	r26, r0
     744:	12 96       	adiw	r26, 0x02	; 2
     746:	cd 91       	ld	r28, X+
     748:	dc 91       	ld	r29, X
     74a:	13 97       	sbiw	r26, 0x03	; 3
     74c:	88 81       	ld	r24, Y
     74e:	99 81       	ldd	r25, Y+1	; 0x01
     750:	28 17       	cp	r18, r24
     752:	39 07       	cpc	r19, r25
     754:	98 f7       	brcc	.-26     	; 0x73c <vListInsert+0x32>
			/* There is nothing to do here, we are just iterating to the
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
     756:	12 96       	adiw	r26, 0x02	; 2
     758:	8d 91       	ld	r24, X+
     75a:	9c 91       	ld	r25, X
     75c:	13 97       	sbiw	r26, 0x03	; 3
     75e:	eb 01       	movw	r28, r22
     760:	9b 83       	std	Y+3, r25	; 0x03
     762:	8a 83       	std	Y+2, r24	; 0x02
	pxNewListItem->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
     764:	ec 01       	movw	r28, r24
     766:	7d 83       	std	Y+5, r23	; 0x05
     768:	6c 83       	std	Y+4, r22	; 0x04
	pxNewListItem->pxPrevious = pxIterator;
     76a:	eb 01       	movw	r28, r22
     76c:	bd 83       	std	Y+5, r27	; 0x05
     76e:	ac 83       	std	Y+4, r26	; 0x04
	pxIterator->pxNext = ( volatile xListItem * ) pxNewListItem;
     770:	13 96       	adiw	r26, 0x03	; 3
     772:	7c 93       	st	X, r23
     774:	6e 93       	st	-X, r22
     776:	12 97       	sbiw	r26, 0x02	; 2

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     778:	f9 87       	std	Y+9, r31	; 0x09
     77a:	e8 87       	std	Y+8, r30	; 0x08

	( pxList->uxNumberOfItems )++;
     77c:	80 81       	ld	r24, Z
     77e:	8f 5f       	subi	r24, 0xFF	; 255
     780:	80 83       	st	Z, r24
}
     782:	df 91       	pop	r29
     784:	cf 91       	pop	r28
     786:	08 95       	ret

00000788 <vListRemove>:
/*-----------------------------------------------------------*/

void vListRemove( xListItem *pxItemToRemove )
{
     788:	fc 01       	movw	r30, r24
xList * pxList;

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
     78a:	a2 81       	ldd	r26, Z+2	; 0x02
     78c:	b3 81       	ldd	r27, Z+3	; 0x03
     78e:	84 81       	ldd	r24, Z+4	; 0x04
     790:	95 81       	ldd	r25, Z+5	; 0x05
     792:	15 96       	adiw	r26, 0x05	; 5
     794:	9c 93       	st	X, r25
     796:	8e 93       	st	-X, r24
     798:	14 97       	sbiw	r26, 0x04	; 4
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
     79a:	a4 81       	ldd	r26, Z+4	; 0x04
     79c:	b5 81       	ldd	r27, Z+5	; 0x05
     79e:	82 81       	ldd	r24, Z+2	; 0x02
     7a0:	93 81       	ldd	r25, Z+3	; 0x03
     7a2:	13 96       	adiw	r26, 0x03	; 3
     7a4:	9c 93       	st	X, r25
     7a6:	8e 93       	st	-X, r24
     7a8:	12 97       	sbiw	r26, 0x02	; 2
	
	/* The list item knows which list it is in.  Obtain the list from the list
	item. */
	pxList = ( xList * ) pxItemToRemove->pvContainer;
     7aa:	a0 85       	ldd	r26, Z+8	; 0x08
     7ac:	b1 85       	ldd	r27, Z+9	; 0x09

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
     7ae:	11 96       	adiw	r26, 0x01	; 1
     7b0:	8d 91       	ld	r24, X+
     7b2:	9c 91       	ld	r25, X
     7b4:	12 97       	sbiw	r26, 0x02	; 2
     7b6:	8e 17       	cp	r24, r30
     7b8:	9f 07       	cpc	r25, r31
     7ba:	31 f4       	brne	.+12     	; 0x7c8 <vListRemove+0x40>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
     7bc:	84 81       	ldd	r24, Z+4	; 0x04
     7be:	95 81       	ldd	r25, Z+5	; 0x05
     7c0:	12 96       	adiw	r26, 0x02	; 2
     7c2:	9c 93       	st	X, r25
     7c4:	8e 93       	st	-X, r24
     7c6:	11 97       	sbiw	r26, 0x01	; 1
	}

	pxItemToRemove->pvContainer = NULL;
     7c8:	11 86       	std	Z+9, r1	; 0x09
     7ca:	10 86       	std	Z+8, r1	; 0x08
	( pxList->uxNumberOfItems )--;
     7cc:	8c 91       	ld	r24, X
     7ce:	81 50       	subi	r24, 0x01	; 1
     7d0:	8c 93       	st	X, r24
}
     7d2:	08 95       	ret

000007d4 <pxPortInitialiseStack>:
unsigned short usAddress;

	/* Place a few bytes of known values on the bottom of the stack. 
	This is just useful for debugging. */

	*pxTopOfStack = 0x11;
     7d4:	21 e1       	ldi	r18, 0x11	; 17
     7d6:	fc 01       	movw	r30, r24
     7d8:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = 0x22;
     7da:	92 e2       	ldi	r25, 0x22	; 34
     7dc:	92 93       	st	-Z, r25
	pxTopOfStack--;
	*pxTopOfStack = 0x33;
     7de:	83 e3       	ldi	r24, 0x33	; 51
     7e0:	82 93       	st	-Z, r24
	/*lint -e950 -e611 -e923 Lint doesn't like this much - but nothing I can do about it. */

	/* The start of the task code will be popped off the stack last, so place
	it on first. */
	usAddress = ( unsigned short ) pxCode;
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned short ) 0x00ff );
     7e2:	62 93       	st	-Z, r22
	pxTopOfStack--;

	usAddress >>= 8;
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned short ) 0x00ff );
     7e4:	72 93       	st	-Z, r23

	/* Next simulate the stack as if after a call to portSAVE_CONTEXT().  
	portSAVE_CONTEXT places the flags on the stack immediately after r0
	to ensure the interrupts get disabled as soon as possible, and so ensuring
	the stack use is minimal should a context switch interrupt occur. */
	*pxTopOfStack = ( portSTACK_TYPE ) 0x00;	/* R0 */
     7e6:	12 92       	st	-Z, r1
	pxTopOfStack--;
	*pxTopOfStack = portFLAGS_INT_ENABLED;
     7e8:	80 e8       	ldi	r24, 0x80	; 128
     7ea:	82 93       	st	-Z, r24
	pxTopOfStack--;


	/* Now the remaining registers.   The compiler expects R1 to be 0. */
	*pxTopOfStack = ( portSTACK_TYPE ) 0x00;	/* R1 */
     7ec:	12 92       	st	-Z, r1
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x02;	/* R2 */
     7ee:	82 e0       	ldi	r24, 0x02	; 2
     7f0:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x03;	/* R3 */
     7f2:	83 e0       	ldi	r24, 0x03	; 3
     7f4:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x04;	/* R4 */
     7f6:	84 e0       	ldi	r24, 0x04	; 4
     7f8:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x05;	/* R5 */
     7fa:	85 e0       	ldi	r24, 0x05	; 5
     7fc:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x06;	/* R6 */
     7fe:	86 e0       	ldi	r24, 0x06	; 6
     800:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x07;	/* R7 */
     802:	87 e0       	ldi	r24, 0x07	; 7
     804:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x08;	/* R8 */
     806:	88 e0       	ldi	r24, 0x08	; 8
     808:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x09;	/* R9 */
     80a:	89 e0       	ldi	r24, 0x09	; 9
     80c:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x10;	/* R10 */
     80e:	80 e1       	ldi	r24, 0x10	; 16
     810:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x11;	/* R11 */
     812:	22 93       	st	-Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x12;	/* R12 */
     814:	82 e1       	ldi	r24, 0x12	; 18
     816:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x13;	/* R13 */
     818:	83 e1       	ldi	r24, 0x13	; 19
     81a:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x14;	/* R14 */
     81c:	84 e1       	ldi	r24, 0x14	; 20
     81e:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x15;	/* R15 */
     820:	85 e1       	ldi	r24, 0x15	; 21
     822:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x16;	/* R16 */
     824:	86 e1       	ldi	r24, 0x16	; 22
     826:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x17;	/* R17 */
     828:	87 e1       	ldi	r24, 0x17	; 23
     82a:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x18;	/* R18 */
     82c:	88 e1       	ldi	r24, 0x18	; 24
     82e:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x19;	/* R19 */
     830:	89 e1       	ldi	r24, 0x19	; 25
     832:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x20;	/* R20 */
     834:	80 e2       	ldi	r24, 0x20	; 32
     836:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x21;	/* R21 */
     838:	81 e2       	ldi	r24, 0x21	; 33
     83a:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x22;	/* R22 */
     83c:	92 93       	st	-Z, r25
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x23;	/* R23 */
     83e:	83 e2       	ldi	r24, 0x23	; 35
     840:	82 93       	st	-Z, r24
	pxTopOfStack--;

	/* Place the parameter on the stack in the expected location. */
	usAddress = ( unsigned short ) pvParameters;
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned short ) 0x00ff );
     842:	42 93       	st	-Z, r20
	pxTopOfStack--;

	usAddress >>= 8;
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned short ) 0x00ff );
     844:	52 93       	st	-Z, r21
	pxTopOfStack--;

	*pxTopOfStack = ( portSTACK_TYPE ) 0x26;	/* R26 X */
     846:	86 e2       	ldi	r24, 0x26	; 38
     848:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x27;	/* R27 */
     84a:	87 e2       	ldi	r24, 0x27	; 39
     84c:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x28;	/* R28 Y */
     84e:	88 e2       	ldi	r24, 0x28	; 40
     850:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x29;	/* R29 */
     852:	89 e2       	ldi	r24, 0x29	; 41
     854:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x30;	/* R30 Z */
     856:	80 e3       	ldi	r24, 0x30	; 48
     858:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x031;	/* R31 */
     85a:	81 e3       	ldi	r24, 0x31	; 49
     85c:	82 93       	st	-Z, r24
	pxTopOfStack--;
     85e:	9f 01       	movw	r18, r30
     860:	21 50       	subi	r18, 0x01	; 1
     862:	30 40       	sbci	r19, 0x00	; 0

	/*lint +e950 +e611 +e923 */

	return pxTopOfStack;
}
     864:	82 2f       	mov	r24, r18
     866:	93 2f       	mov	r25, r19
     868:	08 95       	ret

0000086a <xPortStartScheduler>:
	/* Setup compare match value for compare match A.  Interrupts are disabled 
	before this is called so we need not worry here. */
	ucLowByte = ( unsigned char ) ( ulCompareMatch & ( unsigned long ) 0xff );
	ulCompareMatch >>= 8;
	ucHighByte = ( unsigned char ) ( ulCompareMatch & ( unsigned long ) 0xff );
	OCR1AH = ucHighByte;
     86a:	1b bc       	out	0x2b, r1	; 43
	OCR1AL = ucLowByte;
     86c:	8c e7       	ldi	r24, 0x7C	; 124
     86e:	8a bd       	out	0x2a, r24	; 42

	/* Setup clock source and compare match behaviour. */
	ucLowByte = portCLEAR_COUNTER_ON_MATCH | portPRESCALE_64;
	TCCR1B = ucLowByte;
     870:	8b e0       	ldi	r24, 0x0B	; 11
     872:	8e bd       	out	0x2e, r24	; 46

	/* Enable the interrupt - this is okay as interrupt are currently globally
	disabled. */
	ucLowByte = TIMSK;
     874:	89 b7       	in	r24, 0x39	; 57
	ucLowByte |= portCOMPARE_MATCH_A_INTERRUPT_ENABLE;
     876:	80 61       	ori	r24, 0x10	; 16
	TIMSK = ucLowByte;
     878:	89 bf       	out	0x39, r24	; 57
{
	/* Setup the hardware to generate the tick. */
	prvSetupTimerInterrupt();

	/* Restore the context of the first task that is going to run. */
	portRESTORE_CONTEXT();
     87a:	a0 91 12 03 	lds	r26, 0x0312
     87e:	b0 91 13 03 	lds	r27, 0x0313
     882:	cd 91       	ld	r28, X+
     884:	cd bf       	out	0x3d, r28	; 61
     886:	dd 91       	ld	r29, X+
     888:	de bf       	out	0x3e, r29	; 62
     88a:	ff 91       	pop	r31
     88c:	ef 91       	pop	r30
     88e:	df 91       	pop	r29
     890:	cf 91       	pop	r28
     892:	bf 91       	pop	r27
     894:	af 91       	pop	r26
     896:	9f 91       	pop	r25
     898:	8f 91       	pop	r24
     89a:	7f 91       	pop	r23
     89c:	6f 91       	pop	r22
     89e:	5f 91       	pop	r21
     8a0:	4f 91       	pop	r20
     8a2:	3f 91       	pop	r19
     8a4:	2f 91       	pop	r18
     8a6:	1f 91       	pop	r17
     8a8:	0f 91       	pop	r16
     8aa:	ff 90       	pop	r15
     8ac:	ef 90       	pop	r14
     8ae:	df 90       	pop	r13
     8b0:	cf 90       	pop	r12
     8b2:	bf 90       	pop	r11
     8b4:	af 90       	pop	r10
     8b6:	9f 90       	pop	r9
     8b8:	8f 90       	pop	r8
     8ba:	7f 90       	pop	r7
     8bc:	6f 90       	pop	r6
     8be:	5f 90       	pop	r5
     8c0:	4f 90       	pop	r4
     8c2:	3f 90       	pop	r3
     8c4:	2f 90       	pop	r2
     8c6:	1f 90       	pop	r1
     8c8:	0f 90       	pop	r0
     8ca:	0f be       	out	0x3f, r0	; 63
     8cc:	0f 90       	pop	r0

	/* Simulate a function call end as generated by the compiler.  We will now
	jump to the start of the task the context of which we have just restored. */
	asm volatile ( "ret" );
     8ce:	08 95       	ret

	/* Should not get here. */
	return pdTRUE;
}
     8d0:	81 e0       	ldi	r24, 0x01	; 1
     8d2:	08 95       	ret

000008d4 <vPortEndScheduler>:

void vPortEndScheduler( void )
{
	/* It is unlikely that the AVR port will get stopped.  If required simply
	disable the tick interrupt here. */
}
     8d4:	08 95       	ret

000008d6 <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
     8d6:	0f 92       	push	r0
     8d8:	0f b6       	in	r0, 0x3f	; 63
     8da:	f8 94       	cli
     8dc:	0f 92       	push	r0
     8de:	1f 92       	push	r1
     8e0:	11 24       	eor	r1, r1
     8e2:	2f 92       	push	r2
     8e4:	3f 92       	push	r3
     8e6:	4f 92       	push	r4
     8e8:	5f 92       	push	r5
     8ea:	6f 92       	push	r6
     8ec:	7f 92       	push	r7
     8ee:	8f 92       	push	r8
     8f0:	9f 92       	push	r9
     8f2:	af 92       	push	r10
     8f4:	bf 92       	push	r11
     8f6:	cf 92       	push	r12
     8f8:	df 92       	push	r13
     8fa:	ef 92       	push	r14
     8fc:	ff 92       	push	r15
     8fe:	0f 93       	push	r16
     900:	1f 93       	push	r17
     902:	2f 93       	push	r18
     904:	3f 93       	push	r19
     906:	4f 93       	push	r20
     908:	5f 93       	push	r21
     90a:	6f 93       	push	r22
     90c:	7f 93       	push	r23
     90e:	8f 93       	push	r24
     910:	9f 93       	push	r25
     912:	af 93       	push	r26
     914:	bf 93       	push	r27
     916:	cf 93       	push	r28
     918:	df 93       	push	r29
     91a:	ef 93       	push	r30
     91c:	ff 93       	push	r31
     91e:	a0 91 12 03 	lds	r26, 0x0312
     922:	b0 91 13 03 	lds	r27, 0x0313
     926:	0d b6       	in	r0, 0x3d	; 61
     928:	0d 92       	st	X+, r0
     92a:	0e b6       	in	r0, 0x3e	; 62
     92c:	0d 92       	st	X+, r0
	vTaskSwitchContext();
     92e:	0e 94 55 0d 	call	0x1aaa	; 0x1aaa <vTaskSwitchContext>
	portRESTORE_CONTEXT();
     932:	a0 91 12 03 	lds	r26, 0x0312
     936:	b0 91 13 03 	lds	r27, 0x0313
     93a:	cd 91       	ld	r28, X+
     93c:	cd bf       	out	0x3d, r28	; 61
     93e:	dd 91       	ld	r29, X+
     940:	de bf       	out	0x3e, r29	; 62
     942:	ff 91       	pop	r31
     944:	ef 91       	pop	r30
     946:	df 91       	pop	r29
     948:	cf 91       	pop	r28
     94a:	bf 91       	pop	r27
     94c:	af 91       	pop	r26
     94e:	9f 91       	pop	r25
     950:	8f 91       	pop	r24
     952:	7f 91       	pop	r23
     954:	6f 91       	pop	r22
     956:	5f 91       	pop	r21
     958:	4f 91       	pop	r20
     95a:	3f 91       	pop	r19
     95c:	2f 91       	pop	r18
     95e:	1f 91       	pop	r17
     960:	0f 91       	pop	r16
     962:	ff 90       	pop	r15
     964:	ef 90       	pop	r14
     966:	df 90       	pop	r13
     968:	cf 90       	pop	r12
     96a:	bf 90       	pop	r11
     96c:	af 90       	pop	r10
     96e:	9f 90       	pop	r9
     970:	8f 90       	pop	r8
     972:	7f 90       	pop	r7
     974:	6f 90       	pop	r6
     976:	5f 90       	pop	r5
     978:	4f 90       	pop	r4
     97a:	3f 90       	pop	r3
     97c:	2f 90       	pop	r2
     97e:	1f 90       	pop	r1
     980:	0f 90       	pop	r0
     982:	0f be       	out	0x3f, r0	; 63
     984:	0f 90       	pop	r0

	asm volatile ( "ret" );
     986:	08 95       	ret

00000988 <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
     988:	0f 92       	push	r0
     98a:	0f b6       	in	r0, 0x3f	; 63
     98c:	f8 94       	cli
     98e:	0f 92       	push	r0
     990:	1f 92       	push	r1
     992:	11 24       	eor	r1, r1
     994:	2f 92       	push	r2
     996:	3f 92       	push	r3
     998:	4f 92       	push	r4
     99a:	5f 92       	push	r5
     99c:	6f 92       	push	r6
     99e:	7f 92       	push	r7
     9a0:	8f 92       	push	r8
     9a2:	9f 92       	push	r9
     9a4:	af 92       	push	r10
     9a6:	bf 92       	push	r11
     9a8:	cf 92       	push	r12
     9aa:	df 92       	push	r13
     9ac:	ef 92       	push	r14
     9ae:	ff 92       	push	r15
     9b0:	0f 93       	push	r16
     9b2:	1f 93       	push	r17
     9b4:	2f 93       	push	r18
     9b6:	3f 93       	push	r19
     9b8:	4f 93       	push	r20
     9ba:	5f 93       	push	r21
     9bc:	6f 93       	push	r22
     9be:	7f 93       	push	r23
     9c0:	8f 93       	push	r24
     9c2:	9f 93       	push	r25
     9c4:	af 93       	push	r26
     9c6:	bf 93       	push	r27
     9c8:	cf 93       	push	r28
     9ca:	df 93       	push	r29
     9cc:	ef 93       	push	r30
     9ce:	ff 93       	push	r31
     9d0:	a0 91 12 03 	lds	r26, 0x0312
     9d4:	b0 91 13 03 	lds	r27, 0x0313
     9d8:	0d b6       	in	r0, 0x3d	; 61
     9da:	0d 92       	st	X+, r0
     9dc:	0e b6       	in	r0, 0x3e	; 62
     9de:	0d 92       	st	X+, r0
	vTaskIncrementTick();
     9e0:	0e 94 56 0b 	call	0x16ac	; 0x16ac <vTaskIncrementTick>
	vTaskSwitchContext();
     9e4:	0e 94 55 0d 	call	0x1aaa	; 0x1aaa <vTaskSwitchContext>
	portRESTORE_CONTEXT();
     9e8:	a0 91 12 03 	lds	r26, 0x0312
     9ec:	b0 91 13 03 	lds	r27, 0x0313
     9f0:	cd 91       	ld	r28, X+
     9f2:	cd bf       	out	0x3d, r28	; 61
     9f4:	dd 91       	ld	r29, X+
     9f6:	de bf       	out	0x3e, r29	; 62
     9f8:	ff 91       	pop	r31
     9fa:	ef 91       	pop	r30
     9fc:	df 91       	pop	r29
     9fe:	cf 91       	pop	r28
     a00:	bf 91       	pop	r27
     a02:	af 91       	pop	r26
     a04:	9f 91       	pop	r25
     a06:	8f 91       	pop	r24
     a08:	7f 91       	pop	r23
     a0a:	6f 91       	pop	r22
     a0c:	5f 91       	pop	r21
     a0e:	4f 91       	pop	r20
     a10:	3f 91       	pop	r19
     a12:	2f 91       	pop	r18
     a14:	1f 91       	pop	r17
     a16:	0f 91       	pop	r16
     a18:	ff 90       	pop	r15
     a1a:	ef 90       	pop	r14
     a1c:	df 90       	pop	r13
     a1e:	cf 90       	pop	r12
     a20:	bf 90       	pop	r11
     a22:	af 90       	pop	r10
     a24:	9f 90       	pop	r9
     a26:	8f 90       	pop	r8
     a28:	7f 90       	pop	r7
     a2a:	6f 90       	pop	r6
     a2c:	5f 90       	pop	r5
     a2e:	4f 90       	pop	r4
     a30:	3f 90       	pop	r3
     a32:	2f 90       	pop	r2
     a34:	1f 90       	pop	r1
     a36:	0f 90       	pop	r0
     a38:	0f be       	out	0x3f, r0	; 63
     a3a:	0f 90       	pop	r0

	asm volatile ( "ret" );
     a3c:	08 95       	ret

00000a3e <__vector_7>:
	 * count is incremented after the context is saved.
	 */
	void SIG_OUTPUT_COMPARE1A( void ) __attribute__ ( ( signal, naked ) );
	void SIG_OUTPUT_COMPARE1A( void )
	{
		vPortYieldFromTick();
     a3e:	0e 94 c4 04 	call	0x988	; 0x988 <vPortYieldFromTick>
		asm volatile ( "reti" );
     a42:	18 95       	reti

00000a44 <prvCopyDataFromQueue>:
	++( pxQueue->uxMessagesWaiting );
}
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( xQUEUE * const pxQueue, const void *pvBuffer )
{
     a44:	cf 93       	push	r28
     a46:	df 93       	push	r29
     a48:	fc 01       	movw	r30, r24
	if( pxQueue->uxQueueType != queueQUEUE_IS_MUTEX )
     a4a:	a0 81       	ld	r26, Z
     a4c:	b1 81       	ldd	r27, Z+1	; 0x01
     a4e:	10 97       	sbiw	r26, 0x00	; 0
     a50:	b9 f0       	breq	.+46     	; 0xa80 <prvCopyDataFromQueue+0x3c>
	{
		pxQueue->pcReadFrom += pxQueue->uxItemSize;
     a52:	44 8d       	ldd	r20, Z+28	; 0x1c
     a54:	26 81       	ldd	r18, Z+6	; 0x06
     a56:	37 81       	ldd	r19, Z+7	; 0x07
     a58:	24 0f       	add	r18, r20
     a5a:	31 1d       	adc	r19, r1
     a5c:	37 83       	std	Z+7, r19	; 0x07
     a5e:	26 83       	std	Z+6, r18	; 0x06
		if( pxQueue->pcReadFrom >= pxQueue->pcTail )
     a60:	c2 81       	ldd	r28, Z+2	; 0x02
     a62:	d3 81       	ldd	r29, Z+3	; 0x03
     a64:	2c 17       	cp	r18, r28
     a66:	3d 07       	cpc	r19, r29
     a68:	10 f0       	brcs	.+4      	; 0xa6e <prvCopyDataFromQueue+0x2a>
		{
			pxQueue->pcReadFrom = pxQueue->pcHead;
     a6a:	b7 83       	std	Z+7, r27	; 0x07
     a6c:	a6 83       	std	Z+6, r26	; 0x06
		}
		memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
     a6e:	36 81       	ldd	r19, Z+6	; 0x06
     a70:	27 81       	ldd	r18, Z+7	; 0x07
     a72:	86 2f       	mov	r24, r22
     a74:	97 2f       	mov	r25, r23
     a76:	63 2f       	mov	r22, r19
     a78:	72 2f       	mov	r23, r18
     a7a:	50 e0       	ldi	r21, 0x00	; 0
     a7c:	0e 94 d2 0e 	call	0x1da4	; 0x1da4 <memcpy>
	}
}
     a80:	df 91       	pop	r29
     a82:	cf 91       	pop	r28
     a84:	08 95       	ret

00000a86 <prvCopyDataToQueue>:
	vPortFree( pxQueue );
}
/*-----------------------------------------------------------*/

static void prvCopyDataToQueue( xQUEUE *pxQueue, const void *pvItemToQueue, portBASE_TYPE xPosition )
{
     a86:	cf 93       	push	r28
     a88:	df 93       	push	r29
     a8a:	ec 01       	movw	r28, r24
	if( pxQueue->uxItemSize == ( unsigned portBASE_TYPE ) 0 )
     a8c:	2c 8d       	ldd	r18, Y+28	; 0x1c
     a8e:	22 23       	and	r18, r18
     a90:	a9 f1       	breq	.+106    	; 0xafc <prvCopyDataToQueue+0x76>
				pxQueue->pxMutexHolder = NULL;
			}
		}
		#endif
	}
	else if( xPosition == queueSEND_TO_BACK )
     a92:	44 23       	and	r20, r20
     a94:	b9 f4       	brne	.+46     	; 0xac4 <prvCopyDataToQueue+0x3e>
	{
		memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
     a96:	8c 81       	ldd	r24, Y+4	; 0x04
     a98:	9d 81       	ldd	r25, Y+5	; 0x05
     a9a:	42 2f       	mov	r20, r18
     a9c:	50 e0       	ldi	r21, 0x00	; 0
     a9e:	0e 94 d2 0e 	call	0x1da4	; 0x1da4 <memcpy>
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
     aa2:	2c 8d       	ldd	r18, Y+28	; 0x1c
     aa4:	8c 81       	ldd	r24, Y+4	; 0x04
     aa6:	9d 81       	ldd	r25, Y+5	; 0x05
     aa8:	82 0f       	add	r24, r18
     aaa:	91 1d       	adc	r25, r1
     aac:	9d 83       	std	Y+5, r25	; 0x05
     aae:	8c 83       	std	Y+4, r24	; 0x04
		if( pxQueue->pcWriteTo >= pxQueue->pcTail )
     ab0:	2a 81       	ldd	r18, Y+2	; 0x02
     ab2:	3b 81       	ldd	r19, Y+3	; 0x03
     ab4:	82 17       	cp	r24, r18
     ab6:	93 07       	cpc	r25, r19
     ab8:	08 f1       	brcs	.+66     	; 0xafc <prvCopyDataToQueue+0x76>
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
     aba:	88 81       	ld	r24, Y
     abc:	99 81       	ldd	r25, Y+1	; 0x01
     abe:	9d 83       	std	Y+5, r25	; 0x05
     ac0:	8c 83       	std	Y+4, r24	; 0x04
     ac2:	1c c0       	rjmp	.+56     	; 0xafc <prvCopyDataToQueue+0x76>
		}
	}
	else
	{
		memcpy( ( void * ) pxQueue->pcReadFrom, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
     ac4:	8e 81       	ldd	r24, Y+6	; 0x06
     ac6:	9f 81       	ldd	r25, Y+7	; 0x07
     ac8:	42 2f       	mov	r20, r18
     aca:	50 e0       	ldi	r21, 0x00	; 0
     acc:	0e 94 d2 0e 	call	0x1da4	; 0x1da4 <memcpy>
		pxQueue->pcReadFrom -= pxQueue->uxItemSize;
     ad0:	2c 8d       	ldd	r18, Y+28	; 0x1c
     ad2:	30 e0       	ldi	r19, 0x00	; 0
     ad4:	30 95       	com	r19
     ad6:	21 95       	neg	r18
     ad8:	3f 4f       	sbci	r19, 0xFF	; 255
     ada:	8e 81       	ldd	r24, Y+6	; 0x06
     adc:	9f 81       	ldd	r25, Y+7	; 0x07
     ade:	82 0f       	add	r24, r18
     ae0:	93 1f       	adc	r25, r19
     ae2:	9f 83       	std	Y+7, r25	; 0x07
     ae4:	8e 83       	std	Y+6, r24	; 0x06
		if( pxQueue->pcReadFrom < pxQueue->pcHead )
     ae6:	48 81       	ld	r20, Y
     ae8:	59 81       	ldd	r21, Y+1	; 0x01
     aea:	84 17       	cp	r24, r20
     aec:	95 07       	cpc	r25, r21
     aee:	30 f4       	brcc	.+12     	; 0xafc <prvCopyDataToQueue+0x76>
		{
			pxQueue->pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
     af0:	8a 81       	ldd	r24, Y+2	; 0x02
     af2:	9b 81       	ldd	r25, Y+3	; 0x03
     af4:	28 0f       	add	r18, r24
     af6:	39 1f       	adc	r19, r25
     af8:	3f 83       	std	Y+7, r19	; 0x07
     afa:	2e 83       	std	Y+6, r18	; 0x06
		}
	}

	++( pxQueue->uxMessagesWaiting );
     afc:	8a 8d       	ldd	r24, Y+26	; 0x1a
     afe:	8f 5f       	subi	r24, 0xFF	; 255
     b00:	8a 8f       	std	Y+26, r24	; 0x1a
}
     b02:	df 91       	pop	r29
     b04:	cf 91       	pop	r28
     b06:	08 95       	ret

00000b08 <prvUnlockQueue>:
	}
}
/*-----------------------------------------------------------*/

static void prvUnlockQueue( xQueueHandle pxQueue )
{
     b08:	0f 93       	push	r16
     b0a:	1f 93       	push	r17
     b0c:	cf 93       	push	r28
     b0e:	df 93       	push	r29
     b10:	ec 01       	movw	r28, r24

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
     b12:	0f b6       	in	r0, 0x3f	; 63
     b14:	f8 94       	cli
     b16:	0f 92       	push	r0
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
     b18:	8e 8d       	ldd	r24, Y+30	; 0x1e
     b1a:	18 16       	cp	r1, r24
     b1c:	bc f4       	brge	.+46     	; 0xb4c <prvUnlockQueue+0x44>
		{
			/* Data was posted while the queue was locked.  Are any tasks
			blocked waiting for data to become available? */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
     b1e:	89 89       	ldd	r24, Y+17	; 0x11
     b20:	88 23       	and	r24, r24
     b22:	29 f4       	brne	.+10     	; 0xb2e <prvUnlockQueue+0x26>
     b24:	13 c0       	rjmp	.+38     	; 0xb4c <prvUnlockQueue+0x44>
     b26:	89 89       	ldd	r24, Y+17	; 0x11
     b28:	88 23       	and	r24, r24
     b2a:	21 f4       	brne	.+8      	; 0xb34 <prvUnlockQueue+0x2c>
     b2c:	0f c0       	rjmp	.+30     	; 0xb4c <prvUnlockQueue+0x44>
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
     b2e:	8e 01       	movw	r16, r28
     b30:	0f 5e       	subi	r16, 0xEF	; 239
     b32:	1f 4f       	sbci	r17, 0xFF	; 255
     b34:	c8 01       	movw	r24, r16
     b36:	0e 94 41 0e 	call	0x1c82	; 0x1c82 <xTaskRemoveFromEventList>
     b3a:	88 23       	and	r24, r24
     b3c:	11 f0       	breq	.+4      	; 0xb42 <prvUnlockQueue+0x3a>
				{
					/* The task waiting has a higher priority so record that a
					context	switch is required. */
					vTaskMissedYield();
     b3e:	0e 94 ce 0e 	call	0x1d9c	; 0x1d9c <vTaskMissedYield>
				}

				--( pxQueue->xTxLock );
     b42:	8e 8d       	ldd	r24, Y+30	; 0x1e
     b44:	81 50       	subi	r24, 0x01	; 1
     b46:	8e 8f       	std	Y+30, r24	; 0x1e
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
     b48:	18 16       	cp	r1, r24
     b4a:	6c f3       	brlt	.-38     	; 0xb26 <prvUnlockQueue+0x1e>
			{
				break;
			}
		}

		pxQueue->xTxLock = queueUNLOCKED;
     b4c:	8f ef       	ldi	r24, 0xFF	; 255
     b4e:	8e 8f       	std	Y+30, r24	; 0x1e
	}
	taskEXIT_CRITICAL();
     b50:	0f 90       	pop	r0
     b52:	0f be       	out	0x3f, r0	; 63

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
     b54:	0f b6       	in	r0, 0x3f	; 63
     b56:	f8 94       	cli
     b58:	0f 92       	push	r0
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
     b5a:	8d 8d       	ldd	r24, Y+29	; 0x1d
     b5c:	18 16       	cp	r1, r24
     b5e:	bc f4       	brge	.+46     	; 0xb8e <prvUnlockQueue+0x86>
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
     b60:	88 85       	ldd	r24, Y+8	; 0x08
     b62:	88 23       	and	r24, r24
     b64:	29 f4       	brne	.+10     	; 0xb70 <prvUnlockQueue+0x68>
     b66:	13 c0       	rjmp	.+38     	; 0xb8e <prvUnlockQueue+0x86>
     b68:	88 85       	ldd	r24, Y+8	; 0x08
     b6a:	88 23       	and	r24, r24
     b6c:	21 f4       	brne	.+8      	; 0xb76 <prvUnlockQueue+0x6e>
     b6e:	0f c0       	rjmp	.+30     	; 0xb8e <prvUnlockQueue+0x86>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
     b70:	8e 01       	movw	r16, r28
     b72:	08 5f       	subi	r16, 0xF8	; 248
     b74:	1f 4f       	sbci	r17, 0xFF	; 255
     b76:	c8 01       	movw	r24, r16
     b78:	0e 94 41 0e 	call	0x1c82	; 0x1c82 <xTaskRemoveFromEventList>
     b7c:	88 23       	and	r24, r24
     b7e:	11 f0       	breq	.+4      	; 0xb84 <prvUnlockQueue+0x7c>
				{
					vTaskMissedYield();
     b80:	0e 94 ce 0e 	call	0x1d9c	; 0x1d9c <vTaskMissedYield>
				}

				--( pxQueue->xRxLock );
     b84:	8d 8d       	ldd	r24, Y+29	; 0x1d
     b86:	81 50       	subi	r24, 0x01	; 1
     b88:	8d 8f       	std	Y+29, r24	; 0x1d
	taskEXIT_CRITICAL();

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
     b8a:	18 16       	cp	r1, r24
     b8c:	6c f3       	brlt	.-38     	; 0xb68 <prvUnlockQueue+0x60>
			{
				break;
			}
		}

		pxQueue->xRxLock = queueUNLOCKED;
     b8e:	8f ef       	ldi	r24, 0xFF	; 255
     b90:	8d 8f       	std	Y+29, r24	; 0x1d
	}
	taskEXIT_CRITICAL();
     b92:	0f 90       	pop	r0
     b94:	0f be       	out	0x3f, r0	; 63
}
     b96:	df 91       	pop	r29
     b98:	cf 91       	pop	r28
     b9a:	1f 91       	pop	r17
     b9c:	0f 91       	pop	r16
     b9e:	08 95       	ret

00000ba0 <xQueueCreate>:
/*-----------------------------------------------------------
 * PUBLIC QUEUE MANAGEMENT API documented in queue.h
 *----------------------------------------------------------*/

xQueueHandle xQueueCreate( unsigned portBASE_TYPE uxQueueLength, unsigned portBASE_TYPE uxItemSize )
{
     ba0:	8f 92       	push	r8
     ba2:	9f 92       	push	r9
     ba4:	af 92       	push	r10
     ba6:	bf 92       	push	r11
     ba8:	cf 92       	push	r12
     baa:	df 92       	push	r13
     bac:	ef 92       	push	r14
     bae:	ff 92       	push	r15
     bb0:	0f 93       	push	r16
     bb2:	1f 93       	push	r17
     bb4:	cf 93       	push	r28
     bb6:	df 93       	push	r29
     bb8:	18 2f       	mov	r17, r24
     bba:	06 2f       	mov	r16, r22
xQUEUE *pxNewQueue;
size_t xQueueSizeInBytes;
xQueueHandle xReturn = NULL;

	/* Allocate the new queue structure. */
	if( uxQueueLength > ( unsigned portBASE_TYPE ) 0 )
     bbc:	88 23       	and	r24, r24
     bbe:	09 f4       	brne	.+2      	; 0xbc2 <xQueueCreate+0x22>
     bc0:	49 c0       	rjmp	.+146    	; 0xc54 <xQueueCreate+0xb4>
	{
		pxNewQueue = ( xQUEUE * ) pvPortMalloc( sizeof( xQUEUE ) );
     bc2:	8f e1       	ldi	r24, 0x1F	; 31
     bc4:	90 e0       	ldi	r25, 0x00	; 0
     bc6:	0e 94 80 02 	call	0x500	; 0x500 <pvPortMalloc>
     bca:	e8 2e       	mov	r14, r24
     bcc:	f9 2e       	mov	r15, r25
     bce:	e7 01       	movw	r28, r14
		if( pxNewQueue != NULL )
     bd0:	20 97       	sbiw	r28, 0x00	; 0
     bd2:	09 f4       	brne	.+2      	; 0xbd6 <xQueueCreate+0x36>
     bd4:	42 c0       	rjmp	.+132    	; 0xc5a <xQueueCreate+0xba>
		{
			/* Create the list of pointers to queue items.  The queue is one byte
			longer than asked for to make wrap checking easier/faster. */
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ) + ( size_t ) 1;
     bd6:	a1 2e       	mov	r10, r17
     bd8:	bb 24       	eor	r11, r11
     bda:	80 2e       	mov	r8, r16
     bdc:	99 24       	eor	r9, r9
     bde:	8a 9c       	mul	r8, r10
     be0:	60 01       	movw	r12, r0
     be2:	8b 9c       	mul	r8, r11
     be4:	d0 0c       	add	r13, r0
     be6:	9a 9c       	mul	r9, r10
     be8:	d0 0c       	add	r13, r0
     bea:	11 24       	eor	r1, r1

			pxNewQueue->pcHead = ( signed char * ) pvPortMalloc( xQueueSizeInBytes );
     bec:	c6 01       	movw	r24, r12
     bee:	01 96       	adiw	r24, 0x01	; 1
     bf0:	0e 94 80 02 	call	0x500	; 0x500 <pvPortMalloc>
     bf4:	28 2f       	mov	r18, r24
     bf6:	39 2f       	mov	r19, r25
     bf8:	39 83       	std	Y+1, r19	; 0x01
     bfa:	28 83       	st	Y, r18
			if( pxNewQueue->pcHead != NULL )
     bfc:	21 15       	cp	r18, r1
     bfe:	31 05       	cpc	r19, r1
     c00:	19 f1       	breq	.+70     	; 0xc48 <xQueueCreate+0xa8>
			{
				/* Initialise the queue members as described above where the
				queue type is defined. */
				pxNewQueue->pcTail = pxNewQueue->pcHead + ( uxQueueLength * uxItemSize );
     c02:	c2 0e       	add	r12, r18
     c04:	d3 1e       	adc	r13, r19
     c06:	db 82       	std	Y+3, r13	; 0x03
     c08:	ca 82       	std	Y+2, r12	; 0x02
				pxNewQueue->uxMessagesWaiting = ( unsigned portBASE_TYPE ) 0U;
     c0a:	1a 8e       	std	Y+26, r1	; 0x1a
				pxNewQueue->pcWriteTo = pxNewQueue->pcHead;
     c0c:	3d 83       	std	Y+5, r19	; 0x05
     c0e:	2c 83       	std	Y+4, r18	; 0x04
				pxNewQueue->pcReadFrom = pxNewQueue->pcHead + ( ( uxQueueLength - ( unsigned portBASE_TYPE ) 1U ) * uxItemSize );
     c10:	08 94       	sec
     c12:	a1 08       	sbc	r10, r1
     c14:	b1 08       	sbc	r11, r1
     c16:	a8 9c       	mul	r10, r8
     c18:	c0 01       	movw	r24, r0
     c1a:	a9 9c       	mul	r10, r9
     c1c:	90 0d       	add	r25, r0
     c1e:	b8 9c       	mul	r11, r8
     c20:	90 0d       	add	r25, r0
     c22:	11 24       	eor	r1, r1
     c24:	28 0f       	add	r18, r24
     c26:	39 1f       	adc	r19, r25
     c28:	3f 83       	std	Y+7, r19	; 0x07
     c2a:	2e 83       	std	Y+6, r18	; 0x06
				pxNewQueue->uxLength = uxQueueLength;
     c2c:	1b 8f       	std	Y+27, r17	; 0x1b
				pxNewQueue->uxItemSize = uxItemSize;
     c2e:	0c 8f       	std	Y+28, r16	; 0x1c
				pxNewQueue->xRxLock = queueUNLOCKED;
     c30:	8f ef       	ldi	r24, 0xFF	; 255
     c32:	8d 8f       	std	Y+29, r24	; 0x1d
				pxNewQueue->xTxLock = queueUNLOCKED;
     c34:	8e 8f       	std	Y+30, r24	; 0x1e

				/* Likewise ensure the event queues start with the correct state. */
				vListInitialise( &( pxNewQueue->xTasksWaitingToSend ) );
     c36:	ce 01       	movw	r24, r28
     c38:	08 96       	adiw	r24, 0x08	; 8
     c3a:	0e 94 4c 03 	call	0x698	; 0x698 <vListInitialise>
				vListInitialise( &( pxNewQueue->xTasksWaitingToReceive ) );
     c3e:	ce 01       	movw	r24, r28
     c40:	41 96       	adiw	r24, 0x11	; 17
     c42:	0e 94 4c 03 	call	0x698	; 0x698 <vListInitialise>
     c46:	0b c0       	rjmp	.+22     	; 0xc5e <xQueueCreate+0xbe>
				xReturn = pxNewQueue;
			}
			else
			{
				traceQUEUE_CREATE_FAILED();
				vPortFree( pxNewQueue );
     c48:	ce 01       	movw	r24, r28
     c4a:	0e 94 ae 02 	call	0x55c	; 0x55c <vPortFree>

xQueueHandle xQueueCreate( unsigned portBASE_TYPE uxQueueLength, unsigned portBASE_TYPE uxItemSize )
{
xQUEUE *pxNewQueue;
size_t xQueueSizeInBytes;
xQueueHandle xReturn = NULL;
     c4e:	c0 e0       	ldi	r28, 0x00	; 0
     c50:	d0 e0       	ldi	r29, 0x00	; 0
     c52:	05 c0       	rjmp	.+10     	; 0xc5e <xQueueCreate+0xbe>
     c54:	c0 e0       	ldi	r28, 0x00	; 0
     c56:	d0 e0       	ldi	r29, 0x00	; 0
     c58:	02 c0       	rjmp	.+4      	; 0xc5e <xQueueCreate+0xbe>
     c5a:	c0 e0       	ldi	r28, 0x00	; 0
     c5c:	d0 e0       	ldi	r29, 0x00	; 0
	}

	configASSERT( xReturn );

	return xReturn;
}
     c5e:	7e 01       	movw	r14, r28
     c60:	8c 2f       	mov	r24, r28
     c62:	9f 2d       	mov	r25, r15
     c64:	df 91       	pop	r29
     c66:	cf 91       	pop	r28
     c68:	1f 91       	pop	r17
     c6a:	0f 91       	pop	r16
     c6c:	ff 90       	pop	r15
     c6e:	ef 90       	pop	r14
     c70:	df 90       	pop	r13
     c72:	cf 90       	pop	r12
     c74:	bf 90       	pop	r11
     c76:	af 90       	pop	r10
     c78:	9f 90       	pop	r9
     c7a:	8f 90       	pop	r8
     c7c:	08 95       	ret

00000c7e <xQueueCreateCountingSemaphore>:
/*-----------------------------------------------------------*/

#if configUSE_COUNTING_SEMAPHORES == 1

	xQueueHandle xQueueCreateCountingSemaphore( unsigned portBASE_TYPE uxCountValue, unsigned portBASE_TYPE uxInitialCount )
	{
     c7e:	1f 93       	push	r17
     c80:	16 2f       	mov	r17, r22
	xQueueHandle pxHandle;

		pxHandle = xQueueCreate( ( unsigned portBASE_TYPE ) uxCountValue, queueSEMAPHORE_QUEUE_ITEM_LENGTH );
     c82:	60 e0       	ldi	r22, 0x00	; 0
     c84:	0e 94 d0 05 	call	0xba0	; 0xba0 <xQueueCreate>
     c88:	fc 01       	movw	r30, r24

		if( pxHandle != NULL )
     c8a:	00 97       	sbiw	r24, 0x00	; 0
     c8c:	09 f0       	breq	.+2      	; 0xc90 <xQueueCreateCountingSemaphore+0x12>
		{
			pxHandle->uxMessagesWaiting = uxInitialCount;
     c8e:	12 8f       	std	Z+26, r17	; 0x1a
			traceCREATE_COUNTING_SEMAPHORE_FAILED();
		}

		configASSERT( pxHandle );
		return pxHandle;
	}
     c90:	8e 2f       	mov	r24, r30
     c92:	9f 2f       	mov	r25, r31
     c94:	1f 91       	pop	r17
     c96:	08 95       	ret

00000c98 <xQueueGenericSend>:

#endif /* configUSE_COUNTING_SEMAPHORES */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSend( xQueueHandle pxQueue, const void * const pvItemToQueue, portTickType xTicksToWait, portBASE_TYPE xCopyPosition )
{
     c98:	5f 92       	push	r5
     c9a:	6f 92       	push	r6
     c9c:	7f 92       	push	r7
     c9e:	8f 92       	push	r8
     ca0:	9f 92       	push	r9
     ca2:	af 92       	push	r10
     ca4:	bf 92       	push	r11
     ca6:	cf 92       	push	r12
     ca8:	df 92       	push	r13
     caa:	ef 92       	push	r14
     cac:	ff 92       	push	r15
     cae:	0f 93       	push	r16
     cb0:	1f 93       	push	r17
     cb2:	df 93       	push	r29
     cb4:	cf 93       	push	r28
     cb6:	00 d0       	rcall	.+0      	; 0xcb8 <xQueueGenericSend+0x20>
     cb8:	00 d0       	rcall	.+0      	; 0xcba <xQueueGenericSend+0x22>
     cba:	0f 92       	push	r0
     cbc:	cd b7       	in	r28, 0x3d	; 61
     cbe:	de b7       	in	r29, 0x3e	; 62
     cc0:	8c 01       	movw	r16, r24
     cc2:	3b 01       	movw	r6, r22
     cc4:	5d 83       	std	Y+5, r21	; 0x05
     cc6:	4c 83       	std	Y+4, r20	; 0x04
     cc8:	52 2e       	mov	r5, r18
signed portBASE_TYPE xEntryTimeSet = pdFALSE;
     cca:	dd 24       	eor	r13, r13
				}
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
     ccc:	7e 01       	movw	r14, r28
     cce:	08 94       	sec
     cd0:	e1 1c       	adc	r14, r1
     cd2:	f1 1c       	adc	r15, r1
					xEntryTimeSet = pdTRUE;
     cd4:	cc 24       	eor	r12, r12
     cd6:	c3 94       	inc	r12

		vTaskSuspendAll();
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
     cd8:	aa 24       	eor	r10, r10
     cda:	bb 24       	eor	r11, r11
     cdc:	68 94       	set
     cde:	a2 f8       	bld	r10, 2
     ce0:	ac 0e       	add	r10, r28
     ce2:	bd 1e       	adc	r11, r29
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
     ce4:	88 24       	eor	r8, r8
     ce6:	99 24       	eor	r9, r9
     ce8:	68 94       	set
     cea:	83 f8       	bld	r8, 3
     cec:	88 0e       	add	r8, r24
     cee:	99 1e       	adc	r9, r25
	/* This function relaxes the coding standard somewhat to allow return
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
     cf0:	0f b6       	in	r0, 0x3f	; 63
     cf2:	f8 94       	cli
     cf4:	0f 92       	push	r0
		{
			/* Is there room on the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
     cf6:	f8 01       	movw	r30, r16
     cf8:	92 8d       	ldd	r25, Z+26	; 0x1a
     cfa:	83 8d       	ldd	r24, Z+27	; 0x1b
     cfc:	98 17       	cp	r25, r24
     cfe:	a8 f4       	brcc	.+42     	; 0xd2a <xQueueGenericSend+0x92>
			{
				traceQUEUE_SEND( pxQueue );
				prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
     d00:	c8 01       	movw	r24, r16
     d02:	b3 01       	movw	r22, r6
     d04:	45 2d       	mov	r20, r5
     d06:	0e 94 43 05 	call	0xa86	; 0xa86 <prvCopyDataToQueue>

				/* If there was a task waiting for data to arrive on the
				queue then unblock it now. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
     d0a:	f8 01       	movw	r30, r16
     d0c:	81 89       	ldd	r24, Z+17	; 0x11
     d0e:	88 23       	and	r24, r24
     d10:	41 f0       	breq	.+16     	; 0xd22 <xQueueGenericSend+0x8a>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) == pdTRUE )
     d12:	c8 01       	movw	r24, r16
     d14:	41 96       	adiw	r24, 0x11	; 17
     d16:	0e 94 41 0e 	call	0x1c82	; 0x1c82 <xTaskRemoveFromEventList>
     d1a:	81 30       	cpi	r24, 0x01	; 1
     d1c:	11 f4       	brne	.+4      	; 0xd22 <xQueueGenericSend+0x8a>
					{
						/* The unblocked task has a priority higher than
						our own so yield immediately.  Yes it is ok to do
						this from within the critical section - the kernel
						takes care of that. */
						portYIELD_WITHIN_API();
     d1e:	0e 94 6b 04 	call	0x8d6	; 0x8d6 <vPortYield>
					}
				}

				taskEXIT_CRITICAL();
     d22:	0f 90       	pop	r0
     d24:	0f be       	out	0x3f, r0	; 63

				/* Return to the original privilege level before exiting the
				function. */
				return pdPASS;
     d26:	81 e0       	ldi	r24, 0x01	; 1
     d28:	4e c0       	rjmp	.+156    	; 0xdc6 <xQueueGenericSend+0x12e>
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
     d2a:	8c 81       	ldd	r24, Y+4	; 0x04
     d2c:	9d 81       	ldd	r25, Y+5	; 0x05
     d2e:	00 97       	sbiw	r24, 0x00	; 0
     d30:	21 f4       	brne	.+8      	; 0xd3a <xQueueGenericSend+0xa2>
				{
					/* The queue was full and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
     d32:	0f 90       	pop	r0
     d34:	0f be       	out	0x3f, r0	; 63

					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED( pxQueue );
					return errQUEUE_FULL;
     d36:	80 e0       	ldi	r24, 0x00	; 0
     d38:	46 c0       	rjmp	.+140    	; 0xdc6 <xQueueGenericSend+0x12e>
				}
				else if( xEntryTimeSet == pdFALSE )
     d3a:	dd 20       	and	r13, r13
     d3c:	21 f4       	brne	.+8      	; 0xd46 <xQueueGenericSend+0xae>
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
     d3e:	c7 01       	movw	r24, r14
     d40:	0e 94 87 0e 	call	0x1d0e	; 0x1d0e <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
     d44:	dc 2c       	mov	r13, r12
				}
			}
		}
		taskEXIT_CRITICAL();
     d46:	0f 90       	pop	r0
     d48:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
     d4a:	0e 94 3a 0b 	call	0x1674	; 0x1674 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
     d4e:	0f b6       	in	r0, 0x3f	; 63
     d50:	f8 94       	cli
     d52:	0f 92       	push	r0
     d54:	f8 01       	movw	r30, r16
     d56:	85 8d       	ldd	r24, Z+29	; 0x1d
     d58:	8f 3f       	cpi	r24, 0xFF	; 255
     d5a:	09 f4       	brne	.+2      	; 0xd5e <xQueueGenericSend+0xc6>
     d5c:	15 8e       	std	Z+29, r1	; 0x1d
     d5e:	f8 01       	movw	r30, r16
     d60:	86 8d       	ldd	r24, Z+30	; 0x1e
     d62:	8f 3f       	cpi	r24, 0xFF	; 255
     d64:	09 f4       	brne	.+2      	; 0xd68 <xQueueGenericSend+0xd0>
     d66:	16 8e       	std	Z+30, r1	; 0x1e
     d68:	0f 90       	pop	r0
     d6a:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
     d6c:	c7 01       	movw	r24, r14
     d6e:	b5 01       	movw	r22, r10
     d70:	0e 94 92 0e 	call	0x1d24	; 0x1d24 <xTaskCheckForTimeOut>
     d74:	88 23       	and	r24, r24
     d76:	09 f5       	brne	.+66     	; 0xdba <xQueueGenericSend+0x122>

static signed portBASE_TYPE prvIsQueueFull( const xQueueHandle pxQueue )
{
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
     d78:	0f b6       	in	r0, 0x3f	; 63
     d7a:	f8 94       	cli
     d7c:	0f 92       	push	r0
		xReturn = ( pxQueue->uxMessagesWaiting == pxQueue->uxLength );
     d7e:	f8 01       	movw	r30, r16
     d80:	92 8d       	ldd	r25, Z+26	; 0x1a
	taskEXIT_CRITICAL();
     d82:	0f 90       	pop	r0
     d84:	0f be       	out	0x3f, r0	; 63
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
     d86:	f8 01       	movw	r30, r16
     d88:	83 8d       	ldd	r24, Z+27	; 0x1b
     d8a:	98 17       	cp	r25, r24
     d8c:	81 f4       	brne	.+32     	; 0xdae <xQueueGenericSend+0x116>
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
     d8e:	6c 81       	ldd	r22, Y+4	; 0x04
     d90:	7d 81       	ldd	r23, Y+5	; 0x05
     d92:	c4 01       	movw	r24, r8
     d94:	0e 94 15 0e 	call	0x1c2a	; 0x1c2a <vTaskPlaceOnEventList>
				/* Unlocking the queue means queue events can effect the
				event list.  It is possible	that interrupts occurring now
				remove this task from the event	list again - but as the
				scheduler is suspended the task will go onto the pending
				ready last instead of the actual ready list. */
				prvUnlockQueue( pxQueue );
     d98:	c8 01       	movw	r24, r16
     d9a:	0e 94 84 05 	call	0xb08	; 0xb08 <prvUnlockQueue>
				/* Resuming the scheduler will move tasks from the pending
				ready list into the ready list - so it is feasible that this
				task is already in a ready list before it yields - in which
				case the yield will not cause a context switch unless there
				is also a higher priority task in the pending ready list. */
				if( xTaskResumeAll() == pdFALSE )
     d9e:	0e 94 1c 0c 	call	0x1838	; 0x1838 <xTaskResumeAll>
     da2:	88 23       	and	r24, r24
     da4:	09 f0       	breq	.+2      	; 0xda8 <xQueueGenericSend+0x110>
     da6:	a4 cf       	rjmp	.-184    	; 0xcf0 <xQueueGenericSend+0x58>
				{
					portYIELD_WITHIN_API();
     da8:	0e 94 6b 04 	call	0x8d6	; 0x8d6 <vPortYield>
     dac:	a1 cf       	rjmp	.-190    	; 0xcf0 <xQueueGenericSend+0x58>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
     dae:	c8 01       	movw	r24, r16
     db0:	0e 94 84 05 	call	0xb08	; 0xb08 <prvUnlockQueue>
				( void ) xTaskResumeAll();
     db4:	0e 94 1c 0c 	call	0x1838	; 0x1838 <xTaskResumeAll>
     db8:	9b cf       	rjmp	.-202    	; 0xcf0 <xQueueGenericSend+0x58>
			}
		}
		else
		{
			/* The timeout has expired. */
			prvUnlockQueue( pxQueue );
     dba:	c8 01       	movw	r24, r16
     dbc:	0e 94 84 05 	call	0xb08	; 0xb08 <prvUnlockQueue>
			( void ) xTaskResumeAll();
     dc0:	0e 94 1c 0c 	call	0x1838	; 0x1838 <xTaskResumeAll>

			/* Return to the original privilege level before exiting the
			function. */
			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
     dc4:	80 e0       	ldi	r24, 0x00	; 0
		}
	}
}
     dc6:	0f 90       	pop	r0
     dc8:	0f 90       	pop	r0
     dca:	0f 90       	pop	r0
     dcc:	0f 90       	pop	r0
     dce:	0f 90       	pop	r0
     dd0:	cf 91       	pop	r28
     dd2:	df 91       	pop	r29
     dd4:	1f 91       	pop	r17
     dd6:	0f 91       	pop	r16
     dd8:	ff 90       	pop	r15
     dda:	ef 90       	pop	r14
     ddc:	df 90       	pop	r13
     dde:	cf 90       	pop	r12
     de0:	bf 90       	pop	r11
     de2:	af 90       	pop	r10
     de4:	9f 90       	pop	r9
     de6:	8f 90       	pop	r8
     de8:	7f 90       	pop	r7
     dea:	6f 90       	pop	r6
     dec:	5f 90       	pop	r5
     dee:	08 95       	ret

00000df0 <xQueueGenericSendFromISR>:

#endif /* configUSE_ALTERNATIVE_API */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSendFromISR( xQueueHandle pxQueue, const void * const pvItemToQueue, signed portBASE_TYPE *pxHigherPriorityTaskWoken, portBASE_TYPE xCopyPosition )
{
     df0:	0f 93       	push	r16
     df2:	1f 93       	push	r17
     df4:	cf 93       	push	r28
     df6:	df 93       	push	r29
     df8:	ec 01       	movw	r28, r24
     dfa:	8a 01       	movw	r16, r20
	queue read, instead we return a flag to say whether a context switch is
	required or not (i.e. has a task with a higher priority than us been woken
	by this	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
     dfc:	9a 8d       	ldd	r25, Y+26	; 0x1a
     dfe:	8b 8d       	ldd	r24, Y+27	; 0x1b
     e00:	98 17       	cp	r25, r24
     e02:	c0 f4       	brcc	.+48     	; 0xe34 <xQueueGenericSendFromISR+0x44>
		{
			traceQUEUE_SEND_FROM_ISR( pxQueue );

			prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
     e04:	ce 01       	movw	r24, r28
     e06:	42 2f       	mov	r20, r18
     e08:	0e 94 43 05 	call	0xa86	; 0xa86 <prvCopyDataToQueue>

			/* If the queue is locked we do not alter the event list.  This will
			be done when the queue is unlocked later. */
			if( pxQueue->xTxLock == queueUNLOCKED )
     e0c:	8e 8d       	ldd	r24, Y+30	; 0x1e
     e0e:	8f 3f       	cpi	r24, 0xFF	; 255
     e10:	69 f4       	brne	.+26     	; 0xe2c <xQueueGenericSendFromISR+0x3c>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
     e12:	89 89       	ldd	r24, Y+17	; 0x11
     e14:	88 23       	and	r24, r24
     e16:	81 f0       	breq	.+32     	; 0xe38 <xQueueGenericSendFromISR+0x48>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
     e18:	ce 01       	movw	r24, r28
     e1a:	41 96       	adiw	r24, 0x11	; 17
     e1c:	0e 94 41 0e 	call	0x1c82	; 0x1c82 <xTaskRemoveFromEventList>
     e20:	88 23       	and	r24, r24
     e22:	61 f0       	breq	.+24     	; 0xe3c <xQueueGenericSendFromISR+0x4c>
					{
						/* The task waiting has a higher priority so record that a
						context	switch is required. */
						*pxHigherPriorityTaskWoken = pdTRUE;
     e24:	81 e0       	ldi	r24, 0x01	; 1
     e26:	f8 01       	movw	r30, r16
     e28:	80 83       	st	Z, r24
     e2a:	09 c0       	rjmp	.+18     	; 0xe3e <xQueueGenericSendFromISR+0x4e>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
     e2c:	8f 5f       	subi	r24, 0xFF	; 255
     e2e:	8e 8f       	std	Y+30, r24	; 0x1e
			}

			xReturn = pdPASS;
     e30:	81 e0       	ldi	r24, 0x01	; 1
     e32:	05 c0       	rjmp	.+10     	; 0xe3e <xQueueGenericSendFromISR+0x4e>
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
     e34:	80 e0       	ldi	r24, 0x00	; 0
     e36:	03 c0       	rjmp	.+6      	; 0xe3e <xQueueGenericSendFromISR+0x4e>
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
			}

			xReturn = pdPASS;
     e38:	81 e0       	ldi	r24, 0x01	; 1
     e3a:	01 c0       	rjmp	.+2      	; 0xe3e <xQueueGenericSendFromISR+0x4e>
     e3c:	81 e0       	ldi	r24, 0x01	; 1
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
     e3e:	df 91       	pop	r29
     e40:	cf 91       	pop	r28
     e42:	1f 91       	pop	r17
     e44:	0f 91       	pop	r16
     e46:	08 95       	ret

00000e48 <xQueueGenericReceive>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericReceive( xQueueHandle pxQueue, void * const pvBuffer, portTickType xTicksToWait, portBASE_TYPE xJustPeeking )
{
     e48:	5f 92       	push	r5
     e4a:	6f 92       	push	r6
     e4c:	7f 92       	push	r7
     e4e:	8f 92       	push	r8
     e50:	9f 92       	push	r9
     e52:	af 92       	push	r10
     e54:	bf 92       	push	r11
     e56:	cf 92       	push	r12
     e58:	df 92       	push	r13
     e5a:	ef 92       	push	r14
     e5c:	ff 92       	push	r15
     e5e:	0f 93       	push	r16
     e60:	1f 93       	push	r17
     e62:	df 93       	push	r29
     e64:	cf 93       	push	r28
     e66:	00 d0       	rcall	.+0      	; 0xe68 <xQueueGenericReceive+0x20>
     e68:	00 d0       	rcall	.+0      	; 0xe6a <xQueueGenericReceive+0x22>
     e6a:	0f 92       	push	r0
     e6c:	cd b7       	in	r28, 0x3d	; 61
     e6e:	de b7       	in	r29, 0x3e	; 62
     e70:	8c 01       	movw	r16, r24
     e72:	3b 01       	movw	r6, r22
     e74:	5d 83       	std	Y+5, r21	; 0x05
     e76:	4c 83       	std	Y+4, r20	; 0x04
     e78:	52 2e       	mov	r5, r18
signed portBASE_TYPE xEntryTimeSet = pdFALSE;
     e7a:	dd 24       	eor	r13, r13
				}
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
     e7c:	7e 01       	movw	r14, r28
     e7e:	08 94       	sec
     e80:	e1 1c       	adc	r14, r1
     e82:	f1 1c       	adc	r15, r1
					xEntryTimeSet = pdTRUE;
     e84:	cc 24       	eor	r12, r12
     e86:	c3 94       	inc	r12

		vTaskSuspendAll();
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
     e88:	aa 24       	eor	r10, r10
     e8a:	bb 24       	eor	r11, r11
     e8c:	68 94       	set
     e8e:	a2 f8       	bld	r10, 2
     e90:	ac 0e       	add	r10, r28
     e92:	bd 1e       	adc	r11, r29
						portEXIT_CRITICAL();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
     e94:	0f 2e       	mov	r0, r31
     e96:	f1 e1       	ldi	r31, 0x11	; 17
     e98:	8f 2e       	mov	r8, r31
     e9a:	99 24       	eor	r9, r9
     e9c:	f0 2d       	mov	r31, r0
     e9e:	88 0e       	add	r8, r24
     ea0:	99 1e       	adc	r9, r25
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
     ea2:	0f b6       	in	r0, 0x3f	; 63
     ea4:	f8 94       	cli
     ea6:	0f 92       	push	r0
		{
			/* Is there data in the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
     ea8:	f8 01       	movw	r30, r16
     eaa:	82 8d       	ldd	r24, Z+26	; 0x1a
     eac:	88 23       	and	r24, r24
     eae:	51 f1       	breq	.+84     	; 0xf04 <xQueueGenericReceive+0xbc>
			{
				/* Remember our read position in case we are just peeking. */
				pcOriginalReadPosition = pxQueue->pcReadFrom;
     eb0:	e6 80       	ldd	r14, Z+6	; 0x06
     eb2:	f7 80       	ldd	r15, Z+7	; 0x07

				prvCopyDataFromQueue( pxQueue, pvBuffer );
     eb4:	c8 01       	movw	r24, r16
     eb6:	b3 01       	movw	r22, r6
     eb8:	0e 94 22 05 	call	0xa44	; 0xa44 <prvCopyDataFromQueue>

				if( xJustPeeking == pdFALSE )
     ebc:	55 20       	and	r5, r5
     ebe:	81 f4       	brne	.+32     	; 0xee0 <xQueueGenericReceive+0x98>
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* We are actually removing data. */
					--( pxQueue->uxMessagesWaiting );
     ec0:	f8 01       	movw	r30, r16
     ec2:	82 8d       	ldd	r24, Z+26	; 0x1a
     ec4:	81 50       	subi	r24, 0x01	; 1
     ec6:	82 8f       	std	Z+26, r24	; 0x1a
							pxQueue->pxMutexHolder = xTaskGetCurrentTaskHandle();
						}
					}
					#endif

					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
     ec8:	80 85       	ldd	r24, Z+8	; 0x08
     eca:	88 23       	and	r24, r24
     ecc:	b9 f0       	breq	.+46     	; 0xefc <xQueueGenericReceive+0xb4>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
     ece:	c8 01       	movw	r24, r16
     ed0:	08 96       	adiw	r24, 0x08	; 8
     ed2:	0e 94 41 0e 	call	0x1c82	; 0x1c82 <xTaskRemoveFromEventList>
     ed6:	81 30       	cpi	r24, 0x01	; 1
     ed8:	89 f4       	brne	.+34     	; 0xefc <xQueueGenericReceive+0xb4>
						{
							portYIELD_WITHIN_API();
     eda:	0e 94 6b 04 	call	0x8d6	; 0x8d6 <vPortYield>
     ede:	0e c0       	rjmp	.+28     	; 0xefc <xQueueGenericReceive+0xb4>
				{
					traceQUEUE_PEEK( pxQueue );

					/* We are not removing the data, so reset our read
					pointer. */
					pxQueue->pcReadFrom = pcOriginalReadPosition;
     ee0:	f8 01       	movw	r30, r16
     ee2:	f7 82       	std	Z+7, r15	; 0x07
     ee4:	e6 82       	std	Z+6, r14	; 0x06

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
     ee6:	81 89       	ldd	r24, Z+17	; 0x11
     ee8:	88 23       	and	r24, r24
     eea:	41 f0       	breq	.+16     	; 0xefc <xQueueGenericReceive+0xb4>
					{
						/* Tasks that are removed from the event list will get added to
						the pending ready list as the scheduler is still suspended. */
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
     eec:	c8 01       	movw	r24, r16
     eee:	41 96       	adiw	r24, 0x11	; 17
     ef0:	0e 94 41 0e 	call	0x1c82	; 0x1c82 <xTaskRemoveFromEventList>
     ef4:	88 23       	and	r24, r24
     ef6:	11 f0       	breq	.+4      	; 0xefc <xQueueGenericReceive+0xb4>
						{
							/* The task waiting has a higher priority than this task. */
							portYIELD_WITHIN_API();
     ef8:	0e 94 6b 04 	call	0x8d6	; 0x8d6 <vPortYield>
						}
					}

				}

				taskEXIT_CRITICAL();
     efc:	0f 90       	pop	r0
     efe:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
     f00:	81 e0       	ldi	r24, 0x01	; 1
     f02:	4c c0       	rjmp	.+152    	; 0xf9c <xQueueGenericReceive+0x154>
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
     f04:	8c 81       	ldd	r24, Y+4	; 0x04
     f06:	9d 81       	ldd	r25, Y+5	; 0x05
     f08:	00 97       	sbiw	r24, 0x00	; 0
     f0a:	21 f4       	brne	.+8      	; 0xf14 <xQueueGenericReceive+0xcc>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
     f0c:	0f 90       	pop	r0
     f0e:	0f be       	out	0x3f, r0	; 63
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
     f10:	80 e0       	ldi	r24, 0x00	; 0
     f12:	44 c0       	rjmp	.+136    	; 0xf9c <xQueueGenericReceive+0x154>
				}
				else if( xEntryTimeSet == pdFALSE )
     f14:	dd 20       	and	r13, r13
     f16:	21 f4       	brne	.+8      	; 0xf20 <xQueueGenericReceive+0xd8>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
     f18:	c7 01       	movw	r24, r14
     f1a:	0e 94 87 0e 	call	0x1d0e	; 0x1d0e <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
     f1e:	dc 2c       	mov	r13, r12
				}
			}
		}
		taskEXIT_CRITICAL();
     f20:	0f 90       	pop	r0
     f22:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
     f24:	0e 94 3a 0b 	call	0x1674	; 0x1674 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
     f28:	0f b6       	in	r0, 0x3f	; 63
     f2a:	f8 94       	cli
     f2c:	0f 92       	push	r0
     f2e:	f8 01       	movw	r30, r16
     f30:	85 8d       	ldd	r24, Z+29	; 0x1d
     f32:	8f 3f       	cpi	r24, 0xFF	; 255
     f34:	09 f4       	brne	.+2      	; 0xf38 <xQueueGenericReceive+0xf0>
     f36:	15 8e       	std	Z+29, r1	; 0x1d
     f38:	f8 01       	movw	r30, r16
     f3a:	86 8d       	ldd	r24, Z+30	; 0x1e
     f3c:	8f 3f       	cpi	r24, 0xFF	; 255
     f3e:	09 f4       	brne	.+2      	; 0xf42 <xQueueGenericReceive+0xfa>
     f40:	16 8e       	std	Z+30, r1	; 0x1e
     f42:	0f 90       	pop	r0
     f44:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
     f46:	c7 01       	movw	r24, r14
     f48:	b5 01       	movw	r22, r10
     f4a:	0e 94 92 0e 	call	0x1d24	; 0x1d24 <xTaskCheckForTimeOut>
     f4e:	88 23       	and	r24, r24
     f50:	f9 f4       	brne	.+62     	; 0xf90 <xQueueGenericReceive+0x148>

static signed portBASE_TYPE prvIsQueueEmpty( const xQueueHandle pxQueue )
{
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
     f52:	0f b6       	in	r0, 0x3f	; 63
     f54:	f8 94       	cli
     f56:	0f 92       	push	r0
		xReturn = ( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0 );
     f58:	f8 01       	movw	r30, r16
     f5a:	82 8d       	ldd	r24, Z+26	; 0x1a
	taskEXIT_CRITICAL();
     f5c:	0f 90       	pop	r0
     f5e:	0f be       	out	0x3f, r0	; 63
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
     f60:	88 23       	and	r24, r24
     f62:	81 f4       	brne	.+32     	; 0xf84 <xQueueGenericReceive+0x13c>
						portEXIT_CRITICAL();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
     f64:	6c 81       	ldd	r22, Y+4	; 0x04
     f66:	7d 81       	ldd	r23, Y+5	; 0x05
     f68:	c4 01       	movw	r24, r8
     f6a:	0e 94 15 0e 	call	0x1c2a	; 0x1c2a <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
     f6e:	c8 01       	movw	r24, r16
     f70:	0e 94 84 05 	call	0xb08	; 0xb08 <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
     f74:	0e 94 1c 0c 	call	0x1838	; 0x1838 <xTaskResumeAll>
     f78:	88 23       	and	r24, r24
     f7a:	09 f0       	breq	.+2      	; 0xf7e <xQueueGenericReceive+0x136>
     f7c:	92 cf       	rjmp	.-220    	; 0xea2 <xQueueGenericReceive+0x5a>
				{
					portYIELD_WITHIN_API();
     f7e:	0e 94 6b 04 	call	0x8d6	; 0x8d6 <vPortYield>
     f82:	8f cf       	rjmp	.-226    	; 0xea2 <xQueueGenericReceive+0x5a>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
     f84:	c8 01       	movw	r24, r16
     f86:	0e 94 84 05 	call	0xb08	; 0xb08 <prvUnlockQueue>
				( void ) xTaskResumeAll();
     f8a:	0e 94 1c 0c 	call	0x1838	; 0x1838 <xTaskResumeAll>
     f8e:	89 cf       	rjmp	.-238    	; 0xea2 <xQueueGenericReceive+0x5a>
			}
		}
		else
		{
			prvUnlockQueue( pxQueue );
     f90:	c8 01       	movw	r24, r16
     f92:	0e 94 84 05 	call	0xb08	; 0xb08 <prvUnlockQueue>
			( void ) xTaskResumeAll();
     f96:	0e 94 1c 0c 	call	0x1838	; 0x1838 <xTaskResumeAll>
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
     f9a:	80 e0       	ldi	r24, 0x00	; 0
		}
	}
}
     f9c:	0f 90       	pop	r0
     f9e:	0f 90       	pop	r0
     fa0:	0f 90       	pop	r0
     fa2:	0f 90       	pop	r0
     fa4:	0f 90       	pop	r0
     fa6:	cf 91       	pop	r28
     fa8:	df 91       	pop	r29
     faa:	1f 91       	pop	r17
     fac:	0f 91       	pop	r16
     fae:	ff 90       	pop	r15
     fb0:	ef 90       	pop	r14
     fb2:	df 90       	pop	r13
     fb4:	cf 90       	pop	r12
     fb6:	bf 90       	pop	r11
     fb8:	af 90       	pop	r10
     fba:	9f 90       	pop	r9
     fbc:	8f 90       	pop	r8
     fbe:	7f 90       	pop	r7
     fc0:	6f 90       	pop	r6
     fc2:	5f 90       	pop	r5
     fc4:	08 95       	ret

00000fc6 <xQueueReceiveFromISR>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueReceiveFromISR( xQueueHandle pxQueue, void * const pvBuffer, signed portBASE_TYPE *pxTaskWoken )
{
     fc6:	0f 93       	push	r16
     fc8:	1f 93       	push	r17
     fca:	cf 93       	push	r28
     fcc:	df 93       	push	r29
     fce:	ec 01       	movw	r28, r24
     fd0:	8a 01       	movw	r16, r20
	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( unsigned portBASE_TYPE ) 0U ) ) );

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		/* We cannot block from an ISR, so check there is data available. */
		if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
     fd2:	8a 8d       	ldd	r24, Y+26	; 0x1a
     fd4:	88 23       	and	r24, r24
     fd6:	d1 f0       	breq	.+52     	; 0x100c <xQueueReceiveFromISR+0x46>
		{
			traceQUEUE_RECEIVE_FROM_ISR( pxQueue );

			prvCopyDataFromQueue( pxQueue, pvBuffer );
     fd8:	ce 01       	movw	r24, r28
     fda:	0e 94 22 05 	call	0xa44	; 0xa44 <prvCopyDataFromQueue>
			--( pxQueue->uxMessagesWaiting );
     fde:	8a 8d       	ldd	r24, Y+26	; 0x1a
     fe0:	81 50       	subi	r24, 0x01	; 1
     fe2:	8a 8f       	std	Y+26, r24	; 0x1a

			/* If the queue is locked we will not modify the event list.  Instead
			we update the lock count so the task that unlocks the queue will know
			that an ISR has removed data while the queue was locked. */
			if( pxQueue->xRxLock == queueUNLOCKED )
     fe4:	8d 8d       	ldd	r24, Y+29	; 0x1d
     fe6:	8f 3f       	cpi	r24, 0xFF	; 255
     fe8:	69 f4       	brne	.+26     	; 0x1004 <xQueueReceiveFromISR+0x3e>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
     fea:	88 85       	ldd	r24, Y+8	; 0x08
     fec:	88 23       	and	r24, r24
     fee:	81 f0       	breq	.+32     	; 0x1010 <xQueueReceiveFromISR+0x4a>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
     ff0:	ce 01       	movw	r24, r28
     ff2:	08 96       	adiw	r24, 0x08	; 8
     ff4:	0e 94 41 0e 	call	0x1c82	; 0x1c82 <xTaskRemoveFromEventList>
     ff8:	88 23       	and	r24, r24
     ffa:	61 f0       	breq	.+24     	; 0x1014 <xQueueReceiveFromISR+0x4e>
					{
						/* The task waiting has a higher priority than us so
						force a context switch. */
						*pxTaskWoken = pdTRUE;
     ffc:	81 e0       	ldi	r24, 0x01	; 1
     ffe:	f8 01       	movw	r30, r16
    1000:	80 83       	st	Z, r24
    1002:	09 c0       	rjmp	.+18     	; 0x1016 <xQueueReceiveFromISR+0x50>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was removed while it was locked. */
				++( pxQueue->xRxLock );
    1004:	8f 5f       	subi	r24, 0xFF	; 255
    1006:	8d 8f       	std	Y+29, r24	; 0x1d
			}

			xReturn = pdPASS;
    1008:	81 e0       	ldi	r24, 0x01	; 1
    100a:	05 c0       	rjmp	.+10     	; 0x1016 <xQueueReceiveFromISR+0x50>
		}
		else
		{
			xReturn = pdFAIL;
    100c:	80 e0       	ldi	r24, 0x00	; 0
    100e:	03 c0       	rjmp	.+6      	; 0x1016 <xQueueReceiveFromISR+0x50>
				/* Increment the lock count so the task that unlocks the queue
				knows that data was removed while it was locked. */
				++( pxQueue->xRxLock );
			}

			xReturn = pdPASS;
    1010:	81 e0       	ldi	r24, 0x01	; 1
    1012:	01 c0       	rjmp	.+2      	; 0x1016 <xQueueReceiveFromISR+0x50>
    1014:	81 e0       	ldi	r24, 0x01	; 1
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    1016:	df 91       	pop	r29
    1018:	cf 91       	pop	r28
    101a:	1f 91       	pop	r17
    101c:	0f 91       	pop	r16
    101e:	08 95       	ret

00001020 <uxQueueMessagesWaiting>:
{
unsigned portBASE_TYPE uxReturn;

	configASSERT( pxQueue );

	taskENTER_CRITICAL();
    1020:	0f b6       	in	r0, 0x3f	; 63
    1022:	f8 94       	cli
    1024:	0f 92       	push	r0
		uxReturn = pxQueue->uxMessagesWaiting;
    1026:	fc 01       	movw	r30, r24
    1028:	82 8d       	ldd	r24, Z+26	; 0x1a
	taskEXIT_CRITICAL();
    102a:	0f 90       	pop	r0
    102c:	0f be       	out	0x3f, r0	; 63

	return uxReturn;
}
    102e:	08 95       	ret

00001030 <uxQueueMessagesWaitingFromISR>:
{
unsigned portBASE_TYPE uxReturn;

	configASSERT( pxQueue );

	uxReturn = pxQueue->uxMessagesWaiting;
    1030:	fc 01       	movw	r30, r24
    1032:	82 8d       	ldd	r24, Z+26	; 0x1a

	return uxReturn;
}
    1034:	08 95       	ret

00001036 <vQueueDelete>:
/*-----------------------------------------------------------*/

void vQueueDelete( xQueueHandle pxQueue )
{
    1036:	cf 93       	push	r28
    1038:	df 93       	push	r29
    103a:	ec 01       	movw	r28, r24
	configASSERT( pxQueue );

	traceQUEUE_DELETE( pxQueue );
	vQueueUnregisterQueue( pxQueue );
	vPortFree( pxQueue->pcHead );
    103c:	88 81       	ld	r24, Y
    103e:	99 81       	ldd	r25, Y+1	; 0x01
    1040:	0e 94 ae 02 	call	0x55c	; 0x55c <vPortFree>
	vPortFree( pxQueue );
    1044:	ce 01       	movw	r24, r28
    1046:	0e 94 ae 02 	call	0x55c	; 0x55c <vPortFree>
}
    104a:	df 91       	pop	r29
    104c:	cf 91       	pop	r28
    104e:	08 95       	ret

00001050 <xQueueIsQueueEmptyFromISR>:
signed portBASE_TYPE xQueueIsQueueEmptyFromISR( const xQueueHandle pxQueue )
{
signed portBASE_TYPE xReturn;

	configASSERT( pxQueue );
	xReturn = ( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0 );
    1050:	fc 01       	movw	r30, r24
    1052:	92 8d       	ldd	r25, Z+26	; 0x1a
    1054:	81 e0       	ldi	r24, 0x01	; 1
    1056:	91 11       	cpse	r25, r1
    1058:	80 e0       	ldi	r24, 0x00	; 0

	return xReturn;
}
    105a:	08 95       	ret

0000105c <xQueueIsQueueFullFromISR>:
	return xReturn;
}
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueIsQueueFullFromISR( const xQueueHandle pxQueue )
{
    105c:	fc 01       	movw	r30, r24
signed portBASE_TYPE xReturn;

	configASSERT( pxQueue );
	xReturn = ( pxQueue->uxMessagesWaiting == pxQueue->uxLength );
    105e:	22 8d       	ldd	r18, Z+26	; 0x1a
    1060:	81 e0       	ldi	r24, 0x01	; 1
    1062:	93 8d       	ldd	r25, Z+27	; 0x1b
    1064:	29 13       	cpse	r18, r25
    1066:	80 e0       	ldi	r24, 0x00	; 0

	return xReturn;
}
    1068:	08 95       	ret

0000106a <TASK>:


}

void TASK(void * pvParameters )
{
    106a:	cf 93       	push	r28
    106c:	df 93       	push	r29
		/*pend for semaphore until it released from ISR */

		xSemaphoreTake(task_sync_sem,portMAX_DELAY);

			/*print if semaphore released*/
			lcd_dispString("Button pressed:D");
    106e:	c0 e6       	ldi	r28, 0x60	; 96
    1070:	d0 e0       	ldi	r29, 0x00	; 0
		//lcd_dispString("Running");
		//delay_ms(500);
		//lcd_clrScreen();
		/*pend for semaphore until it released from ISR */

		xSemaphoreTake(task_sync_sem,portMAX_DELAY);
    1072:	80 91 63 03 	lds	r24, 0x0363
    1076:	90 91 64 03 	lds	r25, 0x0364
    107a:	60 e0       	ldi	r22, 0x00	; 0
    107c:	70 e0       	ldi	r23, 0x00	; 0
    107e:	4f ef       	ldi	r20, 0xFF	; 255
    1080:	5f ef       	ldi	r21, 0xFF	; 255
    1082:	20 e0       	ldi	r18, 0x00	; 0
    1084:	0e 94 24 07 	call	0xe48	; 0xe48 <xQueueGenericReceive>

			/*print if semaphore released*/
			lcd_dispString("Button pressed:D");
    1088:	ce 01       	movw	r24, r28
    108a:	0e 94 30 03 	call	0x660	; 0x660 <lcd_dispString>
    108e:	8f ef       	ldi	r24, 0xFF	; 255
    1090:	94 e3       	ldi	r25, 0x34	; 52
    1092:	ac e0       	ldi	r26, 0x0C	; 12
    1094:	81 50       	subi	r24, 0x01	; 1
    1096:	90 40       	sbci	r25, 0x00	; 0
    1098:	a0 40       	sbci	r26, 0x00	; 0
    109a:	e1 f7       	brne	.-8      	; 0x1094 <TASK+0x2a>
    109c:	00 c0       	rjmp	.+0      	; 0x109e <TASK+0x34>
    109e:	00 00       	nop

			_delay_ms(500);

			/*clear screen */
			lcd_clrScreen();
    10a0:	0e 94 2c 03 	call	0x658	; 0x658 <lcd_clrScreen>
    10a4:	e6 cf       	rjmp	.-52     	; 0x1072 <TASK+0x8>

000010a6 <main>:

/*create a semaphore handle*/
xSemaphoreHandle task_sync_sem ; 

int main(void)
{
    10a6:	af 92       	push	r10
    10a8:	bf 92       	push	r11
    10aa:	cf 92       	push	r12
    10ac:	df 92       	push	r13
    10ae:	ef 92       	push	r14
    10b0:	ff 92       	push	r15
    10b2:	0f 93       	push	r16
	/*initialization section*/
	/*initialize PD2 as INPUT and enable PULL-UP resistor*/
	DDRD &=0xfB; // set direction you can use clear macro instead of this way CLR_BIT(PORTD,2)
    10b4:	8a 98       	cbi	0x11, 2	; 17
	PORTD|=0x04; // set PORTD.PD2 high to enable PULL-UP resistor you can use instead this way SET_BIT(PORTD,2)
    10b6:	92 9a       	sbi	0x12, 2	; 18

	/*enable external interrupt INT0 and set sense control for low level */
	MCUCR &=0xfC; // set MCU control register to enable int0 and sense low level 
    10b8:	85 b7       	in	r24, 0x35	; 53
    10ba:	8c 7f       	andi	r24, 0xFC	; 252
    10bc:	85 bf       	out	0x35, r24	; 53
	SET_BIT(GICR,6); // enable INT0 from global interrupt reg
    10be:	8b b7       	in	r24, 0x3b	; 59
    10c0:	80 64       	ori	r24, 0x40	; 64
    10c2:	8b bf       	out	0x3b, r24	; 59
	SET_BIT(SREG,7); // enable GlOBAL interrupt in SREG 
    10c4:	8f b7       	in	r24, 0x3f	; 63
    10c6:	80 68       	ori	r24, 0x80	; 128
    10c8:	8f bf       	out	0x3f, r24	; 63

	/*init LCD*/
	lcd_init();
    10ca:	0e 94 e8 02 	call	0x5d0	; 0x5d0 <lcd_init>

	/*Create binary semaphore with initial value 0 because we used it for sync. between INTERRUPT and TASK*/
	task_sync_sem = xSemaphoreCreateCounting(1,0);
    10ce:	81 e0       	ldi	r24, 0x01	; 1
    10d0:	60 e0       	ldi	r22, 0x00	; 0
    10d2:	0e 94 3f 06 	call	0xc7e	; 0xc7e <xQueueCreateCountingSemaphore>
    10d6:	90 93 64 03 	sts	0x0364, r25
    10da:	80 93 63 03 	sts	0x0363, r24

	/*create task */
	xTaskCreate(TASK,"task",configMINIMAL_STACK_SIZE,NULL,2,NULL);
    10de:	85 e3       	ldi	r24, 0x35	; 53
    10e0:	98 e0       	ldi	r25, 0x08	; 8
    10e2:	61 e7       	ldi	r22, 0x71	; 113
    10e4:	70 e0       	ldi	r23, 0x00	; 0
    10e6:	45 e5       	ldi	r20, 0x55	; 85
    10e8:	50 e0       	ldi	r21, 0x00	; 0
    10ea:	20 e0       	ldi	r18, 0x00	; 0
    10ec:	30 e0       	ldi	r19, 0x00	; 0
    10ee:	02 e0       	ldi	r16, 0x02	; 2
    10f0:	ee 24       	eor	r14, r14
    10f2:	ff 24       	eor	r15, r15
    10f4:	cc 24       	eor	r12, r12
    10f6:	dd 24       	eor	r13, r13
    10f8:	aa 24       	eor	r10, r10
    10fa:	bb 24       	eor	r11, r11
    10fc:	0e 94 f0 08 	call	0x11e0	; 0x11e0 <xTaskGenericCreate>
	/*Start OS "Scheduler " */

	vTaskStartScheduler();
    1100:	0e 94 09 0b 	call	0x1612	; 0x1612 <vTaskStartScheduler>


}
    1104:	80 e0       	ldi	r24, 0x00	; 0
    1106:	90 e0       	ldi	r25, 0x00	; 0
    1108:	0f 91       	pop	r16
    110a:	ff 90       	pop	r15
    110c:	ef 90       	pop	r14
    110e:	df 90       	pop	r13
    1110:	cf 90       	pop	r12
    1112:	bf 90       	pop	r11
    1114:	af 90       	pop	r10
    1116:	08 95       	ret

00001118 <__vector_1>:

}

/*interrupt service routine for external interrupt 0 (PD2) */
ISR(INT0_vect)
{
    1118:	1f 92       	push	r1
    111a:	0f 92       	push	r0
    111c:	0f b6       	in	r0, 0x3f	; 63
    111e:	0f 92       	push	r0
    1120:	11 24       	eor	r1, r1
    1122:	2f 93       	push	r18
    1124:	3f 93       	push	r19
    1126:	4f 93       	push	r20
    1128:	5f 93       	push	r21
    112a:	6f 93       	push	r22
    112c:	7f 93       	push	r23
    112e:	8f 93       	push	r24
    1130:	9f 93       	push	r25
    1132:	af 93       	push	r26
    1134:	bf 93       	push	r27
    1136:	ef 93       	push	r30
    1138:	ff 93       	push	r31
	/*release semaphore */
	xSemaphoreGiveFromISR(task_sync_sem,NULL);
    113a:	80 91 63 03 	lds	r24, 0x0363
    113e:	90 91 64 03 	lds	r25, 0x0364
    1142:	60 e0       	ldi	r22, 0x00	; 0
    1144:	70 e0       	ldi	r23, 0x00	; 0
    1146:	40 e0       	ldi	r20, 0x00	; 0
    1148:	50 e0       	ldi	r21, 0x00	; 0
    114a:	20 e0       	ldi	r18, 0x00	; 0
    114c:	0e 94 f8 06 	call	0xdf0	; 0xdf0 <xQueueGenericSendFromISR>
}
    1150:	ff 91       	pop	r31
    1152:	ef 91       	pop	r30
    1154:	bf 91       	pop	r27
    1156:	af 91       	pop	r26
    1158:	9f 91       	pop	r25
    115a:	8f 91       	pop	r24
    115c:	7f 91       	pop	r23
    115e:	6f 91       	pop	r22
    1160:	5f 91       	pop	r21
    1162:	4f 91       	pop	r20
    1164:	3f 91       	pop	r19
    1166:	2f 91       	pop	r18
    1168:	0f 90       	pop	r0
    116a:	0f be       	out	0x3f, r0	; 63
    116c:	0f 90       	pop	r0
    116e:	1f 90       	pop	r1
    1170:	18 95       	reti

00001172 <prvAddCurrentTaskToDelayedList>:
	#endif
}
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( portTickType xTimeToWake )
{
    1172:	cf 93       	push	r28
    1174:	df 93       	push	r29
    1176:	ec 01       	movw	r28, r24
	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
    1178:	e0 91 12 03 	lds	r30, 0x0312
    117c:	f0 91 13 03 	lds	r31, 0x0313
    1180:	93 83       	std	Z+3, r25	; 0x03
    1182:	82 83       	std	Z+2, r24	; 0x02

	if( xTimeToWake < xTickCount )
    1184:	80 91 16 03 	lds	r24, 0x0316
    1188:	90 91 17 03 	lds	r25, 0x0317
    118c:	c8 17       	cp	r28, r24
    118e:	d9 07       	cpc	r29, r25
    1190:	68 f4       	brcc	.+26     	; 0x11ac <prvAddCurrentTaskToDelayedList+0x3a>
	{
		/* Wake time has overflowed.  Place this item in the overflow list. */
		vListInsert( ( xList * ) pxOverflowDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    1192:	80 91 3e 03 	lds	r24, 0x033E
    1196:	90 91 3f 03 	lds	r25, 0x033F
    119a:	60 91 12 03 	lds	r22, 0x0312
    119e:	70 91 13 03 	lds	r23, 0x0313
    11a2:	6e 5f       	subi	r22, 0xFE	; 254
    11a4:	7f 4f       	sbci	r23, 0xFF	; 255
    11a6:	0e 94 85 03 	call	0x70a	; 0x70a <vListInsert>
    11aa:	17 c0       	rjmp	.+46     	; 0x11da <prvAddCurrentTaskToDelayedList+0x68>
	}
	else
	{
		/* The wake time has not overflowed, so we can use the current block list. */
		vListInsert( ( xList * ) pxDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    11ac:	80 91 40 03 	lds	r24, 0x0340
    11b0:	90 91 41 03 	lds	r25, 0x0341
    11b4:	60 91 12 03 	lds	r22, 0x0312
    11b8:	70 91 13 03 	lds	r23, 0x0313
    11bc:	6e 5f       	subi	r22, 0xFE	; 254
    11be:	7f 4f       	sbci	r23, 0xFF	; 255
    11c0:	0e 94 85 03 	call	0x70a	; 0x70a <vListInsert>

		/* If the task entering the blocked state was placed at the head of the
		list of blocked tasks then xNextTaskUnblockTime needs to be updated
		too. */
		if( xTimeToWake < xNextTaskUnblockTime )
    11c4:	80 91 7b 00 	lds	r24, 0x007B
    11c8:	90 91 7c 00 	lds	r25, 0x007C
    11cc:	c8 17       	cp	r28, r24
    11ce:	d9 07       	cpc	r29, r25
    11d0:	20 f4       	brcc	.+8      	; 0x11da <prvAddCurrentTaskToDelayedList+0x68>
		{
			xNextTaskUnblockTime = xTimeToWake;
    11d2:	d0 93 7c 00 	sts	0x007C, r29
    11d6:	c0 93 7b 00 	sts	0x007B, r28
		}
	}
}
    11da:	df 91       	pop	r29
    11dc:	cf 91       	pop	r28
    11de:	08 95       	ret

000011e0 <xTaskGenericCreate>:
/*-----------------------------------------------------------
 * TASK CREATION API documented in task.h
 *----------------------------------------------------------*/

signed portBASE_TYPE xTaskGenericCreate( pdTASK_CODE pxTaskCode, const signed char * const pcName, unsigned short usStackDepth, void *pvParameters, unsigned portBASE_TYPE uxPriority, xTaskHandle *pxCreatedTask, portSTACK_TYPE *puxStackBuffer, const xMemoryRegion * const xRegions )
{
    11e0:	2f 92       	push	r2
    11e2:	3f 92       	push	r3
    11e4:	4f 92       	push	r4
    11e6:	5f 92       	push	r5
    11e8:	6f 92       	push	r6
    11ea:	7f 92       	push	r7
    11ec:	8f 92       	push	r8
    11ee:	9f 92       	push	r9
    11f0:	bf 92       	push	r11
    11f2:	cf 92       	push	r12
    11f4:	df 92       	push	r13
    11f6:	ef 92       	push	r14
    11f8:	ff 92       	push	r15
    11fa:	0f 93       	push	r16
    11fc:	1f 93       	push	r17
    11fe:	cf 93       	push	r28
    1200:	df 93       	push	r29
    1202:	1c 01       	movw	r2, r24
    1204:	3b 01       	movw	r6, r22
    1206:	ea 01       	movw	r28, r20
    1208:	29 01       	movw	r4, r18
    120a:	b0 2e       	mov	r11, r16
    120c:	47 01       	movw	r8, r14
{
tskTCB *pxNewTCB;

	/* Allocate space for the TCB.  Where the memory comes from depends on
	the implementation of the port malloc function. */
	pxNewTCB = ( tskTCB * ) pvPortMalloc( sizeof( tskTCB ) );
    120e:	81 e2       	ldi	r24, 0x21	; 33
    1210:	90 e0       	ldi	r25, 0x00	; 0
    1212:	0e 94 80 02 	call	0x500	; 0x500 <pvPortMalloc>
    1216:	08 2f       	mov	r16, r24
    1218:	19 2f       	mov	r17, r25

	if( pxNewTCB != NULL )
    121a:	01 15       	cp	r16, r1
    121c:	11 05       	cpc	r17, r1
    121e:	09 f4       	brne	.+2      	; 0x1222 <xTaskGenericCreate+0x42>
    1220:	dd c0       	rjmp	.+442    	; 0x13dc <xTaskGenericCreate+0x1fc>
	{
		/* Allocate space for the stack used by the task being created.
		The base of the stack memory stored in the TCB so the task can
		be deleted later if required. */
		pxNewTCB->pxStack = ( portSTACK_TYPE * ) pvPortMallocAligned( ( ( ( size_t )usStackDepth ) * sizeof( portSTACK_TYPE ) ), puxStackBuffer );
    1222:	c1 14       	cp	r12, r1
    1224:	d1 04       	cpc	r13, r1
    1226:	09 f0       	breq	.+2      	; 0x122a <xTaskGenericCreate+0x4a>
    1228:	f0 c0       	rjmp	.+480    	; 0x140a <xTaskGenericCreate+0x22a>
    122a:	ce 01       	movw	r24, r28
    122c:	0e 94 80 02 	call	0x500	; 0x500 <pvPortMalloc>
    1230:	c8 2e       	mov	r12, r24
    1232:	d9 2e       	mov	r13, r25
    1234:	f8 01       	movw	r30, r16
    1236:	87 8b       	std	Z+23, r24	; 0x17
    1238:	90 8f       	std	Z+24, r25	; 0x18

		if( pxNewTCB->pxStack == NULL )
    123a:	c1 14       	cp	r12, r1
    123c:	d1 04       	cpc	r13, r1
    123e:	29 f4       	brne	.+10     	; 0x124a <xTaskGenericCreate+0x6a>
		{
			/* Could not allocate the stack.  Delete the allocated TCB. */
			vPortFree( pxNewTCB );
    1240:	c8 01       	movw	r24, r16
    1242:	0e 94 ae 02 	call	0x55c	; 0x55c <vPortFree>
		}
		taskEXIT_CRITICAL();
	}
	else
	{
		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
    1246:	8f ef       	ldi	r24, 0xFF	; 255
    1248:	ce c0       	rjmp	.+412    	; 0x13e6 <xTaskGenericCreate+0x206>
			pxNewTCB = NULL;
		}
		else
		{
			/* Just to help debugging. */
			memset( pxNewTCB->pxStack, ( int ) tskSTACK_FILL_BYTE, ( size_t ) usStackDepth * sizeof( portSTACK_TYPE ) );
    124a:	8c 2d       	mov	r24, r12
    124c:	9d 2d       	mov	r25, r13
    124e:	65 ea       	ldi	r22, 0xA5	; 165
    1250:	70 e0       	ldi	r23, 0x00	; 0
    1252:	7e 01       	movw	r14, r28
    1254:	4c 2f       	mov	r20, r28
    1256:	5f 2d       	mov	r21, r15
    1258:	0e 94 db 0e 	call	0x1db6	; 0x1db6 <memset>
		stack grows from high memory to low (as per the 80x86) or visa versa.
		portSTACK_GROWTH is used to make the result positive or negative as
		required by the port. */
		#if( portSTACK_GROWTH < 0 )
		{
			pxTopOfStack = pxNewTCB->pxStack + ( usStackDepth - ( unsigned short ) 1 );
    125c:	21 97       	sbiw	r28, 0x01	; 1
    125e:	f8 01       	movw	r30, r16
    1260:	87 89       	ldd	r24, Z+23	; 0x17
    1262:	90 8d       	ldd	r25, Z+24	; 0x18
    1264:	c8 0f       	add	r28, r24
    1266:	d9 1f       	adc	r29, r25
{
	/* Store the function name in the TCB. */
	#if configMAX_TASK_NAME_LEN > 1
	{
		/* Don't bring strncpy into the build unnecessarily. */
		strncpy( ( char * ) pxTCB->pcTaskName, ( const char * ) pcName, ( unsigned short ) configMAX_TASK_NAME_LEN );
    1268:	c8 01       	movw	r24, r16
    126a:	49 96       	adiw	r24, 0x19	; 25
    126c:	b3 01       	movw	r22, r6
    126e:	48 e0       	ldi	r20, 0x08	; 8
    1270:	50 e0       	ldi	r21, 0x00	; 0
    1272:	0e 94 e2 0e 	call	0x1dc4	; 0x1dc4 <strncpy>
	}
	#endif
	pxTCB->pcTaskName[ ( unsigned short ) configMAX_TASK_NAME_LEN - ( unsigned short ) 1 ] = ( signed char ) '\0';
    1276:	f8 01       	movw	r30, r16
    1278:	10 a2       	std	Z+32, r1	; 0x20
    127a:	cb 2c       	mov	r12, r11
    127c:	bb 20       	and	r11, r11
    127e:	11 f0       	breq	.+4      	; 0x1284 <xTaskGenericCreate+0xa4>
    1280:	cc 24       	eor	r12, r12
    1282:	c3 94       	inc	r12
	if( uxPriority >= configMAX_PRIORITIES )
	{
		uxPriority = configMAX_PRIORITIES - ( unsigned portBASE_TYPE ) 1U;
	}

	pxTCB->uxPriority = uxPriority;
    1284:	f8 01       	movw	r30, r16
    1286:	c6 8a       	std	Z+22, r12	; 0x16
	{
		pxTCB->uxBasePriority = uxPriority;
	}
	#endif

	vListInitialiseItem( &( pxTCB->xGenericListItem ) );
    1288:	ee 24       	eor	r14, r14
    128a:	ff 24       	eor	r15, r15
    128c:	68 94       	set
    128e:	e1 f8       	bld	r14, 1
    1290:	e0 0e       	add	r14, r16
    1292:	f1 1e       	adc	r15, r17
    1294:	c7 01       	movw	r24, r14
    1296:	0e 94 5a 03 	call	0x6b4	; 0x6b4 <vListInitialiseItem>
	vListInitialiseItem( &( pxTCB->xEventListItem ) );
    129a:	c8 01       	movw	r24, r16
    129c:	0c 96       	adiw	r24, 0x0c	; 12
    129e:	0e 94 5a 03 	call	0x6b4	; 0x6b4 <vListInitialiseItem>

	/* Set the pxTCB as a link back from the xListItem.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxTCB->xGenericListItem ), pxTCB );
    12a2:	f8 01       	movw	r30, r16
    12a4:	11 87       	std	Z+9, r17	; 0x09
    12a6:	00 87       	std	Z+8, r16	; 0x08

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) uxPriority );
    12a8:	82 e0       	ldi	r24, 0x02	; 2
    12aa:	90 e0       	ldi	r25, 0x00	; 0
    12ac:	8c 19       	sub	r24, r12
    12ae:	91 09       	sbc	r25, r1
    12b0:	95 87       	std	Z+13, r25	; 0x0d
    12b2:	84 87       	std	Z+12, r24	; 0x0c
	listSET_LIST_ITEM_OWNER( &( pxTCB->xEventListItem ), pxTCB );
    12b4:	13 8b       	std	Z+19, r17	; 0x13
    12b6:	02 8b       	std	Z+18, r16	; 0x12
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged );
		}
		#else
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
    12b8:	ce 01       	movw	r24, r28
    12ba:	b1 01       	movw	r22, r2
    12bc:	a2 01       	movw	r20, r4
    12be:	0e 94 ea 03 	call	0x7d4	; 0x7d4 <pxPortInitialiseStack>
    12c2:	f8 01       	movw	r30, r16
    12c4:	91 83       	std	Z+1, r25	; 0x01
    12c6:	80 83       	st	Z, r24
		#endif

		/* Check the alignment of the initialised stack. */
		configASSERT( ( ( ( unsigned long ) pxNewTCB->pxTopOfStack & ( unsigned long ) portBYTE_ALIGNMENT_MASK ) == 0UL ) );

		if( ( void * ) pxCreatedTask != NULL )
    12c8:	81 14       	cp	r8, r1
    12ca:	91 04       	cpc	r9, r1
    12cc:	19 f0       	breq	.+6      	; 0x12d4 <xTaskGenericCreate+0xf4>
		{
			/* Pass the TCB out - in an anonymous way.  The calling function/
			task can use this as a handle to delete the task later if
			required.*/
			*pxCreatedTask = ( xTaskHandle ) pxNewTCB;
    12ce:	f4 01       	movw	r30, r8
    12d0:	11 83       	std	Z+1, r17	; 0x01
    12d2:	00 83       	st	Z, r16
		}
		
		/* We are going to manipulate the task queues to add this task to a
		ready list, so must make sure no interrupts occur. */
		taskENTER_CRITICAL();
    12d4:	0f b6       	in	r0, 0x3f	; 63
    12d6:	f8 94       	cli
    12d8:	0f 92       	push	r0
		{
			uxCurrentNumberOfTasks++;
    12da:	80 91 43 03 	lds	r24, 0x0343
    12de:	8f 5f       	subi	r24, 0xFF	; 255
    12e0:	80 93 43 03 	sts	0x0343, r24
			if( pxCurrentTCB == NULL )
    12e4:	80 91 12 03 	lds	r24, 0x0312
    12e8:	90 91 13 03 	lds	r25, 0x0313
    12ec:	00 97       	sbiw	r24, 0x00	; 0
    12ee:	a1 f5       	brne	.+104    	; 0x1358 <xTaskGenericCreate+0x178>
			{
				/* There are no other tasks, or all the other tasks are in
				the suspended state - make this the current task. */
				pxCurrentTCB =  pxNewTCB;
    12f0:	10 93 13 03 	sts	0x0313, r17
    12f4:	00 93 12 03 	sts	0x0312, r16

				if( uxCurrentNumberOfTasks == ( unsigned portBASE_TYPE ) 1 )
    12f8:	80 91 43 03 	lds	r24, 0x0343
    12fc:	81 30       	cpi	r24, 0x01	; 1
    12fe:	d9 f5       	brne	.+118    	; 0x1376 <xTaskGenericCreate+0x196>
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
    1300:	ca e1       	ldi	r28, 0x1A	; 26
    1302:	d3 e0       	ldi	r29, 0x03	; 3
    1304:	ce 01       	movw	r24, r28
    1306:	0e 94 4c 03 	call	0x698	; 0x698 <vListInitialise>
    130a:	ce 01       	movw	r24, r28
    130c:	09 96       	adiw	r24, 0x09	; 9
    130e:	0e 94 4c 03 	call	0x698	; 0x698 <vListInitialise>
	}

	vListInitialise( ( xList * ) &xDelayedTaskList1 );
    1312:	c1 e5       	ldi	r28, 0x51	; 81
    1314:	d3 e0       	ldi	r29, 0x03	; 3
    1316:	ce 01       	movw	r24, r28
    1318:	0e 94 4c 03 	call	0x698	; 0x698 <vListInitialise>
	vListInitialise( ( xList * ) &xDelayedTaskList2 );
    131c:	0f 2e       	mov	r0, r31
    131e:	fa e5       	ldi	r31, 0x5A	; 90
    1320:	cf 2e       	mov	r12, r31
    1322:	f3 e0       	ldi	r31, 0x03	; 3
    1324:	df 2e       	mov	r13, r31
    1326:	f0 2d       	mov	r31, r0
    1328:	c6 01       	movw	r24, r12
    132a:	0e 94 4c 03 	call	0x698	; 0x698 <vListInitialise>
	vListInitialise( ( xList * ) &xPendingReadyList );
    132e:	8c e2       	ldi	r24, 0x2C	; 44
    1330:	93 e0       	ldi	r25, 0x03	; 3
    1332:	0e 94 4c 03 	call	0x698	; 0x698 <vListInitialise>

	#if ( INCLUDE_vTaskDelete == 1 )
	{
		vListInitialise( ( xList * ) &xTasksWaitingTermination );
    1336:	86 e4       	ldi	r24, 0x46	; 70
    1338:	93 e0       	ldi	r25, 0x03	; 3
    133a:	0e 94 4c 03 	call	0x698	; 0x698 <vListInitialise>
	}
	#endif

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		vListInitialise( ( xList * ) &xSuspendedTaskList );
    133e:	85 e3       	ldi	r24, 0x35	; 53
    1340:	93 e0       	ldi	r25, 0x03	; 3
    1342:	0e 94 4c 03 	call	0x698	; 0x698 <vListInitialise>
	}
	#endif

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
    1346:	d0 93 41 03 	sts	0x0341, r29
    134a:	c0 93 40 03 	sts	0x0340, r28
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
    134e:	d0 92 3f 03 	sts	0x033F, r13
    1352:	c0 92 3e 03 	sts	0x033E, r12
    1356:	0f c0       	rjmp	.+30     	; 0x1376 <xTaskGenericCreate+0x196>
			else
			{
				/* If the scheduler is not already running, make this task the
				current task if it is the highest priority task to be created
				so far. */
				if( xSchedulerRunning == pdFALSE )
    1358:	80 91 44 03 	lds	r24, 0x0344
    135c:	88 23       	and	r24, r24
    135e:	59 f4       	brne	.+22     	; 0x1376 <xTaskGenericCreate+0x196>
				{
					if( pxCurrentTCB->uxPriority <= uxPriority )
    1360:	e0 91 12 03 	lds	r30, 0x0312
    1364:	f0 91 13 03 	lds	r31, 0x0313
    1368:	86 89       	ldd	r24, Z+22	; 0x16
    136a:	b8 16       	cp	r11, r24
    136c:	20 f0       	brcs	.+8      	; 0x1376 <xTaskGenericCreate+0x196>
					{
						pxCurrentTCB = pxNewTCB;
    136e:	10 93 13 03 	sts	0x0313, r17
    1372:	00 93 12 03 	sts	0x0312, r16
				}
			}

			/* Remember the top priority to make context switching faster.  Use
			the priority in pxNewTCB as this has been capped to a valid value. */
			if( pxNewTCB->uxPriority > uxTopUsedPriority )
    1376:	f8 01       	movw	r30, r16
    1378:	86 89       	ldd	r24, Z+22	; 0x16
    137a:	90 91 50 03 	lds	r25, 0x0350
    137e:	98 17       	cp	r25, r24
    1380:	10 f4       	brcc	.+4      	; 0x1386 <xTaskGenericCreate+0x1a6>
			{
				uxTopUsedPriority = pxNewTCB->uxPriority;
    1382:	80 93 50 03 	sts	0x0350, r24
			{
				/* Add a counter into the TCB for tracing only. */
				pxNewTCB->uxTCBNumber = uxTaskNumber;
			}
			#endif
			uxTaskNumber++;
    1386:	90 91 4f 03 	lds	r25, 0x034F
    138a:	9f 5f       	subi	r25, 0xFF	; 255
    138c:	90 93 4f 03 	sts	0x034F, r25

			prvAddTaskToReadyQueue( pxNewTCB );
    1390:	90 91 19 03 	lds	r25, 0x0319
    1394:	98 17       	cp	r25, r24
    1396:	10 f4       	brcc	.+4      	; 0x139c <xTaskGenericCreate+0x1bc>
    1398:	80 93 19 03 	sts	0x0319, r24
    139c:	90 e0       	ldi	r25, 0x00	; 0
    139e:	9c 01       	movw	r18, r24
    13a0:	22 0f       	add	r18, r18
    13a2:	33 1f       	adc	r19, r19
    13a4:	22 0f       	add	r18, r18
    13a6:	33 1f       	adc	r19, r19
    13a8:	22 0f       	add	r18, r18
    13aa:	33 1f       	adc	r19, r19
    13ac:	82 0f       	add	r24, r18
    13ae:	93 1f       	adc	r25, r19
    13b0:	86 5e       	subi	r24, 0xE6	; 230
    13b2:	9c 4f       	sbci	r25, 0xFC	; 252
    13b4:	b7 01       	movw	r22, r14
    13b6:	0e 94 5e 03 	call	0x6bc	; 0x6bc <vListInsertEnd>

			xReturn = pdPASS;
			traceTASK_CREATE( pxNewTCB );
		}
		taskEXIT_CRITICAL();
    13ba:	0f 90       	pop	r0
    13bc:	0f be       	out	0x3f, r0	; 63
		traceTASK_CREATE_FAILED();
	}

	if( xReturn == pdPASS )
	{
		if( xSchedulerRunning != pdFALSE )
    13be:	80 91 44 03 	lds	r24, 0x0344
    13c2:	88 23       	and	r24, r24
    13c4:	69 f0       	breq	.+26     	; 0x13e0 <xTaskGenericCreate+0x200>
		{
			/* If the created task is of a higher priority than the current task
			then it should run now. */
			if( pxCurrentTCB->uxPriority < uxPriority )
    13c6:	e0 91 12 03 	lds	r30, 0x0312
    13ca:	f0 91 13 03 	lds	r31, 0x0313
    13ce:	86 89       	ldd	r24, Z+22	; 0x16
    13d0:	8b 15       	cp	r24, r11
    13d2:	40 f4       	brcc	.+16     	; 0x13e4 <xTaskGenericCreate+0x204>
			{
				portYIELD_WITHIN_API();
    13d4:	0e 94 6b 04 	call	0x8d6	; 0x8d6 <vPortYield>
			#endif
			uxTaskNumber++;

			prvAddTaskToReadyQueue( pxNewTCB );

			xReturn = pdPASS;
    13d8:	81 e0       	ldi	r24, 0x01	; 1
    13da:	05 c0       	rjmp	.+10     	; 0x13e6 <xTaskGenericCreate+0x206>
		}
		taskEXIT_CRITICAL();
	}
	else
	{
		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
    13dc:	8f ef       	ldi	r24, 0xFF	; 255
    13de:	03 c0       	rjmp	.+6      	; 0x13e6 <xTaskGenericCreate+0x206>
			#endif
			uxTaskNumber++;

			prvAddTaskToReadyQueue( pxNewTCB );

			xReturn = pdPASS;
    13e0:	81 e0       	ldi	r24, 0x01	; 1
    13e2:	01 c0       	rjmp	.+2      	; 0x13e6 <xTaskGenericCreate+0x206>
    13e4:	81 e0       	ldi	r24, 0x01	; 1
			}
		}
	}

	return xReturn;
}
    13e6:	df 91       	pop	r29
    13e8:	cf 91       	pop	r28
    13ea:	1f 91       	pop	r17
    13ec:	0f 91       	pop	r16
    13ee:	ff 90       	pop	r15
    13f0:	ef 90       	pop	r14
    13f2:	df 90       	pop	r13
    13f4:	cf 90       	pop	r12
    13f6:	bf 90       	pop	r11
    13f8:	9f 90       	pop	r9
    13fa:	8f 90       	pop	r8
    13fc:	7f 90       	pop	r7
    13fe:	6f 90       	pop	r6
    1400:	5f 90       	pop	r5
    1402:	4f 90       	pop	r4
    1404:	3f 90       	pop	r3
    1406:	2f 90       	pop	r2
    1408:	08 95       	ret
	if( pxNewTCB != NULL )
	{
		/* Allocate space for the stack used by the task being created.
		The base of the stack memory stored in the TCB so the task can
		be deleted later if required. */
		pxNewTCB->pxStack = ( portSTACK_TYPE * ) pvPortMallocAligned( ( ( ( size_t )usStackDepth ) * sizeof( portSTACK_TYPE ) ), puxStackBuffer );
    140a:	f8 01       	movw	r30, r16
    140c:	d0 8e       	std	Z+24, r13	; 0x18
    140e:	c7 8a       	std	Z+23, r12	; 0x17
    1410:	1c cf       	rjmp	.-456    	; 0x124a <xTaskGenericCreate+0x6a>

00001412 <vTaskDelete>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

	void vTaskDelete( xTaskHandle pxTaskToDelete )
	{
    1412:	ef 92       	push	r14
    1414:	ff 92       	push	r15
    1416:	0f 93       	push	r16
    1418:	1f 93       	push	r17
    141a:	cf 93       	push	r28
    141c:	df 93       	push	r29
    141e:	ec 01       	movw	r28, r24
	tskTCB *pxTCB;

		taskENTER_CRITICAL();
    1420:	0f b6       	in	r0, 0x3f	; 63
    1422:	f8 94       	cli
    1424:	0f 92       	push	r0
		{
			/* Ensure a yield is performed if the current task is being
			deleted. */
			if( pxTaskToDelete == pxCurrentTCB )
    1426:	80 91 12 03 	lds	r24, 0x0312
    142a:	90 91 13 03 	lds	r25, 0x0313
    142e:	c8 17       	cp	r28, r24
    1430:	d9 07       	cpc	r29, r25
    1432:	19 f0       	breq	.+6      	; 0x143a <vTaskDelete+0x28>
			{
				pxTaskToDelete = NULL;
			}

			/* If null is passed in here then we are deleting ourselves. */
			pxTCB = prvGetTCBFromHandle( pxTaskToDelete );
    1434:	20 97       	sbiw	r28, 0x00	; 0
    1436:	41 f4       	brne	.+16     	; 0x1448 <vTaskDelete+0x36>
    1438:	02 c0       	rjmp	.+4      	; 0x143e <vTaskDelete+0x2c>
		{
			/* Ensure a yield is performed if the current task is being
			deleted. */
			if( pxTaskToDelete == pxCurrentTCB )
			{
				pxTaskToDelete = NULL;
    143a:	c0 e0       	ldi	r28, 0x00	; 0
    143c:	d0 e0       	ldi	r29, 0x00	; 0
			}

			/* If null is passed in here then we are deleting ourselves. */
			pxTCB = prvGetTCBFromHandle( pxTaskToDelete );
    143e:	00 91 12 03 	lds	r16, 0x0312
    1442:	10 91 13 03 	lds	r17, 0x0313
    1446:	01 c0       	rjmp	.+2      	; 0x144a <vTaskDelete+0x38>
    1448:	8e 01       	movw	r16, r28

			/* Remove task from the ready list and place in the	termination list.
			This will stop the task from be scheduled.  The idle task will check
			the termination list and free up any memory allocated by the
			scheduler for the TCB and stack. */
			vListRemove( &( pxTCB->xGenericListItem ) );
    144a:	ee 24       	eor	r14, r14
    144c:	ff 24       	eor	r15, r15
    144e:	68 94       	set
    1450:	e1 f8       	bld	r14, 1
    1452:	e0 0e       	add	r14, r16
    1454:	f1 1e       	adc	r15, r17
    1456:	c7 01       	movw	r24, r14
    1458:	0e 94 c4 03 	call	0x788	; 0x788 <vListRemove>

			/* Is the task waiting on an event also? */
			if( pxTCB->xEventListItem.pvContainer != NULL )
    145c:	f8 01       	movw	r30, r16
    145e:	84 89       	ldd	r24, Z+20	; 0x14
    1460:	95 89       	ldd	r25, Z+21	; 0x15
    1462:	00 97       	sbiw	r24, 0x00	; 0
    1464:	21 f0       	breq	.+8      	; 0x146e <vTaskDelete+0x5c>
			{
				vListRemove( &( pxTCB->xEventListItem ) );
    1466:	c8 01       	movw	r24, r16
    1468:	0c 96       	adiw	r24, 0x0c	; 12
    146a:	0e 94 c4 03 	call	0x788	; 0x788 <vListRemove>
			}

			vListInsertEnd( ( xList * ) &xTasksWaitingTermination, &( pxTCB->xGenericListItem ) );
    146e:	86 e4       	ldi	r24, 0x46	; 70
    1470:	93 e0       	ldi	r25, 0x03	; 3
    1472:	b7 01       	movw	r22, r14
    1474:	0e 94 5e 03 	call	0x6bc	; 0x6bc <vListInsertEnd>

			/* Increment the ucTasksDeleted variable so the idle task knows
			there is a task that has been deleted and that it should therefore
			check the xTasksWaitingTermination list. */
			++uxTasksDeleted;
    1478:	80 91 45 03 	lds	r24, 0x0345
    147c:	8f 5f       	subi	r24, 0xFF	; 255
    147e:	80 93 45 03 	sts	0x0345, r24

			/* Increment the uxTaskNumberVariable also so kernel aware debuggers
			can detect that the task lists need re-generating. */
			uxTaskNumber++;
    1482:	80 91 4f 03 	lds	r24, 0x034F
    1486:	8f 5f       	subi	r24, 0xFF	; 255
    1488:	80 93 4f 03 	sts	0x034F, r24

			traceTASK_DELETE( pxTCB );
		}
		taskEXIT_CRITICAL();
    148c:	0f 90       	pop	r0
    148e:	0f be       	out	0x3f, r0	; 63

		/* Force a reschedule if we have just deleted the current task. */
		if( xSchedulerRunning != pdFALSE )
    1490:	80 91 44 03 	lds	r24, 0x0344
    1494:	88 23       	and	r24, r24
    1496:	21 f0       	breq	.+8      	; 0x14a0 <vTaskDelete+0x8e>
		{
			if( ( void * ) pxTaskToDelete == NULL )
    1498:	20 97       	sbiw	r28, 0x00	; 0
    149a:	11 f4       	brne	.+4      	; 0x14a0 <vTaskDelete+0x8e>
			{
				portYIELD_WITHIN_API();
    149c:	0e 94 6b 04 	call	0x8d6	; 0x8d6 <vPortYield>
			}
		}
	}
    14a0:	df 91       	pop	r29
    14a2:	cf 91       	pop	r28
    14a4:	1f 91       	pop	r17
    14a6:	0f 91       	pop	r16
    14a8:	ff 90       	pop	r15
    14aa:	ef 90       	pop	r14
    14ac:	08 95       	ret

000014ae <xTaskIsTaskSuspended>:
#if ( INCLUDE_vTaskSuspend == 1 )

	signed portBASE_TYPE xTaskIsTaskSuspended( xTaskHandle xTask )
	{
	portBASE_TYPE xReturn = pdFALSE;
	const tskTCB * const pxTCB = ( tskTCB * ) xTask;
    14ae:	e8 2f       	mov	r30, r24
    14b0:	f9 2f       	mov	r31, r25
		/* It does not make sense to check if the calling task is suspended. */
		configASSERT( xTask );

		/* Is the task we are attempting to resume actually in the
		suspended list? */
		if( listIS_CONTAINED_WITHIN( &xSuspendedTaskList, &( pxTCB->xGenericListItem ) ) != pdFALSE )
    14b2:	82 85       	ldd	r24, Z+10	; 0x0a
    14b4:	93 85       	ldd	r25, Z+11	; 0x0b
    14b6:	23 e0       	ldi	r18, 0x03	; 3
    14b8:	85 33       	cpi	r24, 0x35	; 53
    14ba:	92 07       	cpc	r25, r18
    14bc:	61 f4       	brne	.+24     	; 0x14d6 <xTaskIsTaskSuspended+0x28>
		{
			/* Has the task already been resumed from within an ISR? */
			if( listIS_CONTAINED_WITHIN( &xPendingReadyList, &( pxTCB->xEventListItem ) ) != pdTRUE )
    14be:	24 89       	ldd	r18, Z+20	; 0x14
    14c0:	35 89       	ldd	r19, Z+21	; 0x15
    14c2:	83 e0       	ldi	r24, 0x03	; 3
    14c4:	2c 32       	cpi	r18, 0x2C	; 44
    14c6:	38 07       	cpc	r19, r24
    14c8:	41 f0       	breq	.+16     	; 0x14da <xTaskIsTaskSuspended+0x2c>

#if ( INCLUDE_vTaskSuspend == 1 )

	signed portBASE_TYPE xTaskIsTaskSuspended( xTaskHandle xTask )
	{
	portBASE_TYPE xReturn = pdFALSE;
    14ca:	81 e0       	ldi	r24, 0x01	; 1
    14cc:	21 15       	cp	r18, r1
    14ce:	31 05       	cpc	r19, r1
    14d0:	29 f0       	breq	.+10     	; 0x14dc <xTaskIsTaskSuspended+0x2e>
    14d2:	80 e0       	ldi	r24, 0x00	; 0
    14d4:	08 95       	ret
    14d6:	80 e0       	ldi	r24, 0x00	; 0
    14d8:	08 95       	ret
    14da:	80 e0       	ldi	r24, 0x00	; 0
				}
			}
		}

		return xReturn;
	}
    14dc:	08 95       	ret

000014de <vTaskResume>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskSuspend == 1 )

	void vTaskResume( xTaskHandle pxTaskToResume )
	{
    14de:	ef 92       	push	r14
    14e0:	ff 92       	push	r15
    14e2:	0f 93       	push	r16
    14e4:	1f 93       	push	r17
    14e6:	cf 93       	push	r28
    14e8:	df 93       	push	r29
		/* It does not make sense to resume the calling task. */
		configASSERT( pxTaskToResume );

		/* Remove the task from whichever list it is currently in, and place
		it in the ready list. */
		pxTCB = ( tskTCB * ) pxTaskToResume;
    14ea:	e8 2e       	mov	r14, r24
    14ec:	e7 01       	movw	r28, r14
    14ee:	7e 01       	movw	r14, r28
    14f0:	f9 2e       	mov	r15, r25
    14f2:	e7 01       	movw	r28, r14

		/* The parameter cannot be NULL as it is impossible to resume the
		currently executing task. */
		if( ( pxTCB != NULL ) && ( pxTCB != pxCurrentTCB ) )
    14f4:	20 97       	sbiw	r28, 0x00	; 0
    14f6:	b9 f1       	breq	.+110    	; 0x1566 <vTaskResume+0x88>
    14f8:	80 91 12 03 	lds	r24, 0x0312
    14fc:	90 91 13 03 	lds	r25, 0x0313
    1500:	e8 16       	cp	r14, r24
    1502:	f9 06       	cpc	r15, r25
    1504:	81 f1       	breq	.+96     	; 0x1566 <vTaskResume+0x88>
		{
			taskENTER_CRITICAL();
    1506:	0f b6       	in	r0, 0x3f	; 63
    1508:	f8 94       	cli
    150a:	0f 92       	push	r0
			{
				if( xTaskIsTaskSuspended( pxTCB ) == pdTRUE )
    150c:	c7 01       	movw	r24, r14
    150e:	0e 94 57 0a 	call	0x14ae	; 0x14ae <xTaskIsTaskSuspended>
    1512:	81 30       	cpi	r24, 0x01	; 1
    1514:	31 f5       	brne	.+76     	; 0x1562 <vTaskResume+0x84>
				{
					traceTASK_RESUME( pxTCB );

					/* As we are in a critical section we can access the ready
					lists even if the scheduler is suspended. */
					vListRemove(  &( pxTCB->xGenericListItem ) );
    1516:	87 01       	movw	r16, r14
    1518:	0e 5f       	subi	r16, 0xFE	; 254
    151a:	1f 4f       	sbci	r17, 0xFF	; 255
    151c:	c8 01       	movw	r24, r16
    151e:	0e 94 c4 03 	call	0x788	; 0x788 <vListRemove>
					prvAddTaskToReadyQueue( pxTCB );
    1522:	8e 89       	ldd	r24, Y+22	; 0x16
    1524:	90 91 19 03 	lds	r25, 0x0319
    1528:	98 17       	cp	r25, r24
    152a:	10 f4       	brcc	.+4      	; 0x1530 <vTaskResume+0x52>
    152c:	80 93 19 03 	sts	0x0319, r24
    1530:	90 e0       	ldi	r25, 0x00	; 0
    1532:	9c 01       	movw	r18, r24
    1534:	22 0f       	add	r18, r18
    1536:	33 1f       	adc	r19, r19
    1538:	22 0f       	add	r18, r18
    153a:	33 1f       	adc	r19, r19
    153c:	22 0f       	add	r18, r18
    153e:	33 1f       	adc	r19, r19
    1540:	82 0f       	add	r24, r18
    1542:	93 1f       	adc	r25, r19
    1544:	86 5e       	subi	r24, 0xE6	; 230
    1546:	9c 4f       	sbci	r25, 0xFC	; 252
    1548:	b8 01       	movw	r22, r16
    154a:	0e 94 5e 03 	call	0x6bc	; 0x6bc <vListInsertEnd>

					/* We may have just resumed a higher priority task. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    154e:	e0 91 12 03 	lds	r30, 0x0312
    1552:	f0 91 13 03 	lds	r31, 0x0313
    1556:	9e 89       	ldd	r25, Y+22	; 0x16
    1558:	86 89       	ldd	r24, Z+22	; 0x16
    155a:	98 17       	cp	r25, r24
    155c:	10 f0       	brcs	.+4      	; 0x1562 <vTaskResume+0x84>
					{
						/* This yield may not cause the task just resumed to run, but
						will leave the lists in the correct state for the next yield. */
						portYIELD_WITHIN_API();
    155e:	0e 94 6b 04 	call	0x8d6	; 0x8d6 <vPortYield>
					}
				}
			}
			taskEXIT_CRITICAL();
    1562:	0f 90       	pop	r0
    1564:	0f be       	out	0x3f, r0	; 63
		}
	}
    1566:	df 91       	pop	r29
    1568:	cf 91       	pop	r28
    156a:	1f 91       	pop	r17
    156c:	0f 91       	pop	r16
    156e:	ff 90       	pop	r15
    1570:	ef 90       	pop	r14
    1572:	08 95       	ret

00001574 <xTaskResumeFromISR>:
/*-----------------------------------------------------------*/

#if ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) )

	portBASE_TYPE xTaskResumeFromISR( xTaskHandle pxTaskToResume )
	{
    1574:	ef 92       	push	r14
    1576:	ff 92       	push	r15
    1578:	1f 93       	push	r17
    157a:	cf 93       	push	r28
    157c:	df 93       	push	r29
	portBASE_TYPE xYieldRequired = pdFALSE;
	tskTCB *pxTCB;

		configASSERT( pxTaskToResume );

		pxTCB = ( tskTCB * ) pxTaskToResume;
    157e:	38 2f       	mov	r19, r24
    1580:	e8 2e       	mov	r14, r24
    1582:	e7 01       	movw	r28, r14
    1584:	7e 01       	movw	r14, r28
    1586:	f9 2e       	mov	r15, r25
    1588:	e7 01       	movw	r28, r14

		if( xTaskIsTaskSuspended( pxTCB ) == pdTRUE )
    158a:	83 2f       	mov	r24, r19
    158c:	0e 94 57 0a 	call	0x14ae	; 0x14ae <xTaskIsTaskSuspended>
    1590:	81 30       	cpi	r24, 0x01	; 1
    1592:	b9 f5       	brne	.+110    	; 0x1602 <xTaskResumeFromISR+0x8e>
		{
			traceTASK_RESUME_FROM_ISR( pxTCB );

			if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    1594:	80 91 18 03 	lds	r24, 0x0318
    1598:	88 23       	and	r24, r24
    159a:	51 f5       	brne	.+84     	; 0x15f0 <xTaskResumeFromISR+0x7c>
			{
				xYieldRequired = ( pxTCB->uxPriority >= pxCurrentTCB->uxPriority );
    159c:	e0 91 12 03 	lds	r30, 0x0312
    15a0:	f0 91 13 03 	lds	r31, 0x0313
    15a4:	11 e0       	ldi	r17, 0x01	; 1
    15a6:	9e 89       	ldd	r25, Y+22	; 0x16
    15a8:	86 89       	ldd	r24, Z+22	; 0x16
    15aa:	98 17       	cp	r25, r24
    15ac:	08 f4       	brcc	.+2      	; 0x15b0 <xTaskResumeFromISR+0x3c>
    15ae:	10 e0       	ldi	r17, 0x00	; 0
				vListRemove(  &( pxTCB->xGenericListItem ) );
    15b0:	ee 24       	eor	r14, r14
    15b2:	ff 24       	eor	r15, r15
    15b4:	68 94       	set
    15b6:	e1 f8       	bld	r14, 1
    15b8:	ec 0e       	add	r14, r28
    15ba:	fd 1e       	adc	r15, r29
    15bc:	c7 01       	movw	r24, r14
    15be:	0e 94 c4 03 	call	0x788	; 0x788 <vListRemove>
				prvAddTaskToReadyQueue( pxTCB );
    15c2:	8e 89       	ldd	r24, Y+22	; 0x16
    15c4:	90 91 19 03 	lds	r25, 0x0319
    15c8:	98 17       	cp	r25, r24
    15ca:	10 f4       	brcc	.+4      	; 0x15d0 <xTaskResumeFromISR+0x5c>
    15cc:	80 93 19 03 	sts	0x0319, r24
    15d0:	90 e0       	ldi	r25, 0x00	; 0
    15d2:	9c 01       	movw	r18, r24
    15d4:	22 0f       	add	r18, r18
    15d6:	33 1f       	adc	r19, r19
    15d8:	22 0f       	add	r18, r18
    15da:	33 1f       	adc	r19, r19
    15dc:	22 0f       	add	r18, r18
    15de:	33 1f       	adc	r19, r19
    15e0:	82 0f       	add	r24, r18
    15e2:	93 1f       	adc	r25, r19
    15e4:	86 5e       	subi	r24, 0xE6	; 230
    15e6:	9c 4f       	sbci	r25, 0xFC	; 252
    15e8:	b7 01       	movw	r22, r14
    15ea:	0e 94 5e 03 	call	0x6bc	; 0x6bc <vListInsertEnd>
    15ee:	0a c0       	rjmp	.+20     	; 0x1604 <xTaskResumeFromISR+0x90>
			else
			{
				/* We cannot access the delayed or ready lists, so will hold this
				task pending until the scheduler is resumed, at which point a
				yield will be performed if necessary. */
				vListInsertEnd( ( xList * ) &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
    15f0:	b7 01       	movw	r22, r14
    15f2:	64 5f       	subi	r22, 0xF4	; 244
    15f4:	7f 4f       	sbci	r23, 0xFF	; 255
    15f6:	8c e2       	ldi	r24, 0x2C	; 44
    15f8:	93 e0       	ldi	r25, 0x03	; 3
    15fa:	0e 94 5e 03 	call	0x6bc	; 0x6bc <vListInsertEnd>

#if ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) )

	portBASE_TYPE xTaskResumeFromISR( xTaskHandle pxTaskToResume )
	{
	portBASE_TYPE xYieldRequired = pdFALSE;
    15fe:	10 e0       	ldi	r17, 0x00	; 0
    1600:	01 c0       	rjmp	.+2      	; 0x1604 <xTaskResumeFromISR+0x90>
    1602:	10 e0       	ldi	r17, 0x00	; 0
				vListInsertEnd( ( xList * ) &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
			}
		}

		return xYieldRequired;
	}
    1604:	81 2f       	mov	r24, r17
    1606:	df 91       	pop	r29
    1608:	cf 91       	pop	r28
    160a:	1f 91       	pop	r17
    160c:	ff 90       	pop	r15
    160e:	ef 90       	pop	r14
    1610:	08 95       	ret

00001612 <vTaskStartScheduler>:
 * PUBLIC SCHEDULER CONTROL documented in task.h
 *----------------------------------------------------------*/


void vTaskStartScheduler( void )
{
    1612:	af 92       	push	r10
    1614:	bf 92       	push	r11
    1616:	cf 92       	push	r12
    1618:	df 92       	push	r13
    161a:	ef 92       	push	r14
    161c:	ff 92       	push	r15
    161e:	0f 93       	push	r16
		xReturn = xTaskCreate( prvIdleTask, ( signed char * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), &xIdleTaskHandle );
	}
	#else
	{
		/* Create the idle task without storing its handle. */
		xReturn = xTaskCreate( prvIdleTask, ( signed char * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), NULL );
    1620:	8c ea       	ldi	r24, 0xAC	; 172
    1622:	9c e0       	ldi	r25, 0x0C	; 12
    1624:	66 e7       	ldi	r22, 0x76	; 118
    1626:	70 e0       	ldi	r23, 0x00	; 0
    1628:	45 e5       	ldi	r20, 0x55	; 85
    162a:	50 e0       	ldi	r21, 0x00	; 0
    162c:	20 e0       	ldi	r18, 0x00	; 0
    162e:	30 e0       	ldi	r19, 0x00	; 0
    1630:	00 e0       	ldi	r16, 0x00	; 0
    1632:	ee 24       	eor	r14, r14
    1634:	ff 24       	eor	r15, r15
    1636:	cc 24       	eor	r12, r12
    1638:	dd 24       	eor	r13, r13
    163a:	aa 24       	eor	r10, r10
    163c:	bb 24       	eor	r11, r11
    163e:	0e 94 f0 08 	call	0x11e0	; 0x11e0 <xTaskGenericCreate>
			xReturn = xTimerCreateTimerTask();
		}
	}
	#endif

	if( xReturn == pdPASS )
    1642:	81 30       	cpi	r24, 0x01	; 1
    1644:	49 f4       	brne	.+18     	; 0x1658 <vTaskStartScheduler+0x46>
		so interrupts will automatically get re-enabled when the first task
		starts to run.

		STEPPING THROUGH HERE USING A DEBUGGER CAN CAUSE BIG PROBLEMS IF THE
		DEBUGGER ALLOWS INTERRUPTS TO BE PROCESSED. */
		portDISABLE_INTERRUPTS();
    1646:	f8 94       	cli

		xSchedulerRunning = pdTRUE;
    1648:	80 93 44 03 	sts	0x0344, r24
		xTickCount = ( portTickType ) 0U;
    164c:	10 92 17 03 	sts	0x0317, r1
    1650:	10 92 16 03 	sts	0x0316, r1
		the run time counter time base. */
		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();
		
		/* Setting up the timer tick is hardware specific and thus in the
		portable interface. */
		if( xPortStartScheduler() != pdFALSE )
    1654:	0e 94 35 04 	call	0x86a	; 0x86a <xPortStartScheduler>
		}
	}

	/* This line will only be reached if the kernel could not be started. */
	configASSERT( xReturn );
}
    1658:	0f 91       	pop	r16
    165a:	ff 90       	pop	r15
    165c:	ef 90       	pop	r14
    165e:	df 90       	pop	r13
    1660:	cf 90       	pop	r12
    1662:	bf 90       	pop	r11
    1664:	af 90       	pop	r10
    1666:	08 95       	ret

00001668 <vTaskEndScheduler>:
void vTaskEndScheduler( void )
{
	/* Stop the scheduler interrupts and call the portable scheduler end
	routine so the original ISRs can be restored if necessary.  The port
	layer must ensure interrupts enable	bit is left in the correct state. */
	portDISABLE_INTERRUPTS();
    1668:	f8 94       	cli
	xSchedulerRunning = pdFALSE;
    166a:	10 92 44 03 	sts	0x0344, r1
	vPortEndScheduler();
    166e:	0e 94 6a 04 	call	0x8d4	; 0x8d4 <vPortEndScheduler>
}
    1672:	08 95       	ret

00001674 <vTaskSuspendAll>:

void vTaskSuspendAll( void )
{
	/* A critical section is not required as the variable is of type
	portBASE_TYPE. */
	++uxSchedulerSuspended;
    1674:	80 91 18 03 	lds	r24, 0x0318
    1678:	8f 5f       	subi	r24, 0xFF	; 255
    167a:	80 93 18 03 	sts	0x0318, r24
}
    167e:	08 95       	ret

00001680 <xTaskGetTickCount>:
portTickType xTaskGetTickCount( void )
{
portTickType xTicks;

	/* Critical section required if running on a 16 bit processor. */
	taskENTER_CRITICAL();
    1680:	0f b6       	in	r0, 0x3f	; 63
    1682:	f8 94       	cli
    1684:	0f 92       	push	r0
	{
		xTicks = xTickCount;
    1686:	20 91 16 03 	lds	r18, 0x0316
    168a:	30 91 17 03 	lds	r19, 0x0317
	}
	taskEXIT_CRITICAL();
    168e:	0f 90       	pop	r0
    1690:	0f be       	out	0x3f, r0	; 63

	return xTicks;
}
    1692:	82 2f       	mov	r24, r18
    1694:	93 2f       	mov	r25, r19
    1696:	08 95       	ret

00001698 <xTaskGetTickCountFromISR>:
{
portTickType xReturn;
unsigned portBASE_TYPE uxSavedInterruptStatus;

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	xReturn = xTickCount;
    1698:	20 91 16 03 	lds	r18, 0x0316
    169c:	30 91 17 03 	lds	r19, 0x0317
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    16a0:	82 2f       	mov	r24, r18
    16a2:	93 2f       	mov	r25, r19
    16a4:	08 95       	ret

000016a6 <uxTaskGetNumberOfTasks>:

unsigned portBASE_TYPE uxTaskGetNumberOfTasks( void )
{
	/* A critical section is not required because the variables are of type
	portBASE_TYPE. */
	return uxCurrentNumberOfTasks;
    16a6:	80 91 43 03 	lds	r24, 0x0343
}
    16aa:	08 95       	ret

000016ac <vTaskIncrementTick>:
 * SCHEDULER INTERNALS AVAILABLE FOR PORTING PURPOSES
 * documented in task.h
 *----------------------------------------------------------*/

void vTaskIncrementTick( void )
{
    16ac:	0f 93       	push	r16
    16ae:	1f 93       	push	r17
    16b0:	cf 93       	push	r28
    16b2:	df 93       	push	r29
tskTCB * pxTCB;

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    16b4:	80 91 18 03 	lds	r24, 0x0318
    16b8:	88 23       	and	r24, r24
    16ba:	09 f0       	breq	.+2      	; 0x16be <vTaskIncrementTick+0x12>
    16bc:	b3 c0       	rjmp	.+358    	; 0x1824 <vTaskIncrementTick+0x178>
	{
		++xTickCount;
    16be:	80 91 16 03 	lds	r24, 0x0316
    16c2:	90 91 17 03 	lds	r25, 0x0317
    16c6:	01 96       	adiw	r24, 0x01	; 1
    16c8:	90 93 17 03 	sts	0x0317, r25
    16cc:	80 93 16 03 	sts	0x0316, r24
		if( xTickCount == ( portTickType ) 0U )
    16d0:	80 91 16 03 	lds	r24, 0x0316
    16d4:	90 91 17 03 	lds	r25, 0x0317
    16d8:	00 97       	sbiw	r24, 0x00	; 0
    16da:	99 f5       	brne	.+102    	; 0x1742 <vTaskIncrementTick+0x96>
			/* Tick count has overflowed so we need to swap the delay lists.
			If there are any items in pxDelayedTaskList here then there is
			an error! */
			configASSERT( ( listLIST_IS_EMPTY( pxDelayedTaskList ) ) );
			
			pxTemp = pxDelayedTaskList;
    16dc:	80 91 40 03 	lds	r24, 0x0340
    16e0:	90 91 41 03 	lds	r25, 0x0341
			pxDelayedTaskList = pxOverflowDelayedTaskList;
    16e4:	20 91 3e 03 	lds	r18, 0x033E
    16e8:	30 91 3f 03 	lds	r19, 0x033F
    16ec:	30 93 41 03 	sts	0x0341, r19
    16f0:	20 93 40 03 	sts	0x0340, r18
			pxOverflowDelayedTaskList = pxTemp;
    16f4:	90 93 3f 03 	sts	0x033F, r25
    16f8:	80 93 3e 03 	sts	0x033E, r24
			xNumOfOverflows++;
    16fc:	80 91 15 03 	lds	r24, 0x0315
    1700:	8f 5f       	subi	r24, 0xFF	; 255
    1702:	80 93 15 03 	sts	0x0315, r24
	
			if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    1706:	e0 91 40 03 	lds	r30, 0x0340
    170a:	f0 91 41 03 	lds	r31, 0x0341
    170e:	80 81       	ld	r24, Z
    1710:	88 23       	and	r24, r24
    1712:	39 f4       	brne	.+14     	; 0x1722 <vTaskIncrementTick+0x76>
				/* The new current delayed list is empty.  Set
				xNextTaskUnblockTime to the maximum possible value so it is
				extremely unlikely that the	
				if( xTickCount >= xNextTaskUnblockTime ) test will pass until
				there is an item in the delayed list. */
				xNextTaskUnblockTime = portMAX_DELAY;
    1714:	8f ef       	ldi	r24, 0xFF	; 255
    1716:	9f ef       	ldi	r25, 0xFF	; 255
    1718:	90 93 7c 00 	sts	0x007C, r25
    171c:	80 93 7b 00 	sts	0x007B, r24
    1720:	10 c0       	rjmp	.+32     	; 0x1742 <vTaskIncrementTick+0x96>
			{
				/* The new current delayed list is not empty, get the value of
				the item at the head of the delayed list.  This is the time at
				which the task at the head of the delayed list should be removed
				from the Blocked state. */
				pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
    1722:	e0 91 40 03 	lds	r30, 0x0340
    1726:	f0 91 41 03 	lds	r31, 0x0341
    172a:	05 80       	ldd	r0, Z+5	; 0x05
    172c:	f6 81       	ldd	r31, Z+6	; 0x06
    172e:	e0 2d       	mov	r30, r0
    1730:	06 80       	ldd	r0, Z+6	; 0x06
    1732:	f7 81       	ldd	r31, Z+7	; 0x07
    1734:	e0 2d       	mov	r30, r0
				xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( pxTCB->xGenericListItem ) );
    1736:	82 81       	ldd	r24, Z+2	; 0x02
    1738:	93 81       	ldd	r25, Z+3	; 0x03
    173a:	90 93 7c 00 	sts	0x007C, r25
    173e:	80 93 7b 00 	sts	0x007B, r24
			}
		}

		/* See if this tick has made a timeout expire. */
		prvCheckDelayedTasks();
    1742:	20 91 16 03 	lds	r18, 0x0316
    1746:	30 91 17 03 	lds	r19, 0x0317
    174a:	80 91 7b 00 	lds	r24, 0x007B
    174e:	90 91 7c 00 	lds	r25, 0x007C
    1752:	28 17       	cp	r18, r24
    1754:	39 07       	cpc	r19, r25
    1756:	08 f4       	brcc	.+2      	; 0x175a <vTaskIncrementTick+0xae>
    1758:	6a c0       	rjmp	.+212    	; 0x182e <vTaskIncrementTick+0x182>
    175a:	e0 91 40 03 	lds	r30, 0x0340
    175e:	f0 91 41 03 	lds	r31, 0x0341
    1762:	80 81       	ld	r24, Z
    1764:	88 23       	and	r24, r24
    1766:	99 f0       	breq	.+38     	; 0x178e <vTaskIncrementTick+0xe2>
    1768:	e0 91 40 03 	lds	r30, 0x0340
    176c:	f0 91 41 03 	lds	r31, 0x0341
    1770:	05 80       	ldd	r0, Z+5	; 0x05
    1772:	f6 81       	ldd	r31, Z+6	; 0x06
    1774:	e0 2d       	mov	r30, r0
    1776:	c6 81       	ldd	r28, Z+6	; 0x06
    1778:	d7 81       	ldd	r29, Z+7	; 0x07
    177a:	8a 81       	ldd	r24, Y+2	; 0x02
    177c:	9b 81       	ldd	r25, Y+3	; 0x03
    177e:	20 91 16 03 	lds	r18, 0x0316
    1782:	30 91 17 03 	lds	r19, 0x0317
    1786:	28 17       	cp	r18, r24
    1788:	39 07       	cpc	r19, r25
    178a:	f8 f4       	brcc	.+62     	; 0x17ca <vTaskIncrementTick+0x11e>
    178c:	19 c0       	rjmp	.+50     	; 0x17c0 <vTaskIncrementTick+0x114>
    178e:	8f ef       	ldi	r24, 0xFF	; 255
    1790:	9f ef       	ldi	r25, 0xFF	; 255
    1792:	90 93 7c 00 	sts	0x007C, r25
    1796:	80 93 7b 00 	sts	0x007B, r24
    179a:	49 c0       	rjmp	.+146    	; 0x182e <vTaskIncrementTick+0x182>
    179c:	e0 91 40 03 	lds	r30, 0x0340
    17a0:	f0 91 41 03 	lds	r31, 0x0341
    17a4:	05 80       	ldd	r0, Z+5	; 0x05
    17a6:	f6 81       	ldd	r31, Z+6	; 0x06
    17a8:	e0 2d       	mov	r30, r0
    17aa:	c6 81       	ldd	r28, Z+6	; 0x06
    17ac:	d7 81       	ldd	r29, Z+7	; 0x07
    17ae:	8a 81       	ldd	r24, Y+2	; 0x02
    17b0:	9b 81       	ldd	r25, Y+3	; 0x03
    17b2:	20 91 16 03 	lds	r18, 0x0316
    17b6:	30 91 17 03 	lds	r19, 0x0317
    17ba:	28 17       	cp	r18, r24
    17bc:	39 07       	cpc	r19, r25
    17be:	28 f4       	brcc	.+10     	; 0x17ca <vTaskIncrementTick+0x11e>
    17c0:	90 93 7c 00 	sts	0x007C, r25
    17c4:	80 93 7b 00 	sts	0x007B, r24
    17c8:	32 c0       	rjmp	.+100    	; 0x182e <vTaskIncrementTick+0x182>
    17ca:	8e 01       	movw	r16, r28
    17cc:	0e 5f       	subi	r16, 0xFE	; 254
    17ce:	1f 4f       	sbci	r17, 0xFF	; 255
    17d0:	c8 01       	movw	r24, r16
    17d2:	0e 94 c4 03 	call	0x788	; 0x788 <vListRemove>
    17d6:	8c 89       	ldd	r24, Y+20	; 0x14
    17d8:	9d 89       	ldd	r25, Y+21	; 0x15
    17da:	00 97       	sbiw	r24, 0x00	; 0
    17dc:	21 f0       	breq	.+8      	; 0x17e6 <vTaskIncrementTick+0x13a>
    17de:	ce 01       	movw	r24, r28
    17e0:	0c 96       	adiw	r24, 0x0c	; 12
    17e2:	0e 94 c4 03 	call	0x788	; 0x788 <vListRemove>
    17e6:	8e 89       	ldd	r24, Y+22	; 0x16
    17e8:	90 91 19 03 	lds	r25, 0x0319
    17ec:	98 17       	cp	r25, r24
    17ee:	10 f4       	brcc	.+4      	; 0x17f4 <vTaskIncrementTick+0x148>
    17f0:	80 93 19 03 	sts	0x0319, r24
    17f4:	90 e0       	ldi	r25, 0x00	; 0
    17f6:	9c 01       	movw	r18, r24
    17f8:	22 0f       	add	r18, r18
    17fa:	33 1f       	adc	r19, r19
    17fc:	22 0f       	add	r18, r18
    17fe:	33 1f       	adc	r19, r19
    1800:	22 0f       	add	r18, r18
    1802:	33 1f       	adc	r19, r19
    1804:	82 0f       	add	r24, r18
    1806:	93 1f       	adc	r25, r19
    1808:	86 5e       	subi	r24, 0xE6	; 230
    180a:	9c 4f       	sbci	r25, 0xFC	; 252
    180c:	b8 01       	movw	r22, r16
    180e:	0e 94 5e 03 	call	0x6bc	; 0x6bc <vListInsertEnd>
    1812:	e0 91 40 03 	lds	r30, 0x0340
    1816:	f0 91 41 03 	lds	r31, 0x0341
    181a:	80 81       	ld	r24, Z
    181c:	88 23       	and	r24, r24
    181e:	09 f0       	breq	.+2      	; 0x1822 <vTaskIncrementTick+0x176>
    1820:	bd cf       	rjmp	.-134    	; 0x179c <vTaskIncrementTick+0xf0>
    1822:	b5 cf       	rjmp	.-150    	; 0x178e <vTaskIncrementTick+0xe2>
	}
	else
	{
		++uxMissedTicks;
    1824:	80 91 42 03 	lds	r24, 0x0342
    1828:	8f 5f       	subi	r24, 0xFF	; 255
    182a:	80 93 42 03 	sts	0x0342, r24
		}
	}
	#endif

	traceTASK_INCREMENT_TICK( xTickCount );
}
    182e:	df 91       	pop	r29
    1830:	cf 91       	pop	r28
    1832:	1f 91       	pop	r17
    1834:	0f 91       	pop	r16
    1836:	08 95       	ret

00001838 <xTaskResumeAll>:
	++uxSchedulerSuspended;
}
/*----------------------------------------------------------*/

signed portBASE_TYPE xTaskResumeAll( void )
{
    1838:	af 92       	push	r10
    183a:	bf 92       	push	r11
    183c:	cf 92       	push	r12
    183e:	df 92       	push	r13
    1840:	ef 92       	push	r14
    1842:	ff 92       	push	r15
    1844:	0f 93       	push	r16
    1846:	1f 93       	push	r17
    1848:	cf 93       	push	r28
    184a:	df 93       	push	r29
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
    184c:	0f b6       	in	r0, 0x3f	; 63
    184e:	f8 94       	cli
    1850:	0f 92       	push	r0
	{
		--uxSchedulerSuspended;
    1852:	80 91 18 03 	lds	r24, 0x0318
    1856:	81 50       	subi	r24, 0x01	; 1
    1858:	80 93 18 03 	sts	0x0318, r24

		if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    185c:	80 91 18 03 	lds	r24, 0x0318
    1860:	88 23       	and	r24, r24
    1862:	09 f0       	breq	.+2      	; 0x1866 <xTaskResumeAll+0x2e>
    1864:	69 c0       	rjmp	.+210    	; 0x1938 <xTaskResumeAll+0x100>
		{
			if( uxCurrentNumberOfTasks > ( unsigned portBASE_TYPE ) 0U )
    1866:	80 91 43 03 	lds	r24, 0x0343
    186a:	88 23       	and	r24, r24
    186c:	81 f5       	brne	.+96     	; 0x18ce <xTaskResumeAll+0x96>
    186e:	67 c0       	rjmp	.+206    	; 0x193e <xTaskResumeAll+0x106>

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) );
    1870:	d6 01       	movw	r26, r12
    1872:	ed 91       	ld	r30, X+
    1874:	fc 91       	ld	r31, X
    1876:	c6 81       	ldd	r28, Z+6	; 0x06
    1878:	d7 81       	ldd	r29, Z+7	; 0x07
					vListRemove( &( pxTCB->xEventListItem ) );
    187a:	ce 01       	movw	r24, r28
    187c:	0c 96       	adiw	r24, 0x0c	; 12
    187e:	0e 94 c4 03 	call	0x788	; 0x788 <vListRemove>
					vListRemove( &( pxTCB->xGenericListItem ) );
    1882:	8e 01       	movw	r16, r28
    1884:	0e 5f       	subi	r16, 0xFE	; 254
    1886:	1f 4f       	sbci	r17, 0xFF	; 255
    1888:	c8 01       	movw	r24, r16
    188a:	0e 94 c4 03 	call	0x788	; 0x788 <vListRemove>
					prvAddTaskToReadyQueue( pxTCB );
    188e:	8e 89       	ldd	r24, Y+22	; 0x16
    1890:	90 91 19 03 	lds	r25, 0x0319
    1894:	98 17       	cp	r25, r24
    1896:	10 f4       	brcc	.+4      	; 0x189c <xTaskResumeAll+0x64>
    1898:	80 93 19 03 	sts	0x0319, r24
    189c:	90 e0       	ldi	r25, 0x00	; 0
    189e:	9c 01       	movw	r18, r24
    18a0:	22 0f       	add	r18, r18
    18a2:	33 1f       	adc	r19, r19
    18a4:	22 0f       	add	r18, r18
    18a6:	33 1f       	adc	r19, r19
    18a8:	22 0f       	add	r18, r18
    18aa:	33 1f       	adc	r19, r19
    18ac:	82 0f       	add	r24, r18
    18ae:	93 1f       	adc	r25, r19
    18b0:	86 5e       	subi	r24, 0xE6	; 230
    18b2:	9c 4f       	sbci	r25, 0xFC	; 252
    18b4:	b8 01       	movw	r22, r16
    18b6:	0e 94 5e 03 	call	0x6bc	; 0x6bc <vListInsertEnd>

					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    18ba:	e0 91 12 03 	lds	r30, 0x0312
    18be:	f0 91 13 03 	lds	r31, 0x0313
    18c2:	9e 89       	ldd	r25, Y+22	; 0x16
    18c4:	86 89       	ldd	r24, Z+22	; 0x16
    18c6:	98 17       	cp	r25, r24
    18c8:	88 f0       	brcs	.+34     	; 0x18ec <xTaskResumeAll+0xb4>
					{
						xYieldRequired = pdTRUE;
    18ca:	ba 2c       	mov	r11, r10
    18cc:	0f c0       	rjmp	.+30     	; 0x18ec <xTaskResumeAll+0xb4>
	{
		--uxSchedulerSuspended;

		if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
		{
			if( uxCurrentNumberOfTasks > ( unsigned portBASE_TYPE ) 0U )
    18ce:	bb 24       	eor	r11, r11
			{
				portBASE_TYPE xYieldRequired = pdFALSE;

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
    18d0:	0f 2e       	mov	r0, r31
    18d2:	fc e2       	ldi	r31, 0x2C	; 44
    18d4:	ef 2e       	mov	r14, r31
    18d6:	f3 e0       	ldi	r31, 0x03	; 3
    18d8:	ff 2e       	mov	r15, r31
    18da:	f0 2d       	mov	r31, r0
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) );
    18dc:	0f 2e       	mov	r0, r31
    18de:	f1 e3       	ldi	r31, 0x31	; 49
    18e0:	cf 2e       	mov	r12, r31
    18e2:	f3 e0       	ldi	r31, 0x03	; 3
    18e4:	df 2e       	mov	r13, r31
    18e6:	f0 2d       	mov	r31, r0

					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
					{
						xYieldRequired = pdTRUE;
    18e8:	aa 24       	eor	r10, r10
    18ea:	a3 94       	inc	r10
			{
				portBASE_TYPE xYieldRequired = pdFALSE;

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
    18ec:	f7 01       	movw	r30, r14
    18ee:	80 81       	ld	r24, Z
    18f0:	88 23       	and	r24, r24
    18f2:	09 f0       	breq	.+2      	; 0x18f6 <xTaskResumeAll+0xbe>
    18f4:	bd cf       	rjmp	.-134    	; 0x1870 <xTaskResumeAll+0x38>
				}

				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
    18f6:	80 91 42 03 	lds	r24, 0x0342
    18fa:	88 23       	and	r24, r24
    18fc:	81 f0       	breq	.+32     	; 0x191e <xTaskResumeAll+0xe6>
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
    18fe:	80 91 42 03 	lds	r24, 0x0342
    1902:	88 23       	and	r24, r24
    1904:	99 f0       	breq	.+38     	; 0x192c <xTaskResumeAll+0xf4>
					{
						vTaskIncrementTick();
    1906:	0e 94 56 0b 	call	0x16ac	; 0x16ac <vTaskIncrementTick>
						--uxMissedTicks;
    190a:	80 91 42 03 	lds	r24, 0x0342
    190e:	81 50       	subi	r24, 0x01	; 1
    1910:	80 93 42 03 	sts	0x0342, r24
				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
    1914:	80 91 42 03 	lds	r24, 0x0342
    1918:	88 23       	and	r24, r24
    191a:	a9 f7       	brne	.-22     	; 0x1906 <xTaskResumeAll+0xce>
    191c:	07 c0       	rjmp	.+14     	; 0x192c <xTaskResumeAll+0xf4>
						xYieldRequired = pdTRUE;
					}
					#endif
				}

				if( ( xYieldRequired == pdTRUE ) || ( xMissedYield == pdTRUE ) )
    191e:	fb 2d       	mov	r31, r11
    1920:	f1 30       	cpi	r31, 0x01	; 1
    1922:	21 f0       	breq	.+8      	; 0x192c <xTaskResumeAll+0xf4>
    1924:	80 91 14 03 	lds	r24, 0x0314
    1928:	81 30       	cpi	r24, 0x01	; 1
    192a:	41 f4       	brne	.+16     	; 0x193c <xTaskResumeAll+0x104>
				{
					xAlreadyYielded = pdTRUE;
					xMissedYield = pdFALSE;
    192c:	10 92 14 03 	sts	0x0314, r1
					portYIELD_WITHIN_API();
    1930:	0e 94 6b 04 	call	0x8d6	; 0x8d6 <vPortYield>
					#endif
				}

				if( ( xYieldRequired == pdTRUE ) || ( xMissedYield == pdTRUE ) )
				{
					xAlreadyYielded = pdTRUE;
    1934:	81 e0       	ldi	r24, 0x01	; 1
    1936:	03 c0       	rjmp	.+6      	; 0x193e <xTaskResumeAll+0x106>
/*----------------------------------------------------------*/

signed portBASE_TYPE xTaskResumeAll( void )
{
register tskTCB *pxTCB;
signed portBASE_TYPE xAlreadyYielded = pdFALSE;
    1938:	80 e0       	ldi	r24, 0x00	; 0
    193a:	01 c0       	rjmp	.+2      	; 0x193e <xTaskResumeAll+0x106>
    193c:	80 e0       	ldi	r24, 0x00	; 0
					portYIELD_WITHIN_API();
				}
			}
		}
	}
	taskEXIT_CRITICAL();
    193e:	0f 90       	pop	r0
    1940:	0f be       	out	0x3f, r0	; 63

	return xAlreadyYielded;
}
    1942:	df 91       	pop	r29
    1944:	cf 91       	pop	r28
    1946:	1f 91       	pop	r17
    1948:	0f 91       	pop	r16
    194a:	ff 90       	pop	r15
    194c:	ef 90       	pop	r14
    194e:	df 90       	pop	r13
    1950:	cf 90       	pop	r12
    1952:	bf 90       	pop	r11
    1954:	af 90       	pop	r10
    1956:	08 95       	ret

00001958 <prvIdleTask>:
 *
 * void prvIdleTask( void *pvParameters );
 *
 */
static portTASK_FUNCTION( prvIdleTask, pvParameters )
{
    1958:	cf 92       	push	r12
    195a:	df 92       	push	r13
    195c:	ff 92       	push	r15
    195e:	0f 93       	push	r16
    1960:	1f 93       	push	r17
    1962:	cf 93       	push	r28
    1964:	df 93       	push	r29
		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		if( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0U )
		{
			vTaskSuspendAll();
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
    1966:	06 e4       	ldi	r16, 0x46	; 70
    1968:	13 e0       	ldi	r17, 0x03	; 3
			{
				tskTCB *pxTCB;

				taskENTER_CRITICAL();
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( ( ( xList * ) &xTasksWaitingTermination ) );
    196a:	0f 2e       	mov	r0, r31
    196c:	fb e4       	ldi	r31, 0x4B	; 75
    196e:	cf 2e       	mov	r12, r31
    1970:	f3 e0       	ldi	r31, 0x03	; 3
    1972:	df 2e       	mov	r13, r31
    1974:	f0 2d       	mov	r31, r0
	{
		portBASE_TYPE xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		if( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0U )
    1976:	80 91 45 03 	lds	r24, 0x0345
    197a:	88 23       	and	r24, r24
    197c:	e1 f3       	breq	.-8      	; 0x1976 <prvIdleTask+0x1e>
		{
			vTaskSuspendAll();
    197e:	0e 94 3a 0b 	call	0x1674	; 0x1674 <vTaskSuspendAll>
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
    1982:	d8 01       	movw	r26, r16
    1984:	fc 90       	ld	r15, X
			xTaskResumeAll();
    1986:	0e 94 1c 0c 	call	0x1838	; 0x1838 <xTaskResumeAll>

			if( xListIsEmpty == pdFALSE )
    198a:	ff 20       	and	r15, r15
    198c:	a1 f3       	breq	.-24     	; 0x1976 <prvIdleTask+0x1e>
			{
				tskTCB *pxTCB;

				taskENTER_CRITICAL();
    198e:	0f b6       	in	r0, 0x3f	; 63
    1990:	f8 94       	cli
    1992:	0f 92       	push	r0
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( ( ( xList * ) &xTasksWaitingTermination ) );
    1994:	d6 01       	movw	r26, r12
    1996:	ed 91       	ld	r30, X+
    1998:	fc 91       	ld	r31, X
    199a:	c6 81       	ldd	r28, Z+6	; 0x06
    199c:	d7 81       	ldd	r29, Z+7	; 0x07
					vListRemove( &( pxTCB->xGenericListItem ) );
    199e:	ce 01       	movw	r24, r28
    19a0:	02 96       	adiw	r24, 0x02	; 2
    19a2:	0e 94 c4 03 	call	0x788	; 0x788 <vListRemove>
					--uxCurrentNumberOfTasks;
    19a6:	80 91 43 03 	lds	r24, 0x0343
    19aa:	81 50       	subi	r24, 0x01	; 1
    19ac:	80 93 43 03 	sts	0x0343, r24
					--uxTasksDeleted;
    19b0:	80 91 45 03 	lds	r24, 0x0345
    19b4:	81 50       	subi	r24, 0x01	; 1
    19b6:	80 93 45 03 	sts	0x0345, r24
				}
				taskEXIT_CRITICAL();
    19ba:	0f 90       	pop	r0
    19bc:	0f be       	out	0x3f, r0	; 63

	static void prvDeleteTCB( tskTCB *pxTCB )
	{
		/* Free up the memory allocated by the scheduler for the task.  It is up to
		the task to free any memory allocated at the application level. */
		vPortFreeAligned( pxTCB->pxStack );
    19be:	8f 89       	ldd	r24, Y+23	; 0x17
    19c0:	98 8d       	ldd	r25, Y+24	; 0x18
    19c2:	0e 94 ae 02 	call	0x55c	; 0x55c <vPortFree>
		vPortFree( pxTCB );
    19c6:	ce 01       	movw	r24, r28
    19c8:	0e 94 ae 02 	call	0x55c	; 0x55c <vPortFree>
    19cc:	d4 cf       	rjmp	.-88     	; 0x1976 <prvIdleTask+0x1e>

000019ce <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( portTickType xTicksToDelay )
	{
    19ce:	0f 93       	push	r16
    19d0:	1f 93       	push	r17
    19d2:	cf 93       	push	r28
    19d4:	df 93       	push	r29
    19d6:	ec 01       	movw	r28, r24
	portTickType xTimeToWake;
	signed portBASE_TYPE xAlreadyYielded = pdFALSE;

		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( portTickType ) 0U )
    19d8:	00 97       	sbiw	r24, 0x00	; 0
    19da:	b1 f0       	breq	.+44     	; 0x1a08 <vTaskDelay+0x3a>
		{
			vTaskSuspendAll();
    19dc:	0e 94 3a 0b 	call	0x1674	; 0x1674 <vTaskSuspendAll>
				This task cannot be in an event list as it is the currently
				executing task. */

				/* Calculate the time to wake - this may overflow but this is
				not a problem. */
				xTimeToWake = xTickCount + xTicksToDelay;
    19e0:	00 91 16 03 	lds	r16, 0x0316
    19e4:	10 91 17 03 	lds	r17, 0x0317

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    19e8:	80 91 12 03 	lds	r24, 0x0312
    19ec:	90 91 13 03 	lds	r25, 0x0313
    19f0:	02 96       	adiw	r24, 0x02	; 2
    19f2:	0e 94 c4 03 	call	0x788	; 0x788 <vListRemove>
				prvAddCurrentTaskToDelayedList( xTimeToWake );
    19f6:	ce 01       	movw	r24, r28
    19f8:	80 0f       	add	r24, r16
    19fa:	91 1f       	adc	r25, r17
    19fc:	0e 94 b9 08 	call	0x1172	; 0x1172 <prvAddCurrentTaskToDelayedList>
			}
			xAlreadyYielded = xTaskResumeAll();
    1a00:	0e 94 1c 0c 	call	0x1838	; 0x1838 <xTaskResumeAll>
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    1a04:	88 23       	and	r24, r24
    1a06:	11 f4       	brne	.+4      	; 0x1a0c <vTaskDelay+0x3e>
		{
			portYIELD_WITHIN_API();
    1a08:	0e 94 6b 04 	call	0x8d6	; 0x8d6 <vPortYield>
		}
	}
    1a0c:	df 91       	pop	r29
    1a0e:	cf 91       	pop	r28
    1a10:	1f 91       	pop	r17
    1a12:	0f 91       	pop	r16
    1a14:	08 95       	ret

00001a16 <vTaskDelayUntil>:
 *----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelayUntil == 1 )

	void vTaskDelayUntil( portTickType * const pxPreviousWakeTime, portTickType xTimeIncrement )
	{
    1a16:	0f 93       	push	r16
    1a18:	1f 93       	push	r17
    1a1a:	cf 93       	push	r28
    1a1c:	df 93       	push	r29
    1a1e:	8c 01       	movw	r16, r24
    1a20:	eb 01       	movw	r28, r22
	portBASE_TYPE xAlreadyYielded, xShouldDelay = pdFALSE;

		configASSERT( pxPreviousWakeTime );
		configASSERT( ( xTimeIncrement > 0U ) );

		vTaskSuspendAll();
    1a22:	0e 94 3a 0b 	call	0x1674	; 0x1674 <vTaskSuspendAll>
		{
			/* Generate the tick time at which the task wants to wake. */
			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
    1a26:	f8 01       	movw	r30, r16
    1a28:	80 81       	ld	r24, Z
    1a2a:	91 81       	ldd	r25, Z+1	; 0x01
    1a2c:	c8 0f       	add	r28, r24
    1a2e:	d9 1f       	adc	r29, r25

			if( xTickCount < *pxPreviousWakeTime )
    1a30:	20 91 16 03 	lds	r18, 0x0316
    1a34:	30 91 17 03 	lds	r19, 0x0317
    1a38:	28 17       	cp	r18, r24
    1a3a:	39 07       	cpc	r19, r25
    1a3c:	68 f4       	brcc	.+26     	; 0x1a58 <vTaskDelayUntil+0x42>
				/* The tick count has overflowed since this function was
				lasted called.  In this case the only time we should ever
				actually delay is if the wake time has also	overflowed,
				and the wake time is greater than the tick time.  When this
				is the case it is as if neither time had overflowed. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xTickCount ) )
    1a3e:	c8 17       	cp	r28, r24
    1a40:	d9 07       	cpc	r29, r25
    1a42:	50 f5       	brcc	.+84     	; 0x1a98 <vTaskDelayUntil+0x82>
    1a44:	80 91 16 03 	lds	r24, 0x0316
    1a48:	90 91 17 03 	lds	r25, 0x0317
					xShouldDelay = pdTRUE;
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
    1a4c:	d1 83       	std	Z+1, r29	; 0x01
    1a4e:	c0 83       	st	Z, r28

			if( xShouldDelay != pdFALSE )
    1a50:	8c 17       	cp	r24, r28
    1a52:	9d 07       	cpc	r25, r29
    1a54:	b0 f4       	brcc	.+44     	; 0x1a82 <vTaskDelayUntil+0x6c>
    1a56:	0b c0       	rjmp	.+22     	; 0x1a6e <vTaskDelayUntil+0x58>
			else
			{
				/* The tick time has not overflowed.  In this case we will
				delay if either the wake time has overflowed, and/or the
				tick time is less than the wake time. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xTickCount ) )
    1a58:	c8 17       	cp	r28, r24
    1a5a:	d9 07       	cpc	r29, r25
    1a5c:	c8 f0       	brcs	.+50     	; 0x1a90 <vTaskDelayUntil+0x7a>
    1a5e:	80 91 16 03 	lds	r24, 0x0316
    1a62:	90 91 17 03 	lds	r25, 0x0317
    1a66:	8c 17       	cp	r24, r28
    1a68:	9d 07       	cpc	r25, r29
    1a6a:	90 f0       	brcs	.+36     	; 0x1a90 <vTaskDelayUntil+0x7a>
    1a6c:	15 c0       	rjmp	.+42     	; 0x1a98 <vTaskDelayUntil+0x82>
				traceTASK_DELAY_UNTIL();

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    1a6e:	80 91 12 03 	lds	r24, 0x0312
    1a72:	90 91 13 03 	lds	r25, 0x0313
    1a76:	02 96       	adiw	r24, 0x02	; 2
    1a78:	0e 94 c4 03 	call	0x788	; 0x788 <vListRemove>
				prvAddCurrentTaskToDelayedList( xTimeToWake );
    1a7c:	ce 01       	movw	r24, r28
    1a7e:	0e 94 b9 08 	call	0x1172	; 0x1172 <prvAddCurrentTaskToDelayedList>
			}
		}
		xAlreadyYielded = xTaskResumeAll();
    1a82:	0e 94 1c 0c 	call	0x1838	; 0x1838 <xTaskResumeAll>

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    1a86:	88 23       	and	r24, r24
    1a88:	59 f4       	brne	.+22     	; 0x1aa0 <vTaskDelayUntil+0x8a>
		{
			portYIELD_WITHIN_API();
    1a8a:	0e 94 6b 04 	call	0x8d6	; 0x8d6 <vPortYield>
    1a8e:	08 c0       	rjmp	.+16     	; 0x1aa0 <vTaskDelayUntil+0x8a>
					xShouldDelay = pdTRUE;
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
    1a90:	f8 01       	movw	r30, r16
    1a92:	d1 83       	std	Z+1, r29	; 0x01
    1a94:	c0 83       	st	Z, r28
    1a96:	eb cf       	rjmp	.-42     	; 0x1a6e <vTaskDelayUntil+0x58>
    1a98:	f8 01       	movw	r30, r16
    1a9a:	d1 83       	std	Z+1, r29	; 0x01
    1a9c:	c0 83       	st	Z, r28
    1a9e:	f1 cf       	rjmp	.-30     	; 0x1a82 <vTaskDelayUntil+0x6c>
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
		{
			portYIELD_WITHIN_API();
		}
	}
    1aa0:	df 91       	pop	r29
    1aa2:	cf 91       	pop	r28
    1aa4:	1f 91       	pop	r17
    1aa6:	0f 91       	pop	r16
    1aa8:	08 95       	ret

00001aaa <vTaskSwitchContext>:
#endif
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
    1aaa:	80 91 18 03 	lds	r24, 0x0318
    1aae:	88 23       	and	r24, r24
    1ab0:	99 f4       	brne	.+38     	; 0x1ad8 <vTaskSwitchContext+0x2e>
	
		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();
	
		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
    1ab2:	80 91 19 03 	lds	r24, 0x0319
    1ab6:	90 e0       	ldi	r25, 0x00	; 0
    1ab8:	fc 01       	movw	r30, r24
    1aba:	ee 0f       	add	r30, r30
    1abc:	ff 1f       	adc	r31, r31
    1abe:	ee 0f       	add	r30, r30
    1ac0:	ff 1f       	adc	r31, r31
    1ac2:	ee 0f       	add	r30, r30
    1ac4:	ff 1f       	adc	r31, r31
    1ac6:	8e 0f       	add	r24, r30
    1ac8:	9f 1f       	adc	r25, r31
    1aca:	fc 01       	movw	r30, r24
    1acc:	e6 5e       	subi	r30, 0xE6	; 230
    1ace:	fc 4f       	sbci	r31, 0xFC	; 252
    1ad0:	80 81       	ld	r24, Z
    1ad2:	88 23       	and	r24, r24
    1ad4:	29 f0       	breq	.+10     	; 0x1ae0 <vTaskSwitchContext+0x36>
    1ad6:	1d c0       	rjmp	.+58     	; 0x1b12 <vTaskSwitchContext+0x68>
{
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xMissedYield = pdTRUE;
    1ad8:	81 e0       	ldi	r24, 0x01	; 1
    1ada:	80 93 14 03 	sts	0x0314, r24
    1ade:	08 95       	ret
	
		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();
	
		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
    1ae0:	2a e1       	ldi	r18, 0x1A	; 26
    1ae2:	33 e0       	ldi	r19, 0x03	; 3
		{
			configASSERT( uxTopReadyPriority );
			--uxTopReadyPriority;
    1ae4:	80 91 19 03 	lds	r24, 0x0319
    1ae8:	81 50       	subi	r24, 0x01	; 1
    1aea:	80 93 19 03 	sts	0x0319, r24
	
		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();
	
		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
    1aee:	80 91 19 03 	lds	r24, 0x0319
    1af2:	90 e0       	ldi	r25, 0x00	; 0
    1af4:	fc 01       	movw	r30, r24
    1af6:	ee 0f       	add	r30, r30
    1af8:	ff 1f       	adc	r31, r31
    1afa:	ee 0f       	add	r30, r30
    1afc:	ff 1f       	adc	r31, r31
    1afe:	ee 0f       	add	r30, r30
    1b00:	ff 1f       	adc	r31, r31
    1b02:	8e 0f       	add	r24, r30
    1b04:	9f 1f       	adc	r25, r31
    1b06:	f9 01       	movw	r30, r18
    1b08:	e8 0f       	add	r30, r24
    1b0a:	f9 1f       	adc	r31, r25
    1b0c:	80 81       	ld	r24, Z
    1b0e:	88 23       	and	r24, r24
    1b10:	49 f3       	breq	.-46     	; 0x1ae4 <vTaskSwitchContext+0x3a>
			--uxTopReadyPriority;
		}
	
		/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the tasks of the
		same priority get an equal share of the processor time. */
		listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopReadyPriority ] ) );
    1b12:	80 91 19 03 	lds	r24, 0x0319
    1b16:	90 e0       	ldi	r25, 0x00	; 0
    1b18:	9c 01       	movw	r18, r24
    1b1a:	22 0f       	add	r18, r18
    1b1c:	33 1f       	adc	r19, r19
    1b1e:	22 0f       	add	r18, r18
    1b20:	33 1f       	adc	r19, r19
    1b22:	22 0f       	add	r18, r18
    1b24:	33 1f       	adc	r19, r19
    1b26:	28 0f       	add	r18, r24
    1b28:	39 1f       	adc	r19, r25
    1b2a:	d9 01       	movw	r26, r18
    1b2c:	a6 5e       	subi	r26, 0xE6	; 230
    1b2e:	bc 4f       	sbci	r27, 0xFC	; 252
    1b30:	11 96       	adiw	r26, 0x01	; 1
    1b32:	ed 91       	ld	r30, X+
    1b34:	fc 91       	ld	r31, X
    1b36:	12 97       	sbiw	r26, 0x02	; 2
    1b38:	02 80       	ldd	r0, Z+2	; 0x02
    1b3a:	f3 81       	ldd	r31, Z+3	; 0x03
    1b3c:	e0 2d       	mov	r30, r0
    1b3e:	12 96       	adiw	r26, 0x02	; 2
    1b40:	fc 93       	st	X, r31
    1b42:	ee 93       	st	-X, r30
    1b44:	11 97       	sbiw	r26, 0x01	; 1
    1b46:	23 5e       	subi	r18, 0xE3	; 227
    1b48:	3c 4f       	sbci	r19, 0xFC	; 252
    1b4a:	e2 17       	cp	r30, r18
    1b4c:	f3 07       	cpc	r31, r19
    1b4e:	29 f4       	brne	.+10     	; 0x1b5a <vTaskSwitchContext+0xb0>
    1b50:	22 81       	ldd	r18, Z+2	; 0x02
    1b52:	33 81       	ldd	r19, Z+3	; 0x03
    1b54:	fd 01       	movw	r30, r26
    1b56:	32 83       	std	Z+2, r19	; 0x02
    1b58:	21 83       	std	Z+1, r18	; 0x01
    1b5a:	fc 01       	movw	r30, r24
    1b5c:	ee 0f       	add	r30, r30
    1b5e:	ff 1f       	adc	r31, r31
    1b60:	ee 0f       	add	r30, r30
    1b62:	ff 1f       	adc	r31, r31
    1b64:	ee 0f       	add	r30, r30
    1b66:	ff 1f       	adc	r31, r31
    1b68:	8e 0f       	add	r24, r30
    1b6a:	9f 1f       	adc	r25, r31
    1b6c:	fc 01       	movw	r30, r24
    1b6e:	e6 5e       	subi	r30, 0xE6	; 230
    1b70:	fc 4f       	sbci	r31, 0xFC	; 252
    1b72:	01 80       	ldd	r0, Z+1	; 0x01
    1b74:	f2 81       	ldd	r31, Z+2	; 0x02
    1b76:	e0 2d       	mov	r30, r0
    1b78:	86 81       	ldd	r24, Z+6	; 0x06
    1b7a:	97 81       	ldd	r25, Z+7	; 0x07
    1b7c:	90 93 13 03 	sts	0x0313, r25
    1b80:	80 93 12 03 	sts	0x0312, r24
    1b84:	08 95       	ret

00001b86 <vTaskSuspend>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskSuspend == 1 )

	void vTaskSuspend( xTaskHandle pxTaskToSuspend )
	{
    1b86:	ef 92       	push	r14
    1b88:	ff 92       	push	r15
    1b8a:	0f 93       	push	r16
    1b8c:	1f 93       	push	r17
    1b8e:	cf 93       	push	r28
    1b90:	df 93       	push	r29
    1b92:	ec 01       	movw	r28, r24
	tskTCB *pxTCB;

		taskENTER_CRITICAL();
    1b94:	0f b6       	in	r0, 0x3f	; 63
    1b96:	f8 94       	cli
    1b98:	0f 92       	push	r0
		{
			/* Ensure a yield is performed if the current task is being
			suspended. */
			if( pxTaskToSuspend == pxCurrentTCB )
    1b9a:	80 91 12 03 	lds	r24, 0x0312
    1b9e:	90 91 13 03 	lds	r25, 0x0313
    1ba2:	c8 17       	cp	r28, r24
    1ba4:	d9 07       	cpc	r29, r25
    1ba6:	19 f0       	breq	.+6      	; 0x1bae <vTaskSuspend+0x28>
			{
				pxTaskToSuspend = NULL;
			}

			/* If null is passed in here then we are suspending ourselves. */
			pxTCB = prvGetTCBFromHandle( pxTaskToSuspend );
    1ba8:	20 97       	sbiw	r28, 0x00	; 0
    1baa:	41 f4       	brne	.+16     	; 0x1bbc <vTaskSuspend+0x36>
    1bac:	02 c0       	rjmp	.+4      	; 0x1bb2 <vTaskSuspend+0x2c>
		{
			/* Ensure a yield is performed if the current task is being
			suspended. */
			if( pxTaskToSuspend == pxCurrentTCB )
			{
				pxTaskToSuspend = NULL;
    1bae:	c0 e0       	ldi	r28, 0x00	; 0
    1bb0:	d0 e0       	ldi	r29, 0x00	; 0
			}

			/* If null is passed in here then we are suspending ourselves. */
			pxTCB = prvGetTCBFromHandle( pxTaskToSuspend );
    1bb2:	00 91 12 03 	lds	r16, 0x0312
    1bb6:	10 91 13 03 	lds	r17, 0x0313
    1bba:	01 c0       	rjmp	.+2      	; 0x1bbe <vTaskSuspend+0x38>
    1bbc:	8e 01       	movw	r16, r28

			traceTASK_SUSPEND( pxTCB );

			/* Remove task from the ready/delayed list and place in the	suspended list. */
			vListRemove( &( pxTCB->xGenericListItem ) );
    1bbe:	ee 24       	eor	r14, r14
    1bc0:	ff 24       	eor	r15, r15
    1bc2:	68 94       	set
    1bc4:	e1 f8       	bld	r14, 1
    1bc6:	e0 0e       	add	r14, r16
    1bc8:	f1 1e       	adc	r15, r17
    1bca:	c7 01       	movw	r24, r14
    1bcc:	0e 94 c4 03 	call	0x788	; 0x788 <vListRemove>

			/* Is the task waiting on an event also? */
			if( pxTCB->xEventListItem.pvContainer != NULL )
    1bd0:	f8 01       	movw	r30, r16
    1bd2:	84 89       	ldd	r24, Z+20	; 0x14
    1bd4:	95 89       	ldd	r25, Z+21	; 0x15
    1bd6:	00 97       	sbiw	r24, 0x00	; 0
    1bd8:	21 f0       	breq	.+8      	; 0x1be2 <vTaskSuspend+0x5c>
			{
				vListRemove( &( pxTCB->xEventListItem ) );
    1bda:	c8 01       	movw	r24, r16
    1bdc:	0c 96       	adiw	r24, 0x0c	; 12
    1bde:	0e 94 c4 03 	call	0x788	; 0x788 <vListRemove>
			}

			vListInsertEnd( ( xList * ) &xSuspendedTaskList, &( pxTCB->xGenericListItem ) );
    1be2:	85 e3       	ldi	r24, 0x35	; 53
    1be4:	93 e0       	ldi	r25, 0x03	; 3
    1be6:	b7 01       	movw	r22, r14
    1be8:	0e 94 5e 03 	call	0x6bc	; 0x6bc <vListInsertEnd>
		}
		taskEXIT_CRITICAL();
    1bec:	0f 90       	pop	r0
    1bee:	0f be       	out	0x3f, r0	; 63

		if( ( void * ) pxTaskToSuspend == NULL )
    1bf0:	20 97       	sbiw	r28, 0x00	; 0
    1bf2:	a1 f4       	brne	.+40     	; 0x1c1c <vTaskSuspend+0x96>
		{
			if( xSchedulerRunning != pdFALSE )
    1bf4:	80 91 44 03 	lds	r24, 0x0344
    1bf8:	88 23       	and	r24, r24
    1bfa:	19 f0       	breq	.+6      	; 0x1c02 <vTaskSuspend+0x7c>
			{
				/* We have just suspended the current task. */
				portYIELD_WITHIN_API();
    1bfc:	0e 94 6b 04 	call	0x8d6	; 0x8d6 <vPortYield>
    1c00:	0d c0       	rjmp	.+26     	; 0x1c1c <vTaskSuspend+0x96>
			else
			{
				/* The scheduler is not running, but the task that was pointed
				to by pxCurrentTCB has just been suspended and pxCurrentTCB
				must be adjusted to point to a different task. */
				if( listCURRENT_LIST_LENGTH( &xSuspendedTaskList ) == uxCurrentNumberOfTasks )
    1c02:	90 91 35 03 	lds	r25, 0x0335
    1c06:	80 91 43 03 	lds	r24, 0x0343
    1c0a:	98 17       	cp	r25, r24
    1c0c:	29 f4       	brne	.+10     	; 0x1c18 <vTaskSuspend+0x92>
				{
					/* No other tasks are ready, so set pxCurrentTCB back to
					NULL so when the next task is created pxCurrentTCB will
					be set to point to it no matter what its relative priority
					is. */
					pxCurrentTCB = NULL;
    1c0e:	10 92 13 03 	sts	0x0313, r1
    1c12:	10 92 12 03 	sts	0x0312, r1
    1c16:	02 c0       	rjmp	.+4      	; 0x1c1c <vTaskSuspend+0x96>
				}
				else
				{
					vTaskSwitchContext();
    1c18:	0e 94 55 0d 	call	0x1aaa	; 0x1aaa <vTaskSwitchContext>
				}
			}
		}
	}
    1c1c:	df 91       	pop	r29
    1c1e:	cf 91       	pop	r28
    1c20:	1f 91       	pop	r17
    1c22:	0f 91       	pop	r16
    1c24:	ff 90       	pop	r15
    1c26:	ef 90       	pop	r14
    1c28:	08 95       	ret

00001c2a <vTaskPlaceOnEventList>:
	}
}
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( const xList * const pxEventList, portTickType xTicksToWait )
{
    1c2a:	cf 93       	push	r28
    1c2c:	df 93       	push	r29
    1c2e:	eb 01       	movw	r28, r22
	SCHEDULER SUSPENDED. */

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event. */
	vListInsert( ( xList * ) pxEventList, ( xListItem * ) &( pxCurrentTCB->xEventListItem ) );
    1c30:	60 91 12 03 	lds	r22, 0x0312
    1c34:	70 91 13 03 	lds	r23, 0x0313
    1c38:	64 5f       	subi	r22, 0xF4	; 244
    1c3a:	7f 4f       	sbci	r23, 0xFF	; 255
    1c3c:	0e 94 85 03 	call	0x70a	; 0x70a <vListInsert>

	/* We must remove ourselves from the ready list before adding ourselves
	to the blocked list as the same list item is used for both lists.  We have
	exclusive access to the ready lists as the scheduler is locked. */
	vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    1c40:	80 91 12 03 	lds	r24, 0x0312
    1c44:	90 91 13 03 	lds	r25, 0x0313
    1c48:	02 96       	adiw	r24, 0x02	; 2
    1c4a:	0e 94 c4 03 	call	0x788	; 0x788 <vListRemove>


	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		if( xTicksToWait == portMAX_DELAY )
    1c4e:	8f ef       	ldi	r24, 0xFF	; 255
    1c50:	cf 3f       	cpi	r28, 0xFF	; 255
    1c52:	d8 07       	cpc	r29, r24
    1c54:	59 f4       	brne	.+22     	; 0x1c6c <vTaskPlaceOnEventList+0x42>
		{
			/* Add ourselves to the suspended task list instead of a delayed task
			list to ensure we are not woken by a timing event.  We will block
			indefinitely. */
			vListInsertEnd( ( xList * ) &xSuspendedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    1c56:	60 91 12 03 	lds	r22, 0x0312
    1c5a:	70 91 13 03 	lds	r23, 0x0313
    1c5e:	6e 5f       	subi	r22, 0xFE	; 254
    1c60:	7f 4f       	sbci	r23, 0xFF	; 255
    1c62:	85 e3       	ldi	r24, 0x35	; 53
    1c64:	93 e0       	ldi	r25, 0x03	; 3
    1c66:	0e 94 5e 03 	call	0x6bc	; 0x6bc <vListInsertEnd>
    1c6a:	08 c0       	rjmp	.+16     	; 0x1c7c <vTaskPlaceOnEventList+0x52>
		}
		else
		{
			/* Calculate the time at which the task should be woken if the event does
			not occur.  This may overflow but this doesn't matter. */
			xTimeToWake = xTickCount + xTicksToWait;
    1c6c:	80 91 16 03 	lds	r24, 0x0316
    1c70:	90 91 17 03 	lds	r25, 0x0317
			prvAddCurrentTaskToDelayedList( xTimeToWake );
    1c74:	8c 0f       	add	r24, r28
    1c76:	9d 1f       	adc	r25, r29
    1c78:	0e 94 b9 08 	call	0x1172	; 0x1172 <prvAddCurrentTaskToDelayedList>
			not occur.  This may overflow but this doesn't matter. */
			xTimeToWake = xTickCount + xTicksToWait;
			prvAddCurrentTaskToDelayedList( xTimeToWake );
	}
	#endif
}
    1c7c:	df 91       	pop	r29
    1c7e:	cf 91       	pop	r28
    1c80:	08 95       	ret

00001c82 <xTaskRemoveFromEventList>:
	
#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xTaskRemoveFromEventList( const xList * const pxEventList )
{
    1c82:	0f 93       	push	r16
    1c84:	1f 93       	push	r17
    1c86:	cf 93       	push	r28
    1c88:	df 93       	push	r29
	get called - the lock count on the queue will get modified instead.  This
	means we can always expect exclusive access to the event list here.
	
	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
    1c8a:	dc 01       	movw	r26, r24
    1c8c:	15 96       	adiw	r26, 0x05	; 5
    1c8e:	ed 91       	ld	r30, X+
    1c90:	fc 91       	ld	r31, X
    1c92:	16 97       	sbiw	r26, 0x06	; 6
    1c94:	c6 81       	ldd	r28, Z+6	; 0x06
    1c96:	d7 81       	ldd	r29, Z+7	; 0x07
	configASSERT( pxUnblockedTCB );
	vListRemove( &( pxUnblockedTCB->xEventListItem ) );
    1c98:	8e 01       	movw	r16, r28
    1c9a:	04 5f       	subi	r16, 0xF4	; 244
    1c9c:	1f 4f       	sbci	r17, 0xFF	; 255
    1c9e:	c8 01       	movw	r24, r16
    1ca0:	0e 94 c4 03 	call	0x788	; 0x788 <vListRemove>

	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    1ca4:	80 91 18 03 	lds	r24, 0x0318
    1ca8:	88 23       	and	r24, r24
    1caa:	e9 f4       	brne	.+58     	; 0x1ce6 <xTaskRemoveFromEventList+0x64>
	{
		vListRemove( &( pxUnblockedTCB->xGenericListItem ) );
    1cac:	8e 01       	movw	r16, r28
    1cae:	0e 5f       	subi	r16, 0xFE	; 254
    1cb0:	1f 4f       	sbci	r17, 0xFF	; 255
    1cb2:	c8 01       	movw	r24, r16
    1cb4:	0e 94 c4 03 	call	0x788	; 0x788 <vListRemove>
		prvAddTaskToReadyQueue( pxUnblockedTCB );
    1cb8:	8e 89       	ldd	r24, Y+22	; 0x16
    1cba:	90 91 19 03 	lds	r25, 0x0319
    1cbe:	98 17       	cp	r25, r24
    1cc0:	10 f4       	brcc	.+4      	; 0x1cc6 <xTaskRemoveFromEventList+0x44>
    1cc2:	80 93 19 03 	sts	0x0319, r24
    1cc6:	90 e0       	ldi	r25, 0x00	; 0
    1cc8:	9c 01       	movw	r18, r24
    1cca:	22 0f       	add	r18, r18
    1ccc:	33 1f       	adc	r19, r19
    1cce:	22 0f       	add	r18, r18
    1cd0:	33 1f       	adc	r19, r19
    1cd2:	22 0f       	add	r18, r18
    1cd4:	33 1f       	adc	r19, r19
    1cd6:	82 0f       	add	r24, r18
    1cd8:	93 1f       	adc	r25, r19
    1cda:	86 5e       	subi	r24, 0xE6	; 230
    1cdc:	9c 4f       	sbci	r25, 0xFC	; 252
    1cde:	b8 01       	movw	r22, r16
    1ce0:	0e 94 5e 03 	call	0x6bc	; 0x6bc <vListInsertEnd>
    1ce4:	05 c0       	rjmp	.+10     	; 0x1cf0 <xTaskRemoveFromEventList+0x6e>
	}
	else
	{
		/* We cannot access the delayed or ready lists, so will hold this
		task pending until the scheduler is resumed. */
		vListInsertEnd( ( xList * ) &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
    1ce6:	8c e2       	ldi	r24, 0x2C	; 44
    1ce8:	93 e0       	ldi	r25, 0x03	; 3
    1cea:	b8 01       	movw	r22, r16
    1cec:	0e 94 5e 03 	call	0x6bc	; 0x6bc <vListInsertEnd>
	}

	if( pxUnblockedTCB->uxPriority >= pxCurrentTCB->uxPriority )
    1cf0:	e0 91 12 03 	lds	r30, 0x0312
    1cf4:	f0 91 13 03 	lds	r31, 0x0313
	else
	{
		xReturn = pdFALSE;
	}

	return xReturn;
    1cf8:	81 e0       	ldi	r24, 0x01	; 1
    1cfa:	2e 89       	ldd	r18, Y+22	; 0x16
    1cfc:	96 89       	ldd	r25, Z+22	; 0x16
    1cfe:	29 17       	cp	r18, r25
    1d00:	08 f4       	brcc	.+2      	; 0x1d04 <xTaskRemoveFromEventList+0x82>
    1d02:	80 e0       	ldi	r24, 0x00	; 0
}
    1d04:	df 91       	pop	r29
    1d06:	cf 91       	pop	r28
    1d08:	1f 91       	pop	r17
    1d0a:	0f 91       	pop	r16
    1d0c:	08 95       	ret

00001d0e <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( xTimeOutType * const pxTimeOut )
{
    1d0e:	fc 01       	movw	r30, r24
	configASSERT( pxTimeOut );
	pxTimeOut->xOverflowCount = xNumOfOverflows;
    1d10:	80 91 15 03 	lds	r24, 0x0315
    1d14:	80 83       	st	Z, r24
	pxTimeOut->xTimeOnEntering = xTickCount;
    1d16:	80 91 16 03 	lds	r24, 0x0316
    1d1a:	90 91 17 03 	lds	r25, 0x0317
    1d1e:	92 83       	std	Z+2, r25	; 0x02
    1d20:	81 83       	std	Z+1, r24	; 0x01
}
    1d22:	08 95       	ret

00001d24 <xTaskCheckForTimeOut>:
/*-----------------------------------------------------------*/

portBASE_TYPE xTaskCheckForTimeOut( xTimeOutType * const pxTimeOut, portTickType * const pxTicksToWait )
{
    1d24:	fc 01       	movw	r30, r24
    1d26:	db 01       	movw	r26, r22
portBASE_TYPE xReturn;

	configASSERT( pxTimeOut );
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
    1d28:	0f b6       	in	r0, 0x3f	; 63
    1d2a:	f8 94       	cli
    1d2c:	0f 92       	push	r0
	{
		#if ( INCLUDE_vTaskSuspend == 1 )
			/* If INCLUDE_vTaskSuspend is set to 1 and the block time specified is
			the maximum block time then the task should block indefinitely, and
			therefore never time out. */
			if( *pxTicksToWait == portMAX_DELAY )
    1d2e:	8d 91       	ld	r24, X+
    1d30:	9c 91       	ld	r25, X
    1d32:	11 97       	sbiw	r26, 0x01	; 1
    1d34:	2f ef       	ldi	r18, 0xFF	; 255
    1d36:	8f 3f       	cpi	r24, 0xFF	; 255
    1d38:	92 07       	cpc	r25, r18
    1d3a:	41 f1       	breq	.+80     	; 0x1d8c <xTaskCheckForTimeOut+0x68>
				xReturn = pdFALSE;
			}
			else /* We are not blocking indefinitely, perform the checks below. */
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( ( portTickType ) xTickCount >= ( portTickType ) pxTimeOut->xTimeOnEntering ) )
    1d3c:	20 91 15 03 	lds	r18, 0x0315
    1d40:	30 81       	ld	r19, Z
    1d42:	32 17       	cp	r19, r18
    1d44:	49 f0       	breq	.+18     	; 0x1d58 <xTaskCheckForTimeOut+0x34>
    1d46:	20 91 16 03 	lds	r18, 0x0316
    1d4a:	30 91 17 03 	lds	r19, 0x0317
    1d4e:	41 81       	ldd	r20, Z+1	; 0x01
    1d50:	52 81       	ldd	r21, Z+2	; 0x02
    1d52:	24 17       	cp	r18, r20
    1d54:	35 07       	cpc	r19, r21
    1d56:	e0 f4       	brcc	.+56     	; 0x1d90 <xTaskCheckForTimeOut+0x6c>
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
		}
		else if( ( ( portTickType ) ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering ) ) < ( portTickType ) *pxTicksToWait )
    1d58:	40 91 16 03 	lds	r20, 0x0316
    1d5c:	50 91 17 03 	lds	r21, 0x0317
    1d60:	21 81       	ldd	r18, Z+1	; 0x01
    1d62:	32 81       	ldd	r19, Z+2	; 0x02
    1d64:	42 1b       	sub	r20, r18
    1d66:	53 0b       	sbc	r21, r19
    1d68:	48 17       	cp	r20, r24
    1d6a:	59 07       	cpc	r21, r25
    1d6c:	98 f4       	brcc	.+38     	; 0x1d94 <xTaskCheckForTimeOut+0x70>
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering );
    1d6e:	40 91 16 03 	lds	r20, 0x0316
    1d72:	50 91 17 03 	lds	r21, 0x0317
    1d76:	24 1b       	sub	r18, r20
    1d78:	35 0b       	sbc	r19, r21
    1d7a:	82 0f       	add	r24, r18
    1d7c:	93 1f       	adc	r25, r19
    1d7e:	8d 93       	st	X+, r24
    1d80:	9c 93       	st	X, r25
			vTaskSetTimeOutState( pxTimeOut );
    1d82:	cf 01       	movw	r24, r30
    1d84:	0e 94 87 0e 	call	0x1d0e	; 0x1d0e <vTaskSetTimeOutState>
			xReturn = pdFALSE;
    1d88:	80 e0       	ldi	r24, 0x00	; 0
    1d8a:	05 c0       	rjmp	.+10     	; 0x1d96 <xTaskCheckForTimeOut+0x72>
			/* If INCLUDE_vTaskSuspend is set to 1 and the block time specified is
			the maximum block time then the task should block indefinitely, and
			therefore never time out. */
			if( *pxTicksToWait == portMAX_DELAY )
			{
				xReturn = pdFALSE;
    1d8c:	80 e0       	ldi	r24, 0x00	; 0
    1d8e:	03 c0       	rjmp	.+6      	; 0x1d96 <xTaskCheckForTimeOut+0x72>
		{
			/* The tick count is greater than the time at which vTaskSetTimeout()
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
    1d90:	81 e0       	ldi	r24, 0x01	; 1
    1d92:	01 c0       	rjmp	.+2      	; 0x1d96 <xTaskCheckForTimeOut+0x72>
			vTaskSetTimeOutState( pxTimeOut );
			xReturn = pdFALSE;
		}
		else
		{
			xReturn = pdTRUE;
    1d94:	81 e0       	ldi	r24, 0x01	; 1
		}
	}
	taskEXIT_CRITICAL();
    1d96:	0f 90       	pop	r0
    1d98:	0f be       	out	0x3f, r0	; 63

	return xReturn;
}
    1d9a:	08 95       	ret

00001d9c <vTaskMissedYield>:
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
	xMissedYield = pdTRUE;
    1d9c:	81 e0       	ldi	r24, 0x01	; 1
    1d9e:	80 93 14 03 	sts	0x0314, r24
}
    1da2:	08 95       	ret

00001da4 <memcpy>:
    1da4:	fb 01       	movw	r30, r22
    1da6:	dc 01       	movw	r26, r24
    1da8:	02 c0       	rjmp	.+4      	; 0x1dae <memcpy+0xa>
    1daa:	01 90       	ld	r0, Z+
    1dac:	0d 92       	st	X+, r0
    1dae:	41 50       	subi	r20, 0x01	; 1
    1db0:	50 40       	sbci	r21, 0x00	; 0
    1db2:	d8 f7       	brcc	.-10     	; 0x1daa <memcpy+0x6>
    1db4:	08 95       	ret

00001db6 <memset>:
    1db6:	dc 01       	movw	r26, r24
    1db8:	01 c0       	rjmp	.+2      	; 0x1dbc <memset+0x6>
    1dba:	6d 93       	st	X+, r22
    1dbc:	41 50       	subi	r20, 0x01	; 1
    1dbe:	50 40       	sbci	r21, 0x00	; 0
    1dc0:	e0 f7       	brcc	.-8      	; 0x1dba <memset+0x4>
    1dc2:	08 95       	ret

00001dc4 <strncpy>:
    1dc4:	fb 01       	movw	r30, r22
    1dc6:	dc 01       	movw	r26, r24
    1dc8:	41 50       	subi	r20, 0x01	; 1
    1dca:	50 40       	sbci	r21, 0x00	; 0
    1dcc:	48 f0       	brcs	.+18     	; 0x1de0 <strncpy+0x1c>
    1dce:	01 90       	ld	r0, Z+
    1dd0:	0d 92       	st	X+, r0
    1dd2:	00 20       	and	r0, r0
    1dd4:	c9 f7       	brne	.-14     	; 0x1dc8 <strncpy+0x4>
    1dd6:	01 c0       	rjmp	.+2      	; 0x1dda <strncpy+0x16>
    1dd8:	1d 92       	st	X+, r1
    1dda:	41 50       	subi	r20, 0x01	; 1
    1ddc:	50 40       	sbci	r21, 0x00	; 0
    1dde:	e0 f7       	brcc	.-8      	; 0x1dd8 <strncpy+0x14>
    1de0:	08 95       	ret

00001de2 <_exit>:
    1de2:	f8 94       	cli

00001de4 <__stop_program>:
    1de4:	ff cf       	rjmp	.-2      	; 0x1de4 <__stop_program>
