
RTOS_LAB3_ATMEGA32.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00001ca2  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000032  00800060  00001ca2  00001d36  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          000002e1  00800092  00800092  00001d68  2**0
                  ALLOC
  3 .stab         00000888  00000000  00000000  00001d68  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      000001d8  00000000  00000000  000025f0  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_aranges 00000120  00000000  00000000  000027c8  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_pubnames 00000649  00000000  00000000  000028e8  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_info   0000252a  00000000  00000000  00002f31  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_abbrev 00000c51  00000000  00000000  0000545b  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_line   0000215d  00000000  00000000  000060ac  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_frame  000004b0  00000000  00000000  0000820c  2**2
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_str    00000fb9  00000000  00000000  000086bc  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_loc    00001701  00000000  00000000  00009675  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_pubtypes 00000448  00000000  00000000  0000ad76  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_ranges 00000090  00000000  00000000  0000b1be  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 2a 00 	jmp	0x54	; 0x54 <__ctors_end>
       4:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
       8:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
       c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      10:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      14:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      18:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      1c:	0c 94 96 05 	jmp	0xb2c	; 0xb2c <__vector_7>
      20:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      24:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      28:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      2c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      30:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      34:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      38:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      3c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      40:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      44:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      48:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      4c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      50:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>

00000054 <__ctors_end>:
      54:	11 24       	eor	r1, r1
      56:	1f be       	out	0x3f, r1	; 63
      58:	cf e5       	ldi	r28, 0x5F	; 95
      5a:	d8 e0       	ldi	r29, 0x08	; 8
      5c:	de bf       	out	0x3e, r29	; 62
      5e:	cd bf       	out	0x3d, r28	; 61

00000060 <__do_copy_data>:
      60:	10 e0       	ldi	r17, 0x00	; 0
      62:	a0 e6       	ldi	r26, 0x60	; 96
      64:	b0 e0       	ldi	r27, 0x00	; 0
      66:	e2 ea       	ldi	r30, 0xA2	; 162
      68:	fc e1       	ldi	r31, 0x1C	; 28
      6a:	02 c0       	rjmp	.+4      	; 0x70 <__do_copy_data+0x10>
      6c:	05 90       	lpm	r0, Z+
      6e:	0d 92       	st	X+, r0
      70:	a2 39       	cpi	r26, 0x92	; 146
      72:	b1 07       	cpc	r27, r17
      74:	d9 f7       	brne	.-10     	; 0x6c <__do_copy_data+0xc>

00000076 <__do_clear_bss>:
      76:	13 e0       	ldi	r17, 0x03	; 3
      78:	a2 e9       	ldi	r26, 0x92	; 146
      7a:	b0 e0       	ldi	r27, 0x00	; 0
      7c:	01 c0       	rjmp	.+2      	; 0x80 <.do_clear_bss_start>

0000007e <.do_clear_bss_loop>:
      7e:	1d 92       	st	X+, r1

00000080 <.do_clear_bss_start>:
      80:	a3 37       	cpi	r26, 0x73	; 115
      82:	b1 07       	cpc	r27, r17
      84:	e1 f7       	brne	.-8      	; 0x7e <.do_clear_bss_loop>
      86:	0e 94 f9 08 	call	0x11f2	; 0x11f2 <main>
      8a:	0c 94 4f 0e 	jmp	0x1c9e	; 0x1c9e <_exit>

0000008e <__bad_interrupt>:
      8e:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000092 <xCoRoutineCreate>:
static void prvCheckDelayedList( void );

/*-----------------------------------------------------------*/

signed portBASE_TYPE xCoRoutineCreate( crCOROUTINE_CODE pxCoRoutineCode, unsigned portBASE_TYPE uxPriority, unsigned portBASE_TYPE uxIndex )
{
      92:	af 92       	push	r10
      94:	bf 92       	push	r11
      96:	cf 92       	push	r12
      98:	df 92       	push	r13
      9a:	ef 92       	push	r14
      9c:	ff 92       	push	r15
      9e:	0f 93       	push	r16
      a0:	1f 93       	push	r17
      a2:	cf 93       	push	r28
      a4:	df 93       	push	r29
      a6:	6c 01       	movw	r12, r24
      a8:	f6 2e       	mov	r15, r22
      aa:	e4 2e       	mov	r14, r20
signed portBASE_TYPE xReturn;
corCRCB *pxCoRoutine;

	/* Allocate the memory that will store the co-routine control block. */
	pxCoRoutine = ( corCRCB * ) pvPortMalloc( sizeof( corCRCB ) );
      ac:	8a e1       	ldi	r24, 0x1A	; 26
      ae:	90 e0       	ldi	r25, 0x00	; 0
      b0:	0e 94 80 02 	call	0x500	; 0x500 <pvPortMalloc>
      b4:	08 2f       	mov	r16, r24
      b6:	19 2f       	mov	r17, r25
	if( pxCoRoutine )
      b8:	01 15       	cp	r16, r1
      ba:	11 05       	cpc	r17, r1
      bc:	09 f4       	brne	.+2      	; 0xc0 <xCoRoutineCreate+0x2e>
      be:	63 c0       	rjmp	.+198    	; 0x186 <xCoRoutineCreate+0xf4>
	{
		/* If pxCurrentCoRoutine is NULL then this is the first co-routine to
		be created and the co-routine data structures need initialising. */
		if( pxCurrentCoRoutine == NULL )
      c0:	80 91 92 00 	lds	r24, 0x0092
      c4:	90 91 93 00 	lds	r25, 0x0093
      c8:	00 97       	sbiw	r24, 0x00	; 0
      ca:	39 f5       	brne	.+78     	; 0x11a <xCoRoutineCreate+0x88>
		{
			pxCurrentCoRoutine = pxCoRoutine;
      cc:	10 93 93 00 	sts	0x0093, r17
      d0:	00 93 92 00 	sts	0x0092, r16
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = 0; uxPriority < configMAX_CO_ROUTINE_PRIORITIES; uxPriority++ )
	{
		vListInitialise( ( xList * ) &( pxReadyCoRoutineLists[ uxPriority ] ) );
      d4:	ce e9       	ldi	r28, 0x9E	; 158
      d6:	d0 e0       	ldi	r29, 0x00	; 0
      d8:	ce 01       	movw	r24, r28
      da:	0e 94 4c 03 	call	0x698	; 0x698 <vListInitialise>
      de:	ce 01       	movw	r24, r28
      e0:	09 96       	adiw	r24, 0x09	; 9
      e2:	0e 94 4c 03 	call	0x698	; 0x698 <vListInitialise>
	}

	vListInitialise( ( xList * ) &xDelayedCoRoutineList1 );
      e6:	ca eb       	ldi	r28, 0xBA	; 186
      e8:	d0 e0       	ldi	r29, 0x00	; 0
      ea:	ce 01       	movw	r24, r28
      ec:	0e 94 4c 03 	call	0x698	; 0x698 <vListInitialise>
	vListInitialise( ( xList * ) &xDelayedCoRoutineList2 );
      f0:	0f 2e       	mov	r0, r31
      f2:	f3 ec       	ldi	r31, 0xC3	; 195
      f4:	af 2e       	mov	r10, r31
      f6:	f0 e0       	ldi	r31, 0x00	; 0
      f8:	bf 2e       	mov	r11, r31
      fa:	f0 2d       	mov	r31, r0
      fc:	c5 01       	movw	r24, r10
      fe:	0e 94 4c 03 	call	0x698	; 0x698 <vListInitialise>
	vListInitialise( ( xList * ) &xPendingReadyCoRoutineList );
     102:	84 e9       	ldi	r24, 0x94	; 148
     104:	90 e0       	ldi	r25, 0x00	; 0
     106:	0e 94 4c 03 	call	0x698	; 0x698 <vListInitialise>

	/* Start with pxDelayedCoRoutineList using list1 and the
	pxOverflowDelayedCoRoutineList using list2. */
	pxDelayedCoRoutineList = &xDelayedCoRoutineList1;
     10a:	d0 93 b7 00 	sts	0x00B7, r29
     10e:	c0 93 b6 00 	sts	0x00B6, r28
	pxOverflowDelayedCoRoutineList = &xDelayedCoRoutineList2;
     112:	b0 92 b9 00 	sts	0x00B9, r11
     116:	a0 92 b8 00 	sts	0x00B8, r10
     11a:	ff 20       	and	r15, r15
     11c:	11 f0       	breq	.+4      	; 0x122 <xCoRoutineCreate+0x90>
     11e:	ff 24       	eor	r15, r15
     120:	f3 94       	inc	r15
		{
			uxPriority = configMAX_CO_ROUTINE_PRIORITIES - 1;
		}

		/* Fill out the co-routine control block from the function parameters. */
		pxCoRoutine->uxState = corINITIAL_STATE;
     122:	f8 01       	movw	r30, r16
     124:	11 8e       	std	Z+25, r1	; 0x19
     126:	10 8e       	std	Z+24, r1	; 0x18
		pxCoRoutine->uxPriority = uxPriority;
     128:	f6 8a       	std	Z+22, r15	; 0x16
		pxCoRoutine->uxIndex = uxIndex;
     12a:	e7 8a       	std	Z+23, r14	; 0x17
		pxCoRoutine->pxCoRoutineFunction = pxCoRoutineCode;
     12c:	e8 01       	movw	r28, r16
     12e:	c9 92       	st	Y+, r12
     130:	d9 92       	st	Y+, r13

		/* Initialise all the other co-routine control block parameters. */
		vListInitialiseItem( &( pxCoRoutine->xGenericListItem ) );
     132:	ce 01       	movw	r24, r28
     134:	0e 94 5a 03 	call	0x6b4	; 0x6b4 <vListInitialiseItem>
		vListInitialiseItem( &( pxCoRoutine->xEventListItem ) );
     138:	c8 01       	movw	r24, r16
     13a:	0c 96       	adiw	r24, 0x0c	; 12
     13c:	0e 94 5a 03 	call	0x6b4	; 0x6b4 <vListInitialiseItem>

		/* Set the co-routine control block as a link back from the xListItem.
		This is so we can get back to the containing CRCB from a generic item
		in a list. */
		listSET_LIST_ITEM_OWNER( &( pxCoRoutine->xGenericListItem ), pxCoRoutine );
     140:	f8 01       	movw	r30, r16
     142:	11 87       	std	Z+9, r17	; 0x09
     144:	00 87       	std	Z+8, r16	; 0x08
		listSET_LIST_ITEM_OWNER( &( pxCoRoutine->xEventListItem ), pxCoRoutine );
     146:	13 8b       	std	Z+19, r17	; 0x13
     148:	02 8b       	std	Z+18, r16	; 0x12
	
		/* Event lists are always in priority order. */
		listSET_LIST_ITEM_VALUE( &( pxCoRoutine->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) uxPriority );
     14a:	82 e0       	ldi	r24, 0x02	; 2
     14c:	90 e0       	ldi	r25, 0x00	; 0
     14e:	8f 19       	sub	r24, r15
     150:	91 09       	sbc	r25, r1
     152:	95 87       	std	Z+13, r25	; 0x0d
     154:	84 87       	std	Z+12, r24	; 0x0c
		
		/* Now the co-routine has been initialised it can be added to the ready
		list at the correct priority. */
		prvAddCoRoutineToReadyQueue( pxCoRoutine );
     156:	86 89       	ldd	r24, Z+22	; 0x16
     158:	90 91 9d 00 	lds	r25, 0x009D
     15c:	98 17       	cp	r25, r24
     15e:	10 f4       	brcc	.+4      	; 0x164 <xCoRoutineCreate+0xd2>
     160:	80 93 9d 00 	sts	0x009D, r24
     164:	90 e0       	ldi	r25, 0x00	; 0
     166:	9c 01       	movw	r18, r24
     168:	22 0f       	add	r18, r18
     16a:	33 1f       	adc	r19, r19
     16c:	22 0f       	add	r18, r18
     16e:	33 1f       	adc	r19, r19
     170:	22 0f       	add	r18, r18
     172:	33 1f       	adc	r19, r19
     174:	82 0f       	add	r24, r18
     176:	93 1f       	adc	r25, r19
     178:	82 56       	subi	r24, 0x62	; 98
     17a:	9f 4f       	sbci	r25, 0xFF	; 255
     17c:	be 01       	movw	r22, r28
     17e:	0e 94 5e 03 	call	0x6bc	; 0x6bc <vListInsertEnd>

		xReturn = pdPASS;
     182:	81 e0       	ldi	r24, 0x01	; 1
     184:	01 c0       	rjmp	.+2      	; 0x188 <xCoRoutineCreate+0xf6>
	}
	else
	{		
		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
     186:	8f ef       	ldi	r24, 0xFF	; 255
	}
	
	return xReturn;	
}
     188:	df 91       	pop	r29
     18a:	cf 91       	pop	r28
     18c:	1f 91       	pop	r17
     18e:	0f 91       	pop	r16
     190:	ff 90       	pop	r15
     192:	ef 90       	pop	r14
     194:	df 90       	pop	r13
     196:	cf 90       	pop	r12
     198:	bf 90       	pop	r11
     19a:	af 90       	pop	r10
     19c:	08 95       	ret

0000019e <vCoRoutineAddToDelayedList>:
/*-----------------------------------------------------------*/

void vCoRoutineAddToDelayedList( portTickType xTicksToDelay, xList *pxEventList )
{
     19e:	0f 93       	push	r16
     1a0:	1f 93       	push	r17
     1a2:	cf 93       	push	r28
     1a4:	df 93       	push	r29
     1a6:	8b 01       	movw	r16, r22
portTickType xTimeToWake;

	/* Calculate the time to wake - this may overflow but this is
	not a problem. */
	xTimeToWake = xCoRoutineTickCount + xTicksToDelay;
     1a8:	c0 91 b4 00 	lds	r28, 0x00B4
     1ac:	d0 91 b5 00 	lds	r29, 0x00B5
     1b0:	c8 0f       	add	r28, r24
     1b2:	d9 1f       	adc	r29, r25

	/* We must remove ourselves from the ready list before adding
	ourselves to the blocked list as the same list item is used for
	both lists. */
	vListRemove( ( xListItem * ) &( pxCurrentCoRoutine->xGenericListItem ) );
     1b4:	80 91 92 00 	lds	r24, 0x0092
     1b8:	90 91 93 00 	lds	r25, 0x0093
     1bc:	02 96       	adiw	r24, 0x02	; 2
     1be:	0e 94 c4 03 	call	0x788	; 0x788 <vListRemove>

	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentCoRoutine->xGenericListItem ), xTimeToWake );
     1c2:	60 91 92 00 	lds	r22, 0x0092
     1c6:	70 91 93 00 	lds	r23, 0x0093
     1ca:	fb 01       	movw	r30, r22
     1cc:	d3 83       	std	Z+3, r29	; 0x03
     1ce:	c2 83       	std	Z+2, r28	; 0x02

	if( xTimeToWake < xCoRoutineTickCount )
     1d0:	80 91 b4 00 	lds	r24, 0x00B4
     1d4:	90 91 b5 00 	lds	r25, 0x00B5
     1d8:	c8 17       	cp	r28, r24
     1da:	d9 07       	cpc	r29, r25
     1dc:	48 f4       	brcc	.+18     	; 0x1f0 <vCoRoutineAddToDelayedList+0x52>
	{
		/* Wake time has overflowed.  Place this item in the
		overflow list. */
		vListInsert( ( xList * ) pxOverflowDelayedCoRoutineList, ( xListItem * ) &( pxCurrentCoRoutine->xGenericListItem ) );
     1de:	6e 5f       	subi	r22, 0xFE	; 254
     1e0:	7f 4f       	sbci	r23, 0xFF	; 255
     1e2:	80 91 b8 00 	lds	r24, 0x00B8
     1e6:	90 91 b9 00 	lds	r25, 0x00B9
     1ea:	0e 94 85 03 	call	0x70a	; 0x70a <vListInsert>
     1ee:	08 c0       	rjmp	.+16     	; 0x200 <vCoRoutineAddToDelayedList+0x62>
	}
	else
	{
		/* The wake time has not overflowed, so we can use the
		current block list. */
		vListInsert( ( xList * ) pxDelayedCoRoutineList, ( xListItem * ) &( pxCurrentCoRoutine->xGenericListItem ) );
     1f0:	6e 5f       	subi	r22, 0xFE	; 254
     1f2:	7f 4f       	sbci	r23, 0xFF	; 255
     1f4:	80 91 b6 00 	lds	r24, 0x00B6
     1f8:	90 91 b7 00 	lds	r25, 0x00B7
     1fc:	0e 94 85 03 	call	0x70a	; 0x70a <vListInsert>
	}

	if( pxEventList )
     200:	01 15       	cp	r16, r1
     202:	11 05       	cpc	r17, r1
     204:	49 f0       	breq	.+18     	; 0x218 <vCoRoutineAddToDelayedList+0x7a>
	{
		/* Also add the co-routine to an event list.  If this is done then the
		function must be called with interrupts disabled. */
		vListInsert( pxEventList, &( pxCurrentCoRoutine->xEventListItem ) );
     206:	60 91 92 00 	lds	r22, 0x0092
     20a:	70 91 93 00 	lds	r23, 0x0093
     20e:	64 5f       	subi	r22, 0xF4	; 244
     210:	7f 4f       	sbci	r23, 0xFF	; 255
     212:	c8 01       	movw	r24, r16
     214:	0e 94 85 03 	call	0x70a	; 0x70a <vListInsert>
	}
}
     218:	df 91       	pop	r29
     21a:	cf 91       	pop	r28
     21c:	1f 91       	pop	r17
     21e:	0f 91       	pop	r16
     220:	08 95       	ret

00000222 <vCoRoutineSchedule>:
	xLastTickCount = xCoRoutineTickCount;
}
/*-----------------------------------------------------------*/

void vCoRoutineSchedule( void )
{
     222:	cf 92       	push	r12
     224:	df 92       	push	r13
     226:	ef 92       	push	r14
     228:	ff 92       	push	r15
     22a:	0f 93       	push	r16
     22c:	1f 93       	push	r17
     22e:	cf 93       	push	r28
     230:	df 93       	push	r29
static void prvCheckPendingReadyList( void )
{
	/* Are there any co-routines waiting to get moved to the ready list?  These
	are co-routines that have been readied by an ISR.  The ISR cannot access
	the	ready lists itself. */
	while( listLIST_IS_EMPTY( &xPendingReadyCoRoutineList ) == pdFALSE )
     232:	80 91 94 00 	lds	r24, 0x0094
     236:	88 23       	and	r24, r24
     238:	b9 f1       	breq	.+110    	; 0x2a8 <vCoRoutineSchedule+0x86>
		corCRCB *pxUnblockedCRCB;

		/* The pending ready list can be accessed by an ISR. */
		portDISABLE_INTERRUPTS();
		{	
			pxUnblockedCRCB = ( corCRCB * ) listGET_OWNER_OF_HEAD_ENTRY( (&xPendingReadyCoRoutineList) );			
     23a:	0f 2e       	mov	r0, r31
     23c:	f9 e9       	ldi	r31, 0x99	; 153
     23e:	ef 2e       	mov	r14, r31
     240:	f0 e0       	ldi	r31, 0x00	; 0
     242:	ff 2e       	mov	r15, r31
     244:	f0 2d       	mov	r31, r0
static void prvCheckPendingReadyList( void )
{
	/* Are there any co-routines waiting to get moved to the ready list?  These
	are co-routines that have been readied by an ISR.  The ISR cannot access
	the	ready lists itself. */
	while( listLIST_IS_EMPTY( &xPendingReadyCoRoutineList ) == pdFALSE )
     246:	0f 2e       	mov	r0, r31
     248:	f4 e9       	ldi	r31, 0x94	; 148
     24a:	cf 2e       	mov	r12, r31
     24c:	f0 e0       	ldi	r31, 0x00	; 0
     24e:	df 2e       	mov	r13, r31
     250:	f0 2d       	mov	r31, r0
	{
		corCRCB *pxUnblockedCRCB;

		/* The pending ready list can be accessed by an ISR. */
		portDISABLE_INTERRUPTS();
     252:	f8 94       	cli
		{	
			pxUnblockedCRCB = ( corCRCB * ) listGET_OWNER_OF_HEAD_ENTRY( (&xPendingReadyCoRoutineList) );			
     254:	d7 01       	movw	r26, r14
     256:	ed 91       	ld	r30, X+
     258:	fc 91       	ld	r31, X
     25a:	c6 81       	ldd	r28, Z+6	; 0x06
     25c:	d7 81       	ldd	r29, Z+7	; 0x07
			vListRemove( &( pxUnblockedCRCB->xEventListItem ) );
     25e:	ce 01       	movw	r24, r28
     260:	0c 96       	adiw	r24, 0x0c	; 12
     262:	0e 94 c4 03 	call	0x788	; 0x788 <vListRemove>
		}
		portENABLE_INTERRUPTS();
     266:	78 94       	sei

		vListRemove( &( pxUnblockedCRCB->xGenericListItem ) );
     268:	8e 01       	movw	r16, r28
     26a:	0e 5f       	subi	r16, 0xFE	; 254
     26c:	1f 4f       	sbci	r17, 0xFF	; 255
     26e:	c8 01       	movw	r24, r16
     270:	0e 94 c4 03 	call	0x788	; 0x788 <vListRemove>
		prvAddCoRoutineToReadyQueue( pxUnblockedCRCB );	
     274:	8e 89       	ldd	r24, Y+22	; 0x16
     276:	90 91 9d 00 	lds	r25, 0x009D
     27a:	98 17       	cp	r25, r24
     27c:	10 f4       	brcc	.+4      	; 0x282 <vCoRoutineSchedule+0x60>
     27e:	80 93 9d 00 	sts	0x009D, r24
     282:	90 e0       	ldi	r25, 0x00	; 0
     284:	9c 01       	movw	r18, r24
     286:	22 0f       	add	r18, r18
     288:	33 1f       	adc	r19, r19
     28a:	22 0f       	add	r18, r18
     28c:	33 1f       	adc	r19, r19
     28e:	22 0f       	add	r18, r18
     290:	33 1f       	adc	r19, r19
     292:	82 0f       	add	r24, r18
     294:	93 1f       	adc	r25, r19
     296:	82 56       	subi	r24, 0x62	; 98
     298:	9f 4f       	sbci	r25, 0xFF	; 255
     29a:	b8 01       	movw	r22, r16
     29c:	0e 94 5e 03 	call	0x6bc	; 0x6bc <vListInsertEnd>
static void prvCheckPendingReadyList( void )
{
	/* Are there any co-routines waiting to get moved to the ready list?  These
	are co-routines that have been readied by an ISR.  The ISR cannot access
	the	ready lists itself. */
	while( listLIST_IS_EMPTY( &xPendingReadyCoRoutineList ) == pdFALSE )
     2a0:	f6 01       	movw	r30, r12
     2a2:	80 81       	ld	r24, Z
     2a4:	88 23       	and	r24, r24
     2a6:	a9 f6       	brne	.-86     	; 0x252 <vCoRoutineSchedule+0x30>

static void prvCheckDelayedList( void )
{
corCRCB *pxCRCB;

	xPassedTicks = xTaskGetTickCount() - xLastTickCount;
     2a8:	0e 94 05 0b 	call	0x160a	; 0x160a <xTaskGetTickCount>
     2ac:	20 91 b0 00 	lds	r18, 0x00B0
     2b0:	30 91 b1 00 	lds	r19, 0x00B1
     2b4:	82 1b       	sub	r24, r18
     2b6:	93 0b       	sbc	r25, r19
     2b8:	90 93 b3 00 	sts	0x00B3, r25
     2bc:	80 93 b2 00 	sts	0x00B2, r24
     2c0:	74 c0       	rjmp	.+232    	; 0x3aa <vCoRoutineSchedule+0x188>
	while( xPassedTicks )
	{
		xCoRoutineTickCount++;
     2c2:	20 91 b4 00 	lds	r18, 0x00B4
     2c6:	30 91 b5 00 	lds	r19, 0x00B5
     2ca:	2f 5f       	subi	r18, 0xFF	; 255
     2cc:	3f 4f       	sbci	r19, 0xFF	; 255
     2ce:	30 93 b5 00 	sts	0x00B5, r19
     2d2:	20 93 b4 00 	sts	0x00B4, r18
		xPassedTicks--;
     2d6:	01 97       	sbiw	r24, 0x01	; 1
     2d8:	90 93 b3 00 	sts	0x00B3, r25
     2dc:	80 93 b2 00 	sts	0x00B2, r24

		/* If the tick count has overflowed we need to swap the ready lists. */
		if( xCoRoutineTickCount == 0 )
     2e0:	21 15       	cp	r18, r1
     2e2:	31 05       	cpc	r19, r1
     2e4:	81 f4       	brne	.+32     	; 0x306 <vCoRoutineSchedule+0xe4>
		{
			xList * pxTemp;

			/* Tick count has overflowed so we need to swap the delay lists.  If there are
			any items in pxDelayedCoRoutineList here then there is an error! */
			pxTemp = pxDelayedCoRoutineList;
     2e6:	80 91 b6 00 	lds	r24, 0x00B6
     2ea:	90 91 b7 00 	lds	r25, 0x00B7
			pxDelayedCoRoutineList = pxOverflowDelayedCoRoutineList;
     2ee:	20 91 b8 00 	lds	r18, 0x00B8
     2f2:	30 91 b9 00 	lds	r19, 0x00B9
     2f6:	30 93 b7 00 	sts	0x00B7, r19
     2fa:	20 93 b6 00 	sts	0x00B6, r18
			pxOverflowDelayedCoRoutineList = pxTemp;
     2fe:	90 93 b9 00 	sts	0x00B9, r25
     302:	80 93 b8 00 	sts	0x00B8, r24
		}

		/* See if this tick has made a timeout expire. */
		while( listLIST_IS_EMPTY( pxDelayedCoRoutineList ) == pdFALSE )
     306:	e0 91 b6 00 	lds	r30, 0x00B6
     30a:	f0 91 b7 00 	lds	r31, 0x00B7
     30e:	80 81       	ld	r24, Z
     310:	88 23       	and	r24, r24
     312:	09 f4       	brne	.+2      	; 0x316 <vCoRoutineSchedule+0xf4>
     314:	4a c0       	rjmp	.+148    	; 0x3aa <vCoRoutineSchedule+0x188>
		{
			pxCRCB = ( corCRCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedCoRoutineList );
     316:	05 80       	ldd	r0, Z+5	; 0x05
     318:	f6 81       	ldd	r31, Z+6	; 0x06
     31a:	e0 2d       	mov	r30, r0
     31c:	c6 81       	ldd	r28, Z+6	; 0x06
     31e:	d7 81       	ldd	r29, Z+7	; 0x07

			if( xCoRoutineTickCount < listGET_LIST_ITEM_VALUE( &( pxCRCB->xGenericListItem ) ) )				
     320:	2a 81       	ldd	r18, Y+2	; 0x02
     322:	3b 81       	ldd	r19, Y+3	; 0x03
     324:	80 91 b4 00 	lds	r24, 0x00B4
     328:	90 91 b5 00 	lds	r25, 0x00B5
     32c:	82 17       	cp	r24, r18
     32e:	93 07       	cpc	r25, r19
     330:	78 f4       	brcc	.+30     	; 0x350 <vCoRoutineSchedule+0x12e>
     332:	3b c0       	rjmp	.+118    	; 0x3aa <vCoRoutineSchedule+0x188>
		}

		/* See if this tick has made a timeout expire. */
		while( listLIST_IS_EMPTY( pxDelayedCoRoutineList ) == pdFALSE )
		{
			pxCRCB = ( corCRCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedCoRoutineList );
     334:	05 80       	ldd	r0, Z+5	; 0x05
     336:	f6 81       	ldd	r31, Z+6	; 0x06
     338:	e0 2d       	mov	r30, r0
     33a:	c6 81       	ldd	r28, Z+6	; 0x06
     33c:	d7 81       	ldd	r29, Z+7	; 0x07

			if( xCoRoutineTickCount < listGET_LIST_ITEM_VALUE( &( pxCRCB->xGenericListItem ) ) )				
     33e:	2a 81       	ldd	r18, Y+2	; 0x02
     340:	3b 81       	ldd	r19, Y+3	; 0x03
     342:	80 91 b4 00 	lds	r24, 0x00B4
     346:	90 91 b5 00 	lds	r25, 0x00B5
     34a:	82 17       	cp	r24, r18
     34c:	93 07       	cpc	r25, r19
     34e:	68 f1       	brcs	.+90     	; 0x3aa <vCoRoutineSchedule+0x188>
			{			
				/* Timeout not yet expired. */																			
				break;																				
			}																						

			portDISABLE_INTERRUPTS();
     350:	f8 94       	cli
				/* The event could have occurred just before this critical
				section.  If this is the case then the generic list item will
				have been moved to the pending ready list and the following
				line is still valid.  Also the pvContainer parameter will have
				been set to NULL so the following lines are also valid. */
				vListRemove( &( pxCRCB->xGenericListItem ) );											
     352:	8e 01       	movw	r16, r28
     354:	0e 5f       	subi	r16, 0xFE	; 254
     356:	1f 4f       	sbci	r17, 0xFF	; 255
     358:	c8 01       	movw	r24, r16
     35a:	0e 94 c4 03 	call	0x788	; 0x788 <vListRemove>

				/* Is the co-routine waiting on an event also? */												
				if( pxCRCB->xEventListItem.pvContainer )													
     35e:	8c 89       	ldd	r24, Y+20	; 0x14
     360:	9d 89       	ldd	r25, Y+21	; 0x15
     362:	00 97       	sbiw	r24, 0x00	; 0
     364:	21 f0       	breq	.+8      	; 0x36e <vCoRoutineSchedule+0x14c>
				{															
					vListRemove( &( pxCRCB->xEventListItem ) );											
     366:	ce 01       	movw	r24, r28
     368:	0c 96       	adiw	r24, 0x0c	; 12
     36a:	0e 94 c4 03 	call	0x788	; 0x788 <vListRemove>
				}
			}
			portENABLE_INTERRUPTS();
     36e:	78 94       	sei

			prvAddCoRoutineToReadyQueue( pxCRCB );													
     370:	8e 89       	ldd	r24, Y+22	; 0x16
     372:	90 91 9d 00 	lds	r25, 0x009D
     376:	98 17       	cp	r25, r24
     378:	10 f4       	brcc	.+4      	; 0x37e <vCoRoutineSchedule+0x15c>
     37a:	80 93 9d 00 	sts	0x009D, r24
     37e:	90 e0       	ldi	r25, 0x00	; 0
     380:	9c 01       	movw	r18, r24
     382:	22 0f       	add	r18, r18
     384:	33 1f       	adc	r19, r19
     386:	22 0f       	add	r18, r18
     388:	33 1f       	adc	r19, r19
     38a:	22 0f       	add	r18, r18
     38c:	33 1f       	adc	r19, r19
     38e:	82 0f       	add	r24, r18
     390:	93 1f       	adc	r25, r19
     392:	82 56       	subi	r24, 0x62	; 98
     394:	9f 4f       	sbci	r25, 0xFF	; 255
     396:	b8 01       	movw	r22, r16
     398:	0e 94 5e 03 	call	0x6bc	; 0x6bc <vListInsertEnd>
			pxDelayedCoRoutineList = pxOverflowDelayedCoRoutineList;
			pxOverflowDelayedCoRoutineList = pxTemp;
		}

		/* See if this tick has made a timeout expire. */
		while( listLIST_IS_EMPTY( pxDelayedCoRoutineList ) == pdFALSE )
     39c:	e0 91 b6 00 	lds	r30, 0x00B6
     3a0:	f0 91 b7 00 	lds	r31, 0x00B7
     3a4:	80 81       	ld	r24, Z
     3a6:	88 23       	and	r24, r24
     3a8:	29 f6       	brne	.-118    	; 0x334 <vCoRoutineSchedule+0x112>
static void prvCheckDelayedList( void )
{
corCRCB *pxCRCB;

	xPassedTicks = xTaskGetTickCount() - xLastTickCount;
	while( xPassedTicks )
     3aa:	80 91 b2 00 	lds	r24, 0x00B2
     3ae:	90 91 b3 00 	lds	r25, 0x00B3
     3b2:	00 97       	sbiw	r24, 0x00	; 0
     3b4:	09 f0       	breq	.+2      	; 0x3b8 <vCoRoutineSchedule+0x196>
     3b6:	85 cf       	rjmp	.-246    	; 0x2c2 <vCoRoutineSchedule+0xa0>

			prvAddCoRoutineToReadyQueue( pxCRCB );													
		}																									
	}

	xLastTickCount = xCoRoutineTickCount;
     3b8:	80 91 b4 00 	lds	r24, 0x00B4
     3bc:	90 91 b5 00 	lds	r25, 0x00B5
     3c0:	90 93 b1 00 	sts	0x00B1, r25
     3c4:	80 93 b0 00 	sts	0x00B0, r24

	/* See if any delayed co-routines have timed out. */
	prvCheckDelayedList();

	/* Find the highest priority queue that contains ready co-routines. */
	while( listLIST_IS_EMPTY( &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) ) )
     3c8:	40 91 9d 00 	lds	r20, 0x009D
     3cc:	84 2f       	mov	r24, r20
     3ce:	90 e0       	ldi	r25, 0x00	; 0
     3d0:	fc 01       	movw	r30, r24
     3d2:	ee 0f       	add	r30, r30
     3d4:	ff 1f       	adc	r31, r31
     3d6:	ee 0f       	add	r30, r30
     3d8:	ff 1f       	adc	r31, r31
     3da:	ee 0f       	add	r30, r30
     3dc:	ff 1f       	adc	r31, r31
     3de:	e8 0f       	add	r30, r24
     3e0:	f9 1f       	adc	r31, r25
     3e2:	e2 56       	subi	r30, 0x62	; 98
     3e4:	ff 4f       	sbci	r31, 0xFF	; 255
     3e6:	20 81       	ld	r18, Z
     3e8:	22 23       	and	r18, r18
     3ea:	e9 f4       	brne	.+58     	; 0x426 <vCoRoutineSchedule+0x204>
	{
		if( uxTopCoRoutineReadyPriority == 0 )
     3ec:	44 23       	and	r20, r20
     3ee:	31 f4       	brne	.+12     	; 0x3fc <vCoRoutineSchedule+0x1da>
     3f0:	57 c0       	rjmp	.+174    	; 0x4a0 <vCoRoutineSchedule+0x27e>
     3f2:	44 23       	and	r20, r20
     3f4:	29 f4       	brne	.+10     	; 0x400 <vCoRoutineSchedule+0x1de>
     3f6:	40 93 9d 00 	sts	0x009D, r20
     3fa:	52 c0       	rjmp	.+164    	; 0x4a0 <vCoRoutineSchedule+0x27e>

	/* See if any delayed co-routines have timed out. */
	prvCheckDelayedList();

	/* Find the highest priority queue that contains ready co-routines. */
	while( listLIST_IS_EMPTY( &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) ) )
     3fc:	2e e9       	ldi	r18, 0x9E	; 158
     3fe:	30 e0       	ldi	r19, 0x00	; 0
		if( uxTopCoRoutineReadyPriority == 0 )
		{
			/* No more co-routines to check. */
			return;
		}
		--uxTopCoRoutineReadyPriority;
     400:	41 50       	subi	r20, 0x01	; 1

	/* See if any delayed co-routines have timed out. */
	prvCheckDelayedList();

	/* Find the highest priority queue that contains ready co-routines. */
	while( listLIST_IS_EMPTY( &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) ) )
     402:	84 2f       	mov	r24, r20
     404:	90 e0       	ldi	r25, 0x00	; 0
     406:	fc 01       	movw	r30, r24
     408:	ee 0f       	add	r30, r30
     40a:	ff 1f       	adc	r31, r31
     40c:	ee 0f       	add	r30, r30
     40e:	ff 1f       	adc	r31, r31
     410:	ee 0f       	add	r30, r30
     412:	ff 1f       	adc	r31, r31
     414:	e8 0f       	add	r30, r24
     416:	f9 1f       	adc	r31, r25
     418:	e2 0f       	add	r30, r18
     41a:	f3 1f       	adc	r31, r19
     41c:	50 81       	ld	r21, Z
     41e:	55 23       	and	r21, r21
     420:	41 f3       	breq	.-48     	; 0x3f2 <vCoRoutineSchedule+0x1d0>
     422:	40 93 9d 00 	sts	0x009D, r20
		--uxTopCoRoutineReadyPriority;
	}

	/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the co-routines
	 of the	same priority get an equal share of the processor time. */
	listGET_OWNER_OF_NEXT_ENTRY( pxCurrentCoRoutine, &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) );
     426:	9c 01       	movw	r18, r24
     428:	22 0f       	add	r18, r18
     42a:	33 1f       	adc	r19, r19
     42c:	22 0f       	add	r18, r18
     42e:	33 1f       	adc	r19, r19
     430:	22 0f       	add	r18, r18
     432:	33 1f       	adc	r19, r19
     434:	28 0f       	add	r18, r24
     436:	39 1f       	adc	r19, r25
     438:	d9 01       	movw	r26, r18
     43a:	a2 56       	subi	r26, 0x62	; 98
     43c:	bf 4f       	sbci	r27, 0xFF	; 255
     43e:	11 96       	adiw	r26, 0x01	; 1
     440:	ed 91       	ld	r30, X+
     442:	fc 91       	ld	r31, X
     444:	12 97       	sbiw	r26, 0x02	; 2
     446:	02 80       	ldd	r0, Z+2	; 0x02
     448:	f3 81       	ldd	r31, Z+3	; 0x03
     44a:	e0 2d       	mov	r30, r0
     44c:	12 96       	adiw	r26, 0x02	; 2
     44e:	fc 93       	st	X, r31
     450:	ee 93       	st	-X, r30
     452:	11 97       	sbiw	r26, 0x01	; 1
     454:	2f 55       	subi	r18, 0x5F	; 95
     456:	3f 4f       	sbci	r19, 0xFF	; 255
     458:	e2 17       	cp	r30, r18
     45a:	f3 07       	cpc	r31, r19
     45c:	29 f4       	brne	.+10     	; 0x468 <vCoRoutineSchedule+0x246>
     45e:	22 81       	ldd	r18, Z+2	; 0x02
     460:	33 81       	ldd	r19, Z+3	; 0x03
     462:	fd 01       	movw	r30, r26
     464:	32 83       	std	Z+2, r19	; 0x02
     466:	21 83       	std	Z+1, r18	; 0x01
     468:	fc 01       	movw	r30, r24
     46a:	ee 0f       	add	r30, r30
     46c:	ff 1f       	adc	r31, r31
     46e:	ee 0f       	add	r30, r30
     470:	ff 1f       	adc	r31, r31
     472:	ee 0f       	add	r30, r30
     474:	ff 1f       	adc	r31, r31
     476:	8e 0f       	add	r24, r30
     478:	9f 1f       	adc	r25, r31
     47a:	fc 01       	movw	r30, r24
     47c:	e2 56       	subi	r30, 0x62	; 98
     47e:	ff 4f       	sbci	r31, 0xFF	; 255
     480:	01 80       	ldd	r0, Z+1	; 0x01
     482:	f2 81       	ldd	r31, Z+2	; 0x02
     484:	e0 2d       	mov	r30, r0
     486:	a6 81       	ldd	r26, Z+6	; 0x06
     488:	b7 81       	ldd	r27, Z+7	; 0x07
     48a:	b0 93 93 00 	sts	0x0093, r27
     48e:	a0 93 92 00 	sts	0x0092, r26

	/* Call the co-routine. */
	( pxCurrentCoRoutine->pxCoRoutineFunction )( pxCurrentCoRoutine, pxCurrentCoRoutine->uxIndex );
     492:	ed 91       	ld	r30, X+
     494:	fc 91       	ld	r31, X
     496:	11 97       	sbiw	r26, 0x01	; 1
     498:	cd 01       	movw	r24, r26
     49a:	57 96       	adiw	r26, 0x17	; 23
     49c:	6c 91       	ld	r22, X
     49e:	09 95       	icall

	return;
}
     4a0:	df 91       	pop	r29
     4a2:	cf 91       	pop	r28
     4a4:	1f 91       	pop	r17
     4a6:	0f 91       	pop	r16
     4a8:	ff 90       	pop	r15
     4aa:	ef 90       	pop	r14
     4ac:	df 90       	pop	r13
     4ae:	cf 90       	pop	r12
     4b0:	08 95       	ret

000004b2 <xCoRoutineRemoveFromEventList>:
	pxOverflowDelayedCoRoutineList = &xDelayedCoRoutineList2;
}
/*-----------------------------------------------------------*/

signed portBASE_TYPE xCoRoutineRemoveFromEventList( const xList *pxEventList )
{
     4b2:	0f 93       	push	r16
     4b4:	1f 93       	push	r17
     4b6:	cf 93       	push	r28
     4b8:	df 93       	push	r29
signed portBASE_TYPE xReturn;

	/* This function is called from within an interrupt.  It can only access
	event lists and the pending ready list.  This function assumes that a
	check has already been made to ensure pxEventList is not empty. */
	pxUnblockedCRCB = ( corCRCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
     4ba:	dc 01       	movw	r26, r24
     4bc:	15 96       	adiw	r26, 0x05	; 5
     4be:	ed 91       	ld	r30, X+
     4c0:	fc 91       	ld	r31, X
     4c2:	16 97       	sbiw	r26, 0x06	; 6
     4c4:	06 81       	ldd	r16, Z+6	; 0x06
     4c6:	17 81       	ldd	r17, Z+7	; 0x07
	vListRemove( &( pxUnblockedCRCB->xEventListItem ) );
     4c8:	e8 01       	movw	r28, r16
     4ca:	2c 96       	adiw	r28, 0x0c	; 12
     4cc:	ce 01       	movw	r24, r28
     4ce:	0e 94 c4 03 	call	0x788	; 0x788 <vListRemove>
	vListInsertEnd( ( xList * ) &( xPendingReadyCoRoutineList ), &( pxUnblockedCRCB->xEventListItem ) );
     4d2:	84 e9       	ldi	r24, 0x94	; 148
     4d4:	90 e0       	ldi	r25, 0x00	; 0
     4d6:	be 01       	movw	r22, r28
     4d8:	0e 94 5e 03 	call	0x6bc	; 0x6bc <vListInsertEnd>

	if( pxUnblockedCRCB->uxPriority >= pxCurrentCoRoutine->uxPriority )
     4dc:	e0 91 92 00 	lds	r30, 0x0092
     4e0:	f0 91 93 00 	lds	r31, 0x0093
	{
		xReturn = pdTRUE;
     4e4:	81 e0       	ldi	r24, 0x01	; 1
     4e6:	d8 01       	movw	r26, r16
     4e8:	56 96       	adiw	r26, 0x16	; 22
     4ea:	2c 91       	ld	r18, X
     4ec:	56 97       	sbiw	r26, 0x16	; 22
     4ee:	96 89       	ldd	r25, Z+22	; 0x16
     4f0:	29 17       	cp	r18, r25
     4f2:	08 f4       	brcc	.+2      	; 0x4f6 <xCoRoutineRemoveFromEventList+0x44>
     4f4:	80 e0       	ldi	r24, 0x00	; 0
	{
		xReturn = pdFALSE;
	}

	return xReturn;
}
     4f6:	df 91       	pop	r29
     4f8:	cf 91       	pop	r28
     4fa:	1f 91       	pop	r17
     4fc:	0f 91       	pop	r16
     4fe:	08 95       	ret

00000500 <pvPortMalloc>:

static size_t xNextFreeByte = ( size_t ) 0;
/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
     500:	ef 92       	push	r14
     502:	ff 92       	push	r15
     504:	0f 93       	push	r16
     506:	1f 93       	push	r17
     508:	cf 93       	push	r28
     50a:	df 93       	push	r29
     50c:	8c 01       	movw	r16, r24
			/* Byte alignment required. */
			xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
		}
	#endif

	vTaskSuspendAll();
     50e:	0e 94 ff 0a 	call	0x15fe	; 0x15fe <vTaskSuspendAll>
	{
		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configTOTAL_HEAP_SIZE ) &&
     512:	c0 91 cc 00 	lds	r28, 0x00CC
     516:	d0 91 cd 00 	lds	r29, 0x00CD
     51a:	0c 0f       	add	r16, r28
     51c:	1d 1f       	adc	r17, r29
     51e:	22 e0       	ldi	r18, 0x02	; 2
     520:	08 35       	cpi	r16, 0x58	; 88
     522:	12 07       	cpc	r17, r18
     524:	50 f4       	brcc	.+20     	; 0x53a <pvPortMalloc+0x3a>
     526:	c0 17       	cp	r28, r16
     528:	d1 07       	cpc	r29, r17
     52a:	50 f4       	brcc	.+20     	; 0x540 <pvPortMalloc+0x40>
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
		{
			/* Return the next free byte then increment the index past this
			block. */
			pvReturn = &( xHeap.ucHeap[ xNextFreeByte ] );
     52c:	c2 53       	subi	r28, 0x32	; 50
     52e:	df 4f       	sbci	r29, 0xFF	; 255
			xNextFreeByte += xWantedSize;			
     530:	10 93 cd 00 	sts	0x00CD, r17
     534:	00 93 cc 00 	sts	0x00CC, r16
     538:	05 c0       	rjmp	.+10     	; 0x544 <pvPortMalloc+0x44>
static size_t xNextFreeByte = ( size_t ) 0;
/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
void *pvReturn = NULL; 
     53a:	c0 e0       	ldi	r28, 0x00	; 0
     53c:	d0 e0       	ldi	r29, 0x00	; 0
     53e:	02 c0       	rjmp	.+4      	; 0x544 <pvPortMalloc+0x44>
     540:	c0 e0       	ldi	r28, 0x00	; 0
     542:	d0 e0       	ldi	r29, 0x00	; 0
			block. */
			pvReturn = &( xHeap.ucHeap[ xNextFreeByte ] );
			xNextFreeByte += xWantedSize;			
		}	
	}
	xTaskResumeAll();
     544:	0e 94 e1 0b 	call	0x17c2	; 0x17c2 <xTaskResumeAll>
		}
	}
	#endif	

	return pvReturn;
}
     548:	7e 01       	movw	r14, r28
     54a:	8c 2f       	mov	r24, r28
     54c:	9f 2d       	mov	r25, r15
     54e:	df 91       	pop	r29
     550:	cf 91       	pop	r28
     552:	1f 91       	pop	r17
     554:	0f 91       	pop	r16
     556:	ff 90       	pop	r15
     558:	ef 90       	pop	r14
     55a:	08 95       	ret

0000055c <vPortFree>:
{
	/* Memory cannot be freed using this scheme.  See heap_2.c and heap_3.c 
	for alternative implementations, and the memory management pages of 
	http://www.FreeRTOS.org for more information. */
	( void ) pv;
}
     55c:	08 95       	ret

0000055e <vPortInitialiseBlocks>:
/*-----------------------------------------------------------*/

void vPortInitialiseBlocks( void )
{
	/* Only required when static memory is not cleared. */
	xNextFreeByte = ( size_t ) 0;
     55e:	10 92 cd 00 	sts	0x00CD, r1
     562:	10 92 cc 00 	sts	0x00CC, r1
}
     566:	08 95       	ret

00000568 <xPortGetFreeHeapSize>:
/*-----------------------------------------------------------*/

size_t xPortGetFreeHeapSize( void )
{
	return ( configTOTAL_HEAP_SIZE - xNextFreeByte );
     568:	80 91 cc 00 	lds	r24, 0x00CC
     56c:	90 91 cd 00 	lds	r25, 0x00CD
     570:	28 e5       	ldi	r18, 0x58	; 88
     572:	32 e0       	ldi	r19, 0x02	; 2
     574:	28 1b       	sub	r18, r24
     576:	39 0b       	sbc	r19, r25
}
     578:	82 2f       	mov	r24, r18
     57a:	93 2f       	mov	r25, r19
     57c:	08 95       	ret

0000057e <enableTrigger>:
//   data changes.
////////////////////////////////////////////////////////////////////
void enableTrigger(void)
{

	CLR_BIT(PORTB,2);
     57e:	c2 98       	cbi	0x18, 2	; 24
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
     580:	89 ef       	ldi	r24, 0xF9	; 249
     582:	90 e0       	ldi	r25, 0x00	; 0
     584:	01 97       	sbiw	r24, 0x01	; 1
     586:	f1 f7       	brne	.-4      	; 0x584 <enableTrigger+0x6>
     588:	00 c0       	rjmp	.+0      	; 0x58a <enableTrigger+0xc>
     58a:	00 00       	nop
	
	_delay_ms(1);

	SET_BIT(PORTB,2);
     58c:	c2 9a       	sbi	0x18, 2	; 24
     58e:	8b ed       	ldi	r24, 0xDB	; 219
     590:	95 e0       	ldi	r25, 0x05	; 5
     592:	01 97       	sbiw	r24, 0x01	; 1
     594:	f1 f7       	brne	.-4      	; 0x592 <enableTrigger+0x14>
     596:	00 c0       	rjmp	.+0      	; 0x598 <enableTrigger+0x1a>
     598:	00 00       	nop
	_delay_ms(6);


}
     59a:	08 95       	ret

0000059c <lcd_sendCommand>:
		
}


void lcd_sendCommand(unsigned char cmd)
{
     59c:	1f 93       	push	r17
     59e:	18 2f       	mov	r17, r24
	unsigned char high_nibble , low_nibble ; 		
	
	HIGH_NIBBLE(high_nibble,cmd);
	LOW_NIBBLE(low_nibble,cmd);

	CLR_BIT(PORTB,0); // to enable command mode 
     5a0:	c0 98       	cbi	0x18, 0	; 24
	CLR_BIT(PORTB,1); // write signal to lcd 
     5a2:	c1 98       	cbi	0x18, 1	; 24

	PORTB &=0x0f;
     5a4:	88 b3       	in	r24, 0x18	; 24
     5a6:	8f 70       	andi	r24, 0x0F	; 15
     5a8:	88 bb       	out	0x18, r24	; 24
	PORTB |=high_nibble;// to send high nibble command  
     5aa:	88 b3       	in	r24, 0x18	; 24
void lcd_sendCommand(unsigned char cmd)
{

	unsigned char high_nibble , low_nibble ; 		
	
	HIGH_NIBBLE(high_nibble,cmd);
     5ac:	91 2f       	mov	r25, r17
     5ae:	90 7f       	andi	r25, 0xF0	; 240

	CLR_BIT(PORTB,0); // to enable command mode 
	CLR_BIT(PORTB,1); // write signal to lcd 

	PORTB &=0x0f;
	PORTB |=high_nibble;// to send high nibble command  
     5b0:	89 2b       	or	r24, r25
     5b2:	88 bb       	out	0x18, r24	; 24
	enableTrigger(); // triggre lcd enable 
     5b4:	0e 94 bf 02 	call	0x57e	; 0x57e <enableTrigger>

	PORTB &=0x0f;
     5b8:	88 b3       	in	r24, 0x18	; 24
     5ba:	8f 70       	andi	r24, 0x0F	; 15
     5bc:	88 bb       	out	0x18, r24	; 24
	PORTB |=low_nibble; // to send low nibble command 
     5be:	88 b3       	in	r24, 0x18	; 24
{

	unsigned char high_nibble , low_nibble ; 		
	
	HIGH_NIBBLE(high_nibble,cmd);
	LOW_NIBBLE(low_nibble,cmd);
     5c0:	12 95       	swap	r17
     5c2:	10 7f       	andi	r17, 0xF0	; 240
	PORTB &=0x0f;
	PORTB |=high_nibble;// to send high nibble command  
	enableTrigger(); // triggre lcd enable 

	PORTB &=0x0f;
	PORTB |=low_nibble; // to send low nibble command 
     5c4:	18 2b       	or	r17, r24
     5c6:	18 bb       	out	0x18, r17	; 24
	enableTrigger();
     5c8:	0e 94 bf 02 	call	0x57e	; 0x57e <enableTrigger>

}
     5cc:	1f 91       	pop	r17
     5ce:	08 95       	ret

000005d0 <lcd_init>:
//							 and pinB.0 to pinB.2 o/p for control pins 
//////////////////////////////////////////////////////////////////////////////////////
void lcd_init(void)
{

	DDRB=0xff; // init port B as O/P port 
     5d0:	8f ef       	ldi	r24, 0xFF	; 255
     5d2:	87 bb       	out	0x17, r24	; 23
	PORTB=0x04; // activate LCD enable 
     5d4:	84 e0       	ldi	r24, 0x04	; 4
     5d6:	88 bb       	out	0x18, r24	; 24

	lcd_sendCommand(0x33); // 4-bit mode 
     5d8:	83 e3       	ldi	r24, 0x33	; 51
     5da:	0e 94 ce 02 	call	0x59c	; 0x59c <lcd_sendCommand>
	lcd_sendCommand (0x32);
     5de:	82 e3       	ldi	r24, 0x32	; 50
     5e0:	0e 94 ce 02 	call	0x59c	; 0x59c <lcd_sendCommand>
	lcd_sendCommand (0x28);
     5e4:	88 e2       	ldi	r24, 0x28	; 40
     5e6:	0e 94 ce 02 	call	0x59c	; 0x59c <lcd_sendCommand>



	lcd_sendCommand(0x0c); // turn on lcd 
     5ea:	8c e0       	ldi	r24, 0x0C	; 12
     5ec:	0e 94 ce 02 	call	0x59c	; 0x59c <lcd_sendCommand>

		
}
     5f0:	08 95       	ret

000005f2 <lcd_displayChar>:
	enableTrigger();

}

void lcd_displayChar (unsigned char data)
{
     5f2:	1f 93       	push	r17
     5f4:	18 2f       	mov	r17, r24

	unsigned char high_nibble , low_nibble ;

	SET_BIT(PORTB,0); //  enable data mode 
     5f6:	c0 9a       	sbi	0x18, 0	; 24
	CLR_BIT(PORTB,1); // activate lcd write 
     5f8:	c1 98       	cbi	0x18, 1	; 24

	HIGH_NIBBLE(high_nibble,data); // get high nibble data 
	LOW_NIBBLE(low_nibble,data); // get low nibble data 
	
	PORTB &= 0x0f;
     5fa:	88 b3       	in	r24, 0x18	; 24
     5fc:	8f 70       	andi	r24, 0x0F	; 15
     5fe:	88 bb       	out	0x18, r24	; 24
	PORTB |=high_nibble;// to send high nibble data  
     600:	88 b3       	in	r24, 0x18	; 24
	unsigned char high_nibble , low_nibble ;

	SET_BIT(PORTB,0); //  enable data mode 
	CLR_BIT(PORTB,1); // activate lcd write 

	HIGH_NIBBLE(high_nibble,data); // get high nibble data 
     602:	91 2f       	mov	r25, r17
     604:	90 7f       	andi	r25, 0xF0	; 240
	LOW_NIBBLE(low_nibble,data); // get low nibble data 
	
	PORTB &= 0x0f;
	PORTB |=high_nibble;// to send high nibble data  
     606:	89 2b       	or	r24, r25
     608:	88 bb       	out	0x18, r24	; 24
	enableTrigger(); // triggre lcd enable 
     60a:	0e 94 bf 02 	call	0x57e	; 0x57e <enableTrigger>
	
	PORTB &=0x0f;
     60e:	88 b3       	in	r24, 0x18	; 24
     610:	8f 70       	andi	r24, 0x0F	; 15
     612:	88 bb       	out	0x18, r24	; 24
	PORTB |=low_nibble; // to send low nibble data 
     614:	88 b3       	in	r24, 0x18	; 24

	SET_BIT(PORTB,0); //  enable data mode 
	CLR_BIT(PORTB,1); // activate lcd write 

	HIGH_NIBBLE(high_nibble,data); // get high nibble data 
	LOW_NIBBLE(low_nibble,data); // get low nibble data 
     616:	12 95       	swap	r17
     618:	10 7f       	andi	r17, 0xF0	; 240
	PORTB &= 0x0f;
	PORTB |=high_nibble;// to send high nibble data  
	enableTrigger(); // triggre lcd enable 
	
	PORTB &=0x0f;
	PORTB |=low_nibble; // to send low nibble data 
     61a:	18 2b       	or	r17, r24
     61c:	18 bb       	out	0x18, r17	; 24
	enableTrigger();
     61e:	0e 94 bf 02 	call	0x57e	; 0x57e <enableTrigger>
	

}
     622:	1f 91       	pop	r17
     624:	08 95       	ret

00000626 <lcd_gotoxy>:

void lcd_gotoxy(unsigned char y , unsigned char x )
{
	unsigned char position = 0x80;
	 
	switch(y)
     626:	81 30       	cpi	r24, 0x01	; 1
     628:	51 f0       	breq	.+20     	; 0x63e <lcd_gotoxy+0x18>
     62a:	81 30       	cpi	r24, 0x01	; 1
     62c:	28 f0       	brcs	.+10     	; 0x638 <lcd_gotoxy+0x12>
     62e:	82 30       	cpi	r24, 0x02	; 2
     630:	49 f0       	breq	.+18     	; 0x644 <lcd_gotoxy+0x1e>
     632:	83 30       	cpi	r24, 0x03	; 3
     634:	69 f4       	brne	.+26     	; 0x650 <lcd_gotoxy+0x2a>
     636:	09 c0       	rjmp	.+18     	; 0x64a <lcd_gotoxy+0x24>
	{
		case 0:

			position=position+x;
     638:	86 2f       	mov	r24, r22
     63a:	80 58       	subi	r24, 0x80	; 128
					
		break;
     63c:	0a c0       	rjmp	.+20     	; 0x652 <lcd_gotoxy+0x2c>

		case 1:

			position=0xc0;
			position=position+x;
     63e:	86 2f       	mov	r24, r22
     640:	80 54       	subi	r24, 0x40	; 64

		break;
     642:	07 c0       	rjmp	.+14     	; 0x652 <lcd_gotoxy+0x2c>

		case 2:

			position=position+x;
     644:	86 2f       	mov	r24, r22
     646:	80 58       	subi	r24, 0x80	; 128

		break;
     648:	04 c0       	rjmp	.+8      	; 0x652 <lcd_gotoxy+0x2c>

		case 3:
			position=position+x;
     64a:	86 2f       	mov	r24, r22
     64c:	80 58       	subi	r24, 0x80	; 128
		break;
     64e:	01 c0       	rjmp	.+2      	; 0x652 <lcd_gotoxy+0x2c>
}


void lcd_gotoxy(unsigned char y , unsigned char x )
{
	unsigned char position = 0x80;
     650:	80 e8       	ldi	r24, 0x80	; 128
		break;
	
	
	}
	
	lcd_sendCommand(position); 	
     652:	0e 94 ce 02 	call	0x59c	; 0x59c <lcd_sendCommand>


}
     656:	08 95       	ret

00000658 <lcd_clrScreen>:


void lcd_clrScreen(void)
{

	lcd_sendCommand(0x01);
     658:	81 e0       	ldi	r24, 0x01	; 1
     65a:	0e 94 ce 02 	call	0x59c	; 0x59c <lcd_sendCommand>


}
     65e:	08 95       	ret

00000660 <lcd_dispString>:


void lcd_dispString(char * ptr)
{
     660:	cf 93       	push	r28
     662:	df 93       	push	r29
     664:	ec 01       	movw	r28, r24

	while(* ptr!= '\0')
     666:	88 81       	ld	r24, Y
     668:	88 23       	and	r24, r24
     66a:	31 f0       	breq	.+12     	; 0x678 <lcd_dispString+0x18>


}


void lcd_dispString(char * ptr)
     66c:	21 96       	adiw	r28, 0x01	; 1
{

	while(* ptr!= '\0')
	{
		lcd_displayChar(* ptr);
     66e:	0e 94 f9 02 	call	0x5f2	; 0x5f2 <lcd_displayChar>


void lcd_dispString(char * ptr)
{

	while(* ptr!= '\0')
     672:	89 91       	ld	r24, Y+
     674:	88 23       	and	r24, r24
     676:	d9 f7       	brne	.-10     	; 0x66e <lcd_dispString+0xe>
	
	}



}
     678:	df 91       	pop	r29
     67a:	cf 91       	pop	r28
     67c:	08 95       	ret

0000067e <lcd_disp_string_xy>:

void lcd_disp_string_xy(char * ptr , int y , int x)
{
     67e:	cf 93       	push	r28
     680:	df 93       	push	r29
     682:	ec 01       	movw	r28, r24
     684:	86 2f       	mov	r24, r22

	lcd_gotoxy(y,x);
     686:	64 2f       	mov	r22, r20
     688:	0e 94 13 03 	call	0x626	; 0x626 <lcd_gotoxy>
	lcd_dispString(ptr);
     68c:	ce 01       	movw	r24, r28
     68e:	0e 94 30 03 	call	0x660	; 0x660 <lcd_dispString>

	


}
     692:	df 91       	pop	r29
     694:	cf 91       	pop	r28
     696:	08 95       	ret

00000698 <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( xList *pxList )
{
     698:	fc 01       	movw	r30, r24
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( xListItem * ) &( pxList->xListEnd );
     69a:	03 96       	adiw	r24, 0x03	; 3
     69c:	92 83       	std	Z+2, r25	; 0x02
     69e:	81 83       	std	Z+1, r24	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
     6a0:	2f ef       	ldi	r18, 0xFF	; 255
     6a2:	3f ef       	ldi	r19, 0xFF	; 255
     6a4:	34 83       	std	Z+4, r19	; 0x04
     6a6:	23 83       	std	Z+3, r18	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( xListItem * ) &( pxList->xListEnd );
     6a8:	96 83       	std	Z+6, r25	; 0x06
     6aa:	85 83       	std	Z+5, r24	; 0x05
	pxList->xListEnd.pxPrevious = ( xListItem * ) &( pxList->xListEnd );
     6ac:	90 87       	std	Z+8, r25	; 0x08
     6ae:	87 83       	std	Z+7, r24	; 0x07

	pxList->uxNumberOfItems = ( unsigned portBASE_TYPE ) 0U;
     6b0:	10 82       	st	Z, r1
}
     6b2:	08 95       	ret

000006b4 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( xListItem *pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
     6b4:	fc 01       	movw	r30, r24
     6b6:	11 86       	std	Z+9, r1	; 0x09
     6b8:	10 86       	std	Z+8, r1	; 0x08
}
     6ba:	08 95       	ret

000006bc <vListInsertEnd>:
/*-----------------------------------------------------------*/

void vListInsertEnd( xList *pxList, xListItem *pxNewListItem )
{
     6bc:	cf 93       	push	r28
     6be:	df 93       	push	r29
     6c0:	fc 01       	movw	r30, r24
     6c2:	db 01       	movw	r26, r22

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	pvListGetOwnerOfNextEntry.  This means it has to be the item pointed to by
	the pxIndex member. */
	pxIndex = pxList->pxIndex;
     6c4:	21 81       	ldd	r18, Z+1	; 0x01
     6c6:	32 81       	ldd	r19, Z+2	; 0x02

	pxNewListItem->pxNext = pxIndex->pxNext;
     6c8:	e9 01       	movw	r28, r18
     6ca:	8a 81       	ldd	r24, Y+2	; 0x02
     6cc:	9b 81       	ldd	r25, Y+3	; 0x03
     6ce:	13 96       	adiw	r26, 0x03	; 3
     6d0:	9c 93       	st	X, r25
     6d2:	8e 93       	st	-X, r24
     6d4:	12 97       	sbiw	r26, 0x02	; 2
	pxNewListItem->pxPrevious = pxList->pxIndex;
     6d6:	81 81       	ldd	r24, Z+1	; 0x01
     6d8:	92 81       	ldd	r25, Z+2	; 0x02
     6da:	15 96       	adiw	r26, 0x05	; 5
     6dc:	9c 93       	st	X, r25
     6de:	8e 93       	st	-X, r24
     6e0:	14 97       	sbiw	r26, 0x04	; 4
	pxIndex->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
     6e2:	8a 81       	ldd	r24, Y+2	; 0x02
     6e4:	9b 81       	ldd	r25, Y+3	; 0x03
     6e6:	ec 01       	movw	r28, r24
     6e8:	7d 83       	std	Y+5, r23	; 0x05
     6ea:	6c 83       	std	Y+4, r22	; 0x04
	pxIndex->pxNext = ( volatile xListItem * ) pxNewListItem;
     6ec:	e9 01       	movw	r28, r18
     6ee:	7b 83       	std	Y+3, r23	; 0x03
     6f0:	6a 83       	std	Y+2, r22	; 0x02
	pxList->pxIndex = ( volatile xListItem * ) pxNewListItem;
     6f2:	72 83       	std	Z+2, r23	; 0x02
     6f4:	61 83       	std	Z+1, r22	; 0x01

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     6f6:	19 96       	adiw	r26, 0x09	; 9
     6f8:	fc 93       	st	X, r31
     6fa:	ee 93       	st	-X, r30
     6fc:	18 97       	sbiw	r26, 0x08	; 8

	( pxList->uxNumberOfItems )++;
     6fe:	80 81       	ld	r24, Z
     700:	8f 5f       	subi	r24, 0xFF	; 255
     702:	80 83       	st	Z, r24
}
     704:	df 91       	pop	r29
     706:	cf 91       	pop	r28
     708:	08 95       	ret

0000070a <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( xList *pxList, xListItem *pxNewListItem )
{
     70a:	cf 93       	push	r28
     70c:	df 93       	push	r29
     70e:	fc 01       	movw	r30, r24
volatile xListItem *pxIterator;
portTickType xValueOfInsertion;

	/* Insert the new list item into the list, sorted in ulListItem order. */
	xValueOfInsertion = pxNewListItem->xItemValue;
     710:	db 01       	movw	r26, r22
     712:	2d 91       	ld	r18, X+
     714:	3c 91       	ld	r19, X
     716:	11 97       	sbiw	r26, 0x01	; 1
	are stored in ready lists (all of which have the same ulListItem value)
	get an equal share of the CPU.  However, if the xItemValue is the same as
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
     718:	bf ef       	ldi	r27, 0xFF	; 255
     71a:	2f 3f       	cpi	r18, 0xFF	; 255
     71c:	3b 07       	cpc	r19, r27
     71e:	19 f4       	brne	.+6      	; 0x726 <vListInsert+0x1c>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
     720:	a7 81       	ldd	r26, Z+7	; 0x07
     722:	b0 85       	ldd	r27, Z+8	; 0x08
     724:	18 c0       	rjmp	.+48     	; 0x756 <vListInsert+0x4c>
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		See http://www.freertos.org/FAQHelp.html for more tips.
		**********************************************************************/
		
		for( pxIterator = ( xListItem * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext )
     726:	dc 01       	movw	r26, r24
     728:	13 96       	adiw	r26, 0x03	; 3
     72a:	12 96       	adiw	r26, 0x02	; 2
     72c:	cd 91       	ld	r28, X+
     72e:	dc 91       	ld	r29, X
     730:	13 97       	sbiw	r26, 0x03	; 3
     732:	88 81       	ld	r24, Y
     734:	99 81       	ldd	r25, Y+1	; 0x01
     736:	28 17       	cp	r18, r24
     738:	39 07       	cpc	r19, r25
     73a:	68 f0       	brcs	.+26     	; 0x756 <vListInsert+0x4c>
     73c:	12 96       	adiw	r26, 0x02	; 2
     73e:	0d 90       	ld	r0, X+
     740:	bc 91       	ld	r27, X
     742:	a0 2d       	mov	r26, r0
     744:	12 96       	adiw	r26, 0x02	; 2
     746:	cd 91       	ld	r28, X+
     748:	dc 91       	ld	r29, X
     74a:	13 97       	sbiw	r26, 0x03	; 3
     74c:	88 81       	ld	r24, Y
     74e:	99 81       	ldd	r25, Y+1	; 0x01
     750:	28 17       	cp	r18, r24
     752:	39 07       	cpc	r19, r25
     754:	98 f7       	brcc	.-26     	; 0x73c <vListInsert+0x32>
			/* There is nothing to do here, we are just iterating to the
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
     756:	12 96       	adiw	r26, 0x02	; 2
     758:	8d 91       	ld	r24, X+
     75a:	9c 91       	ld	r25, X
     75c:	13 97       	sbiw	r26, 0x03	; 3
     75e:	eb 01       	movw	r28, r22
     760:	9b 83       	std	Y+3, r25	; 0x03
     762:	8a 83       	std	Y+2, r24	; 0x02
	pxNewListItem->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
     764:	ec 01       	movw	r28, r24
     766:	7d 83       	std	Y+5, r23	; 0x05
     768:	6c 83       	std	Y+4, r22	; 0x04
	pxNewListItem->pxPrevious = pxIterator;
     76a:	eb 01       	movw	r28, r22
     76c:	bd 83       	std	Y+5, r27	; 0x05
     76e:	ac 83       	std	Y+4, r26	; 0x04
	pxIterator->pxNext = ( volatile xListItem * ) pxNewListItem;
     770:	13 96       	adiw	r26, 0x03	; 3
     772:	7c 93       	st	X, r23
     774:	6e 93       	st	-X, r22
     776:	12 97       	sbiw	r26, 0x02	; 2

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     778:	f9 87       	std	Y+9, r31	; 0x09
     77a:	e8 87       	std	Y+8, r30	; 0x08

	( pxList->uxNumberOfItems )++;
     77c:	80 81       	ld	r24, Z
     77e:	8f 5f       	subi	r24, 0xFF	; 255
     780:	80 83       	st	Z, r24
}
     782:	df 91       	pop	r29
     784:	cf 91       	pop	r28
     786:	08 95       	ret

00000788 <vListRemove>:
/*-----------------------------------------------------------*/

void vListRemove( xListItem *pxItemToRemove )
{
     788:	fc 01       	movw	r30, r24
xList * pxList;

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
     78a:	a2 81       	ldd	r26, Z+2	; 0x02
     78c:	b3 81       	ldd	r27, Z+3	; 0x03
     78e:	84 81       	ldd	r24, Z+4	; 0x04
     790:	95 81       	ldd	r25, Z+5	; 0x05
     792:	15 96       	adiw	r26, 0x05	; 5
     794:	9c 93       	st	X, r25
     796:	8e 93       	st	-X, r24
     798:	14 97       	sbiw	r26, 0x04	; 4
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
     79a:	a4 81       	ldd	r26, Z+4	; 0x04
     79c:	b5 81       	ldd	r27, Z+5	; 0x05
     79e:	82 81       	ldd	r24, Z+2	; 0x02
     7a0:	93 81       	ldd	r25, Z+3	; 0x03
     7a2:	13 96       	adiw	r26, 0x03	; 3
     7a4:	9c 93       	st	X, r25
     7a6:	8e 93       	st	-X, r24
     7a8:	12 97       	sbiw	r26, 0x02	; 2
	
	/* The list item knows which list it is in.  Obtain the list from the list
	item. */
	pxList = ( xList * ) pxItemToRemove->pvContainer;
     7aa:	a0 85       	ldd	r26, Z+8	; 0x08
     7ac:	b1 85       	ldd	r27, Z+9	; 0x09

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
     7ae:	11 96       	adiw	r26, 0x01	; 1
     7b0:	8d 91       	ld	r24, X+
     7b2:	9c 91       	ld	r25, X
     7b4:	12 97       	sbiw	r26, 0x02	; 2
     7b6:	8e 17       	cp	r24, r30
     7b8:	9f 07       	cpc	r25, r31
     7ba:	31 f4       	brne	.+12     	; 0x7c8 <vListRemove+0x40>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
     7bc:	84 81       	ldd	r24, Z+4	; 0x04
     7be:	95 81       	ldd	r25, Z+5	; 0x05
     7c0:	12 96       	adiw	r26, 0x02	; 2
     7c2:	9c 93       	st	X, r25
     7c4:	8e 93       	st	-X, r24
     7c6:	11 97       	sbiw	r26, 0x01	; 1
	}

	pxItemToRemove->pvContainer = NULL;
     7c8:	11 86       	std	Z+9, r1	; 0x09
     7ca:	10 86       	std	Z+8, r1	; 0x08
	( pxList->uxNumberOfItems )--;
     7cc:	8c 91       	ld	r24, X
     7ce:	81 50       	subi	r24, 0x01	; 1
     7d0:	8c 93       	st	X, r24
}
     7d2:	08 95       	ret

000007d4 <keypad_init>:
/****************************keypad initialization**************************/

void keypad_init(void){


	DDRA=0xf0; // set port A (a0 to a3 as input ) (a4 to a7 as output )
     7d4:	80 ef       	ldi	r24, 0xF0	; 240
     7d6:	8a bb       	out	0x1a, r24	; 26
	PORTA=0xff; // activate pull-up resistors from a0 to a3 and out a4 to a7 '1'
     7d8:	8f ef       	ldi	r24, 0xFF	; 255
     7da:	8b bb       	out	0x1b, r24	; 27


}
     7dc:	08 95       	ret

000007de <getPressed>:

unsigned char getPressed(void){
	
	for(column_index=0;column_index<4;column_index++)
     7de:	10 92 70 03 	sts	0x0370, r1
     7e2:	20 e0       	ldi	r18, 0x00	; 0
	{
		CLR_BIT(PORTA,(column_index+4)); // activate  column
     7e4:	81 e0       	ldi	r24, 0x01	; 1
     7e6:	90 e0       	ldi	r25, 0x00	; 0
     7e8:	4b b3       	in	r20, 0x1b	; 27
     7ea:	30 e0       	ldi	r19, 0x00	; 0
     7ec:	2c 5f       	subi	r18, 0xFC	; 252
     7ee:	3f 4f       	sbci	r19, 0xFF	; 255
     7f0:	bc 01       	movw	r22, r24
     7f2:	02 c0       	rjmp	.+4      	; 0x7f8 <getPressed+0x1a>
     7f4:	66 0f       	add	r22, r22
     7f6:	77 1f       	adc	r23, r23
     7f8:	2a 95       	dec	r18
     7fa:	e2 f7       	brpl	.-8      	; 0x7f4 <getPressed+0x16>
     7fc:	9b 01       	movw	r18, r22
     7fe:	20 95       	com	r18
     800:	24 23       	and	r18, r20
     802:	2b bb       	out	0x1b, r18	; 27
     804:	e3 ec       	ldi	r30, 0xC3	; 195
     806:	f9 e0       	ldi	r31, 0x09	; 9
     808:	31 97       	sbiw	r30, 0x01	; 1
     80a:	f1 f7       	brne	.-4      	; 0x808 <getPressed+0x2a>
     80c:	00 c0       	rjmp	.+0      	; 0x80e <getPressed+0x30>
     80e:	00 00       	nop
		// check if any key is pressed 
		
	
		
				
		if((PINA & 0x0f ) != 0x0f)
     810:	29 b3       	in	r18, 0x19	; 25
     812:	2f 70       	andi	r18, 0x0F	; 15
     814:	2f 30       	cpi	r18, 0x0F	; 15
     816:	49 f0       	breq	.+18     	; 0x82a <getPressed+0x4c>
		{
			 
			row_val=PINA &0x0F;
     818:	89 b3       	in	r24, 0x19	; 25
     81a:	8f 70       	andi	r24, 0x0F	; 15
     81c:	80 93 61 00 	sts	0x0061, r24
		
			while((PINA & 0x0f) != 0x0f ); //  single press logic 
     820:	89 b3       	in	r24, 0x19	; 25
     822:	8f 70       	andi	r24, 0x0F	; 15
     824:	8f 30       	cpi	r24, 0x0F	; 15
     826:	e1 f7       	brne	.-8      	; 0x820 <getPressed+0x42>
     828:	14 c0       	rjmp	.+40     	; 0x852 <getPressed+0x74>
			//SET_BIT(PORTA,(column_index+4)); 
			break;
		
		}	 	
		
		SET_BIT(PORTA,(column_index+4)); // deactivate selected column	
     82a:	3b b3       	in	r19, 0x1b	; 27
     82c:	20 91 70 03 	lds	r18, 0x0370
     830:	62 2f       	mov	r22, r18
     832:	70 e0       	ldi	r23, 0x00	; 0
     834:	6c 5f       	subi	r22, 0xFC	; 252
     836:	7f 4f       	sbci	r23, 0xFF	; 255
     838:	ac 01       	movw	r20, r24
     83a:	02 c0       	rjmp	.+4      	; 0x840 <getPressed+0x62>
     83c:	44 0f       	add	r20, r20
     83e:	55 1f       	adc	r21, r21
     840:	6a 95       	dec	r22
     842:	e2 f7       	brpl	.-8      	; 0x83c <getPressed+0x5e>
     844:	43 2b       	or	r20, r19
     846:	4b bb       	out	0x1b, r20	; 27

}

unsigned char getPressed(void){
	
	for(column_index=0;column_index<4;column_index++)
     848:	2f 5f       	subi	r18, 0xFF	; 255
     84a:	20 93 70 03 	sts	0x0370, r18
     84e:	24 30       	cpi	r18, 0x04	; 4
     850:	58 f2       	brcs	.-106    	; 0x7e8 <getPressed+0xa>
		
		SET_BIT(PORTA,(column_index+4)); // deactivate selected column	

	}
	
	switch (row_val)
     852:	80 91 61 00 	lds	r24, 0x0061
     856:	8b 30       	cpi	r24, 0x0B	; 11
     858:	81 f0       	breq	.+32     	; 0x87a <__stack+0x1b>
     85a:	8c 30       	cpi	r24, 0x0C	; 12
     85c:	18 f4       	brcc	.+6      	; 0x864 <__stack+0x5>
     85e:	87 30       	cpi	r24, 0x07	; 7
     860:	99 f4       	brne	.+38     	; 0x888 <__stack+0x29>
     862:	0f c0       	rjmp	.+30     	; 0x882 <__stack+0x23>
     864:	8d 30       	cpi	r24, 0x0D	; 13
     866:	29 f0       	breq	.+10     	; 0x872 <__stack+0x13>
     868:	8e 30       	cpi	r24, 0x0E	; 14
     86a:	71 f4       	brne	.+28     	; 0x888 <__stack+0x29>
	{
	
		case FIRST_ROW:
			row_index=0;
     86c:	10 92 6f 03 	sts	0x036F, r1

		break;
     870:	0b c0       	rjmp	.+22     	; 0x888 <__stack+0x29>

		case SECOND_ROW:
			row_index=1; 
     872:	81 e0       	ldi	r24, 0x01	; 1
     874:	80 93 6f 03 	sts	0x036F, r24

		break;
     878:	07 c0       	rjmp	.+14     	; 0x888 <__stack+0x29>

		case THIRD_ROW:
			row_index=2;
     87a:	82 e0       	ldi	r24, 0x02	; 2
     87c:	80 93 6f 03 	sts	0x036F, r24

		break;
     880:	03 c0       	rjmp	.+6      	; 0x888 <__stack+0x29>

		case FOURTH_ROW:
			row_index=3;
     882:	83 e0       	ldi	r24, 0x03	; 3
     884:	80 93 6f 03 	sts	0x036F, r24
		break;
		

	}
	
	if(row_val==NOT_PRESSED) 
     888:	80 91 61 00 	lds	r24, 0x0061
     88c:	8f 3f       	cpi	r24, 0xFF	; 255
     88e:	19 f4       	brne	.+6      	; 0x896 <__stack+0x37>
	{
		return_val=NOT_PRESSED;
     890:	80 93 60 00 	sts	0x0060, r24
     894:	13 c0       	rjmp	.+38     	; 0x8bc <__stack+0x5d>
	}
	else
	{
		return_val= keys_matrix[row_index][column_index]; // get value of key from keys matrix
     896:	e0 91 6f 03 	lds	r30, 0x036F
     89a:	f0 e0       	ldi	r31, 0x00	; 0
     89c:	80 91 70 03 	lds	r24, 0x0370
     8a0:	ee 0f       	add	r30, r30
     8a2:	ff 1f       	adc	r31, r31
     8a4:	ee 0f       	add	r30, r30
     8a6:	ff 1f       	adc	r31, r31
     8a8:	e8 0f       	add	r30, r24
     8aa:	f1 1d       	adc	r31, r1
     8ac:	ee 59       	subi	r30, 0x9E	; 158
     8ae:	ff 4f       	sbci	r31, 0xFF	; 255
     8b0:	80 81       	ld	r24, Z
     8b2:	80 93 60 00 	sts	0x0060, r24
		
		row_val=NOT_PRESSED; 
     8b6:	8f ef       	ldi	r24, 0xFF	; 255
     8b8:	80 93 61 00 	sts	0x0061, r24
	}
	
	return return_val;
}
     8bc:	80 91 60 00 	lds	r24, 0x0060
     8c0:	08 95       	ret

000008c2 <pxPortInitialiseStack>:
unsigned short usAddress;

	/* Place a few bytes of known values on the bottom of the stack. 
	This is just useful for debugging. */

	*pxTopOfStack = 0x11;
     8c2:	21 e1       	ldi	r18, 0x11	; 17
     8c4:	fc 01       	movw	r30, r24
     8c6:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = 0x22;
     8c8:	92 e2       	ldi	r25, 0x22	; 34
     8ca:	92 93       	st	-Z, r25
	pxTopOfStack--;
	*pxTopOfStack = 0x33;
     8cc:	83 e3       	ldi	r24, 0x33	; 51
     8ce:	82 93       	st	-Z, r24
	/*lint -e950 -e611 -e923 Lint doesn't like this much - but nothing I can do about it. */

	/* The start of the task code will be popped off the stack last, so place
	it on first. */
	usAddress = ( unsigned short ) pxCode;
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned short ) 0x00ff );
     8d0:	62 93       	st	-Z, r22
	pxTopOfStack--;

	usAddress >>= 8;
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned short ) 0x00ff );
     8d2:	72 93       	st	-Z, r23

	/* Next simulate the stack as if after a call to portSAVE_CONTEXT().  
	portSAVE_CONTEXT places the flags on the stack immediately after r0
	to ensure the interrupts get disabled as soon as possible, and so ensuring
	the stack use is minimal should a context switch interrupt occur. */
	*pxTopOfStack = ( portSTACK_TYPE ) 0x00;	/* R0 */
     8d4:	12 92       	st	-Z, r1
	pxTopOfStack--;
	*pxTopOfStack = portFLAGS_INT_ENABLED;
     8d6:	80 e8       	ldi	r24, 0x80	; 128
     8d8:	82 93       	st	-Z, r24
	pxTopOfStack--;


	/* Now the remaining registers.   The compiler expects R1 to be 0. */
	*pxTopOfStack = ( portSTACK_TYPE ) 0x00;	/* R1 */
     8da:	12 92       	st	-Z, r1
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x02;	/* R2 */
     8dc:	82 e0       	ldi	r24, 0x02	; 2
     8de:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x03;	/* R3 */
     8e0:	83 e0       	ldi	r24, 0x03	; 3
     8e2:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x04;	/* R4 */
     8e4:	84 e0       	ldi	r24, 0x04	; 4
     8e6:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x05;	/* R5 */
     8e8:	85 e0       	ldi	r24, 0x05	; 5
     8ea:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x06;	/* R6 */
     8ec:	86 e0       	ldi	r24, 0x06	; 6
     8ee:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x07;	/* R7 */
     8f0:	87 e0       	ldi	r24, 0x07	; 7
     8f2:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x08;	/* R8 */
     8f4:	88 e0       	ldi	r24, 0x08	; 8
     8f6:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x09;	/* R9 */
     8f8:	89 e0       	ldi	r24, 0x09	; 9
     8fa:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x10;	/* R10 */
     8fc:	80 e1       	ldi	r24, 0x10	; 16
     8fe:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x11;	/* R11 */
     900:	22 93       	st	-Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x12;	/* R12 */
     902:	82 e1       	ldi	r24, 0x12	; 18
     904:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x13;	/* R13 */
     906:	83 e1       	ldi	r24, 0x13	; 19
     908:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x14;	/* R14 */
     90a:	84 e1       	ldi	r24, 0x14	; 20
     90c:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x15;	/* R15 */
     90e:	85 e1       	ldi	r24, 0x15	; 21
     910:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x16;	/* R16 */
     912:	86 e1       	ldi	r24, 0x16	; 22
     914:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x17;	/* R17 */
     916:	87 e1       	ldi	r24, 0x17	; 23
     918:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x18;	/* R18 */
     91a:	88 e1       	ldi	r24, 0x18	; 24
     91c:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x19;	/* R19 */
     91e:	89 e1       	ldi	r24, 0x19	; 25
     920:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x20;	/* R20 */
     922:	80 e2       	ldi	r24, 0x20	; 32
     924:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x21;	/* R21 */
     926:	81 e2       	ldi	r24, 0x21	; 33
     928:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x22;	/* R22 */
     92a:	92 93       	st	-Z, r25
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x23;	/* R23 */
     92c:	83 e2       	ldi	r24, 0x23	; 35
     92e:	82 93       	st	-Z, r24
	pxTopOfStack--;

	/* Place the parameter on the stack in the expected location. */
	usAddress = ( unsigned short ) pvParameters;
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned short ) 0x00ff );
     930:	42 93       	st	-Z, r20
	pxTopOfStack--;

	usAddress >>= 8;
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned short ) 0x00ff );
     932:	52 93       	st	-Z, r21
	pxTopOfStack--;

	*pxTopOfStack = ( portSTACK_TYPE ) 0x26;	/* R26 X */
     934:	86 e2       	ldi	r24, 0x26	; 38
     936:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x27;	/* R27 */
     938:	87 e2       	ldi	r24, 0x27	; 39
     93a:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x28;	/* R28 Y */
     93c:	88 e2       	ldi	r24, 0x28	; 40
     93e:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x29;	/* R29 */
     940:	89 e2       	ldi	r24, 0x29	; 41
     942:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x30;	/* R30 Z */
     944:	80 e3       	ldi	r24, 0x30	; 48
     946:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x031;	/* R31 */
     948:	81 e3       	ldi	r24, 0x31	; 49
     94a:	82 93       	st	-Z, r24
	pxTopOfStack--;
     94c:	9f 01       	movw	r18, r30
     94e:	21 50       	subi	r18, 0x01	; 1
     950:	30 40       	sbci	r19, 0x00	; 0

	/*lint +e950 +e611 +e923 */

	return pxTopOfStack;
}
     952:	82 2f       	mov	r24, r18
     954:	93 2f       	mov	r25, r19
     956:	08 95       	ret

00000958 <xPortStartScheduler>:
	/* Setup compare match value for compare match A.  Interrupts are disabled 
	before this is called so we need not worry here. */
	ucLowByte = ( unsigned char ) ( ulCompareMatch & ( unsigned long ) 0xff );
	ulCompareMatch >>= 8;
	ucHighByte = ( unsigned char ) ( ulCompareMatch & ( unsigned long ) 0xff );
	OCR1AH = ucHighByte;
     958:	1b bc       	out	0x2b, r1	; 43
	OCR1AL = ucLowByte;
     95a:	8c e7       	ldi	r24, 0x7C	; 124
     95c:	8a bd       	out	0x2a, r24	; 42

	/* Setup clock source and compare match behaviour. */
	ucLowByte = portCLEAR_COUNTER_ON_MATCH | portPRESCALE_64;
	TCCR1B = ucLowByte;
     95e:	8b e0       	ldi	r24, 0x0B	; 11
     960:	8e bd       	out	0x2e, r24	; 46

	/* Enable the interrupt - this is okay as interrupt are currently globally
	disabled. */
	ucLowByte = TIMSK;
     962:	89 b7       	in	r24, 0x39	; 57
	ucLowByte |= portCOMPARE_MATCH_A_INTERRUPT_ENABLE;
     964:	80 61       	ori	r24, 0x10	; 16
	TIMSK = ucLowByte;
     966:	89 bf       	out	0x39, r24	; 57
{
	/* Setup the hardware to generate the tick. */
	prvSetupTimerInterrupt();

	/* Restore the context of the first task that is going to run. */
	portRESTORE_CONTEXT();
     968:	a0 91 27 03 	lds	r26, 0x0327
     96c:	b0 91 28 03 	lds	r27, 0x0328
     970:	cd 91       	ld	r28, X+
     972:	cd bf       	out	0x3d, r28	; 61
     974:	dd 91       	ld	r29, X+
     976:	de bf       	out	0x3e, r29	; 62
     978:	ff 91       	pop	r31
     97a:	ef 91       	pop	r30
     97c:	df 91       	pop	r29
     97e:	cf 91       	pop	r28
     980:	bf 91       	pop	r27
     982:	af 91       	pop	r26
     984:	9f 91       	pop	r25
     986:	8f 91       	pop	r24
     988:	7f 91       	pop	r23
     98a:	6f 91       	pop	r22
     98c:	5f 91       	pop	r21
     98e:	4f 91       	pop	r20
     990:	3f 91       	pop	r19
     992:	2f 91       	pop	r18
     994:	1f 91       	pop	r17
     996:	0f 91       	pop	r16
     998:	ff 90       	pop	r15
     99a:	ef 90       	pop	r14
     99c:	df 90       	pop	r13
     99e:	cf 90       	pop	r12
     9a0:	bf 90       	pop	r11
     9a2:	af 90       	pop	r10
     9a4:	9f 90       	pop	r9
     9a6:	8f 90       	pop	r8
     9a8:	7f 90       	pop	r7
     9aa:	6f 90       	pop	r6
     9ac:	5f 90       	pop	r5
     9ae:	4f 90       	pop	r4
     9b0:	3f 90       	pop	r3
     9b2:	2f 90       	pop	r2
     9b4:	1f 90       	pop	r1
     9b6:	0f 90       	pop	r0
     9b8:	0f be       	out	0x3f, r0	; 63
     9ba:	0f 90       	pop	r0

	/* Simulate a function call end as generated by the compiler.  We will now
	jump to the start of the task the context of which we have just restored. */
	asm volatile ( "ret" );
     9bc:	08 95       	ret

	/* Should not get here. */
	return pdTRUE;
}
     9be:	81 e0       	ldi	r24, 0x01	; 1
     9c0:	08 95       	ret

000009c2 <vPortEndScheduler>:

void vPortEndScheduler( void )
{
	/* It is unlikely that the AVR port will get stopped.  If required simply
	disable the tick interrupt here. */
}
     9c2:	08 95       	ret

000009c4 <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
     9c4:	0f 92       	push	r0
     9c6:	0f b6       	in	r0, 0x3f	; 63
     9c8:	f8 94       	cli
     9ca:	0f 92       	push	r0
     9cc:	1f 92       	push	r1
     9ce:	11 24       	eor	r1, r1
     9d0:	2f 92       	push	r2
     9d2:	3f 92       	push	r3
     9d4:	4f 92       	push	r4
     9d6:	5f 92       	push	r5
     9d8:	6f 92       	push	r6
     9da:	7f 92       	push	r7
     9dc:	8f 92       	push	r8
     9de:	9f 92       	push	r9
     9e0:	af 92       	push	r10
     9e2:	bf 92       	push	r11
     9e4:	cf 92       	push	r12
     9e6:	df 92       	push	r13
     9e8:	ef 92       	push	r14
     9ea:	ff 92       	push	r15
     9ec:	0f 93       	push	r16
     9ee:	1f 93       	push	r17
     9f0:	2f 93       	push	r18
     9f2:	3f 93       	push	r19
     9f4:	4f 93       	push	r20
     9f6:	5f 93       	push	r21
     9f8:	6f 93       	push	r22
     9fa:	7f 93       	push	r23
     9fc:	8f 93       	push	r24
     9fe:	9f 93       	push	r25
     a00:	af 93       	push	r26
     a02:	bf 93       	push	r27
     a04:	cf 93       	push	r28
     a06:	df 93       	push	r29
     a08:	ef 93       	push	r30
     a0a:	ff 93       	push	r31
     a0c:	a0 91 27 03 	lds	r26, 0x0327
     a10:	b0 91 28 03 	lds	r27, 0x0328
     a14:	0d b6       	in	r0, 0x3d	; 61
     a16:	0d 92       	st	X+, r0
     a18:	0e b6       	in	r0, 0x3e	; 62
     a1a:	0d 92       	st	X+, r0
	vTaskSwitchContext();
     a1c:	0e 94 1a 0d 	call	0x1a34	; 0x1a34 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
     a20:	a0 91 27 03 	lds	r26, 0x0327
     a24:	b0 91 28 03 	lds	r27, 0x0328
     a28:	cd 91       	ld	r28, X+
     a2a:	cd bf       	out	0x3d, r28	; 61
     a2c:	dd 91       	ld	r29, X+
     a2e:	de bf       	out	0x3e, r29	; 62
     a30:	ff 91       	pop	r31
     a32:	ef 91       	pop	r30
     a34:	df 91       	pop	r29
     a36:	cf 91       	pop	r28
     a38:	bf 91       	pop	r27
     a3a:	af 91       	pop	r26
     a3c:	9f 91       	pop	r25
     a3e:	8f 91       	pop	r24
     a40:	7f 91       	pop	r23
     a42:	6f 91       	pop	r22
     a44:	5f 91       	pop	r21
     a46:	4f 91       	pop	r20
     a48:	3f 91       	pop	r19
     a4a:	2f 91       	pop	r18
     a4c:	1f 91       	pop	r17
     a4e:	0f 91       	pop	r16
     a50:	ff 90       	pop	r15
     a52:	ef 90       	pop	r14
     a54:	df 90       	pop	r13
     a56:	cf 90       	pop	r12
     a58:	bf 90       	pop	r11
     a5a:	af 90       	pop	r10
     a5c:	9f 90       	pop	r9
     a5e:	8f 90       	pop	r8
     a60:	7f 90       	pop	r7
     a62:	6f 90       	pop	r6
     a64:	5f 90       	pop	r5
     a66:	4f 90       	pop	r4
     a68:	3f 90       	pop	r3
     a6a:	2f 90       	pop	r2
     a6c:	1f 90       	pop	r1
     a6e:	0f 90       	pop	r0
     a70:	0f be       	out	0x3f, r0	; 63
     a72:	0f 90       	pop	r0

	asm volatile ( "ret" );
     a74:	08 95       	ret

00000a76 <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
     a76:	0f 92       	push	r0
     a78:	0f b6       	in	r0, 0x3f	; 63
     a7a:	f8 94       	cli
     a7c:	0f 92       	push	r0
     a7e:	1f 92       	push	r1
     a80:	11 24       	eor	r1, r1
     a82:	2f 92       	push	r2
     a84:	3f 92       	push	r3
     a86:	4f 92       	push	r4
     a88:	5f 92       	push	r5
     a8a:	6f 92       	push	r6
     a8c:	7f 92       	push	r7
     a8e:	8f 92       	push	r8
     a90:	9f 92       	push	r9
     a92:	af 92       	push	r10
     a94:	bf 92       	push	r11
     a96:	cf 92       	push	r12
     a98:	df 92       	push	r13
     a9a:	ef 92       	push	r14
     a9c:	ff 92       	push	r15
     a9e:	0f 93       	push	r16
     aa0:	1f 93       	push	r17
     aa2:	2f 93       	push	r18
     aa4:	3f 93       	push	r19
     aa6:	4f 93       	push	r20
     aa8:	5f 93       	push	r21
     aaa:	6f 93       	push	r22
     aac:	7f 93       	push	r23
     aae:	8f 93       	push	r24
     ab0:	9f 93       	push	r25
     ab2:	af 93       	push	r26
     ab4:	bf 93       	push	r27
     ab6:	cf 93       	push	r28
     ab8:	df 93       	push	r29
     aba:	ef 93       	push	r30
     abc:	ff 93       	push	r31
     abe:	a0 91 27 03 	lds	r26, 0x0327
     ac2:	b0 91 28 03 	lds	r27, 0x0328
     ac6:	0d b6       	in	r0, 0x3d	; 61
     ac8:	0d 92       	st	X+, r0
     aca:	0e b6       	in	r0, 0x3e	; 62
     acc:	0d 92       	st	X+, r0
	vTaskIncrementTick();
     ace:	0e 94 1b 0b 	call	0x1636	; 0x1636 <vTaskIncrementTick>
	vTaskSwitchContext();
     ad2:	0e 94 1a 0d 	call	0x1a34	; 0x1a34 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
     ad6:	a0 91 27 03 	lds	r26, 0x0327
     ada:	b0 91 28 03 	lds	r27, 0x0328
     ade:	cd 91       	ld	r28, X+
     ae0:	cd bf       	out	0x3d, r28	; 61
     ae2:	dd 91       	ld	r29, X+
     ae4:	de bf       	out	0x3e, r29	; 62
     ae6:	ff 91       	pop	r31
     ae8:	ef 91       	pop	r30
     aea:	df 91       	pop	r29
     aec:	cf 91       	pop	r28
     aee:	bf 91       	pop	r27
     af0:	af 91       	pop	r26
     af2:	9f 91       	pop	r25
     af4:	8f 91       	pop	r24
     af6:	7f 91       	pop	r23
     af8:	6f 91       	pop	r22
     afa:	5f 91       	pop	r21
     afc:	4f 91       	pop	r20
     afe:	3f 91       	pop	r19
     b00:	2f 91       	pop	r18
     b02:	1f 91       	pop	r17
     b04:	0f 91       	pop	r16
     b06:	ff 90       	pop	r15
     b08:	ef 90       	pop	r14
     b0a:	df 90       	pop	r13
     b0c:	cf 90       	pop	r12
     b0e:	bf 90       	pop	r11
     b10:	af 90       	pop	r10
     b12:	9f 90       	pop	r9
     b14:	8f 90       	pop	r8
     b16:	7f 90       	pop	r7
     b18:	6f 90       	pop	r6
     b1a:	5f 90       	pop	r5
     b1c:	4f 90       	pop	r4
     b1e:	3f 90       	pop	r3
     b20:	2f 90       	pop	r2
     b22:	1f 90       	pop	r1
     b24:	0f 90       	pop	r0
     b26:	0f be       	out	0x3f, r0	; 63
     b28:	0f 90       	pop	r0

	asm volatile ( "ret" );
     b2a:	08 95       	ret

00000b2c <__vector_7>:
	 * count is incremented after the context is saved.
	 */
	void SIG_OUTPUT_COMPARE1A( void ) __attribute__ ( ( signal, naked ) );
	void SIG_OUTPUT_COMPARE1A( void )
	{
		vPortYieldFromTick();
     b2c:	0e 94 3b 05 	call	0xa76	; 0xa76 <vPortYieldFromTick>
		asm volatile ( "reti" );
     b30:	18 95       	reti

00000b32 <prvCopyDataFromQueue>:
	++( pxQueue->uxMessagesWaiting );
}
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( xQUEUE * const pxQueue, const void *pvBuffer )
{
     b32:	cf 93       	push	r28
     b34:	df 93       	push	r29
     b36:	fc 01       	movw	r30, r24
	if( pxQueue->uxQueueType != queueQUEUE_IS_MUTEX )
     b38:	a0 81       	ld	r26, Z
     b3a:	b1 81       	ldd	r27, Z+1	; 0x01
     b3c:	10 97       	sbiw	r26, 0x00	; 0
     b3e:	b9 f0       	breq	.+46     	; 0xb6e <prvCopyDataFromQueue+0x3c>
	{
		pxQueue->pcReadFrom += pxQueue->uxItemSize;
     b40:	44 8d       	ldd	r20, Z+28	; 0x1c
     b42:	26 81       	ldd	r18, Z+6	; 0x06
     b44:	37 81       	ldd	r19, Z+7	; 0x07
     b46:	24 0f       	add	r18, r20
     b48:	31 1d       	adc	r19, r1
     b4a:	37 83       	std	Z+7, r19	; 0x07
     b4c:	26 83       	std	Z+6, r18	; 0x06
		if( pxQueue->pcReadFrom >= pxQueue->pcTail )
     b4e:	c2 81       	ldd	r28, Z+2	; 0x02
     b50:	d3 81       	ldd	r29, Z+3	; 0x03
     b52:	2c 17       	cp	r18, r28
     b54:	3d 07       	cpc	r19, r29
     b56:	10 f0       	brcs	.+4      	; 0xb5c <prvCopyDataFromQueue+0x2a>
		{
			pxQueue->pcReadFrom = pxQueue->pcHead;
     b58:	b7 83       	std	Z+7, r27	; 0x07
     b5a:	a6 83       	std	Z+6, r26	; 0x06
		}
		memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
     b5c:	36 81       	ldd	r19, Z+6	; 0x06
     b5e:	27 81       	ldd	r18, Z+7	; 0x07
     b60:	86 2f       	mov	r24, r22
     b62:	97 2f       	mov	r25, r23
     b64:	63 2f       	mov	r22, r19
     b66:	72 2f       	mov	r23, r18
     b68:	50 e0       	ldi	r21, 0x00	; 0
     b6a:	0e 94 30 0e 	call	0x1c60	; 0x1c60 <memcpy>
	}
}
     b6e:	df 91       	pop	r29
     b70:	cf 91       	pop	r28
     b72:	08 95       	ret

00000b74 <prvCopyDataToQueue>:
	vPortFree( pxQueue );
}
/*-----------------------------------------------------------*/

static void prvCopyDataToQueue( xQUEUE *pxQueue, const void *pvItemToQueue, portBASE_TYPE xPosition )
{
     b74:	cf 93       	push	r28
     b76:	df 93       	push	r29
     b78:	ec 01       	movw	r28, r24
	if( pxQueue->uxItemSize == ( unsigned portBASE_TYPE ) 0 )
     b7a:	2c 8d       	ldd	r18, Y+28	; 0x1c
     b7c:	22 23       	and	r18, r18
     b7e:	a9 f1       	breq	.+106    	; 0xbea <prvCopyDataToQueue+0x76>
				pxQueue->pxMutexHolder = NULL;
			}
		}
		#endif
	}
	else if( xPosition == queueSEND_TO_BACK )
     b80:	44 23       	and	r20, r20
     b82:	b9 f4       	brne	.+46     	; 0xbb2 <prvCopyDataToQueue+0x3e>
	{
		memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
     b84:	8c 81       	ldd	r24, Y+4	; 0x04
     b86:	9d 81       	ldd	r25, Y+5	; 0x05
     b88:	42 2f       	mov	r20, r18
     b8a:	50 e0       	ldi	r21, 0x00	; 0
     b8c:	0e 94 30 0e 	call	0x1c60	; 0x1c60 <memcpy>
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
     b90:	2c 8d       	ldd	r18, Y+28	; 0x1c
     b92:	8c 81       	ldd	r24, Y+4	; 0x04
     b94:	9d 81       	ldd	r25, Y+5	; 0x05
     b96:	82 0f       	add	r24, r18
     b98:	91 1d       	adc	r25, r1
     b9a:	9d 83       	std	Y+5, r25	; 0x05
     b9c:	8c 83       	std	Y+4, r24	; 0x04
		if( pxQueue->pcWriteTo >= pxQueue->pcTail )
     b9e:	2a 81       	ldd	r18, Y+2	; 0x02
     ba0:	3b 81       	ldd	r19, Y+3	; 0x03
     ba2:	82 17       	cp	r24, r18
     ba4:	93 07       	cpc	r25, r19
     ba6:	08 f1       	brcs	.+66     	; 0xbea <prvCopyDataToQueue+0x76>
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
     ba8:	88 81       	ld	r24, Y
     baa:	99 81       	ldd	r25, Y+1	; 0x01
     bac:	9d 83       	std	Y+5, r25	; 0x05
     bae:	8c 83       	std	Y+4, r24	; 0x04
     bb0:	1c c0       	rjmp	.+56     	; 0xbea <prvCopyDataToQueue+0x76>
		}
	}
	else
	{
		memcpy( ( void * ) pxQueue->pcReadFrom, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
     bb2:	8e 81       	ldd	r24, Y+6	; 0x06
     bb4:	9f 81       	ldd	r25, Y+7	; 0x07
     bb6:	42 2f       	mov	r20, r18
     bb8:	50 e0       	ldi	r21, 0x00	; 0
     bba:	0e 94 30 0e 	call	0x1c60	; 0x1c60 <memcpy>
		pxQueue->pcReadFrom -= pxQueue->uxItemSize;
     bbe:	2c 8d       	ldd	r18, Y+28	; 0x1c
     bc0:	30 e0       	ldi	r19, 0x00	; 0
     bc2:	30 95       	com	r19
     bc4:	21 95       	neg	r18
     bc6:	3f 4f       	sbci	r19, 0xFF	; 255
     bc8:	8e 81       	ldd	r24, Y+6	; 0x06
     bca:	9f 81       	ldd	r25, Y+7	; 0x07
     bcc:	82 0f       	add	r24, r18
     bce:	93 1f       	adc	r25, r19
     bd0:	9f 83       	std	Y+7, r25	; 0x07
     bd2:	8e 83       	std	Y+6, r24	; 0x06
		if( pxQueue->pcReadFrom < pxQueue->pcHead )
     bd4:	48 81       	ld	r20, Y
     bd6:	59 81       	ldd	r21, Y+1	; 0x01
     bd8:	84 17       	cp	r24, r20
     bda:	95 07       	cpc	r25, r21
     bdc:	30 f4       	brcc	.+12     	; 0xbea <prvCopyDataToQueue+0x76>
		{
			pxQueue->pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
     bde:	8a 81       	ldd	r24, Y+2	; 0x02
     be0:	9b 81       	ldd	r25, Y+3	; 0x03
     be2:	28 0f       	add	r18, r24
     be4:	39 1f       	adc	r19, r25
     be6:	3f 83       	std	Y+7, r19	; 0x07
     be8:	2e 83       	std	Y+6, r18	; 0x06
		}
	}

	++( pxQueue->uxMessagesWaiting );
     bea:	8a 8d       	ldd	r24, Y+26	; 0x1a
     bec:	8f 5f       	subi	r24, 0xFF	; 255
     bee:	8a 8f       	std	Y+26, r24	; 0x1a
}
     bf0:	df 91       	pop	r29
     bf2:	cf 91       	pop	r28
     bf4:	08 95       	ret

00000bf6 <prvUnlockQueue>:
	}
}
/*-----------------------------------------------------------*/

static void prvUnlockQueue( xQueueHandle pxQueue )
{
     bf6:	0f 93       	push	r16
     bf8:	1f 93       	push	r17
     bfa:	cf 93       	push	r28
     bfc:	df 93       	push	r29
     bfe:	ec 01       	movw	r28, r24

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
     c00:	0f b6       	in	r0, 0x3f	; 63
     c02:	f8 94       	cli
     c04:	0f 92       	push	r0
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
     c06:	8e 8d       	ldd	r24, Y+30	; 0x1e
     c08:	18 16       	cp	r1, r24
     c0a:	bc f4       	brge	.+46     	; 0xc3a <prvUnlockQueue+0x44>
		{
			/* Data was posted while the queue was locked.  Are any tasks
			blocked waiting for data to become available? */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
     c0c:	89 89       	ldd	r24, Y+17	; 0x11
     c0e:	88 23       	and	r24, r24
     c10:	29 f4       	brne	.+10     	; 0xc1c <prvUnlockQueue+0x26>
     c12:	13 c0       	rjmp	.+38     	; 0xc3a <prvUnlockQueue+0x44>
     c14:	89 89       	ldd	r24, Y+17	; 0x11
     c16:	88 23       	and	r24, r24
     c18:	21 f4       	brne	.+8      	; 0xc22 <prvUnlockQueue+0x2c>
     c1a:	0f c0       	rjmp	.+30     	; 0xc3a <prvUnlockQueue+0x44>
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
     c1c:	8e 01       	movw	r16, r28
     c1e:	0f 5e       	subi	r16, 0xEF	; 239
     c20:	1f 4f       	sbci	r17, 0xFF	; 255
     c22:	c8 01       	movw	r24, r16
     c24:	0e 94 a5 0d 	call	0x1b4a	; 0x1b4a <xTaskRemoveFromEventList>
     c28:	88 23       	and	r24, r24
     c2a:	11 f0       	breq	.+4      	; 0xc30 <prvUnlockQueue+0x3a>
				{
					/* The task waiting has a higher priority so record that a
					context	switch is required. */
					vTaskMissedYield();
     c2c:	0e 94 2c 0e 	call	0x1c58	; 0x1c58 <vTaskMissedYield>
				}

				--( pxQueue->xTxLock );
     c30:	8e 8d       	ldd	r24, Y+30	; 0x1e
     c32:	81 50       	subi	r24, 0x01	; 1
     c34:	8e 8f       	std	Y+30, r24	; 0x1e
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
     c36:	18 16       	cp	r1, r24
     c38:	6c f3       	brlt	.-38     	; 0xc14 <prvUnlockQueue+0x1e>
			{
				break;
			}
		}

		pxQueue->xTxLock = queueUNLOCKED;
     c3a:	8f ef       	ldi	r24, 0xFF	; 255
     c3c:	8e 8f       	std	Y+30, r24	; 0x1e
	}
	taskEXIT_CRITICAL();
     c3e:	0f 90       	pop	r0
     c40:	0f be       	out	0x3f, r0	; 63

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
     c42:	0f b6       	in	r0, 0x3f	; 63
     c44:	f8 94       	cli
     c46:	0f 92       	push	r0
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
     c48:	8d 8d       	ldd	r24, Y+29	; 0x1d
     c4a:	18 16       	cp	r1, r24
     c4c:	bc f4       	brge	.+46     	; 0xc7c <prvUnlockQueue+0x86>
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
     c4e:	88 85       	ldd	r24, Y+8	; 0x08
     c50:	88 23       	and	r24, r24
     c52:	29 f4       	brne	.+10     	; 0xc5e <prvUnlockQueue+0x68>
     c54:	13 c0       	rjmp	.+38     	; 0xc7c <prvUnlockQueue+0x86>
     c56:	88 85       	ldd	r24, Y+8	; 0x08
     c58:	88 23       	and	r24, r24
     c5a:	21 f4       	brne	.+8      	; 0xc64 <prvUnlockQueue+0x6e>
     c5c:	0f c0       	rjmp	.+30     	; 0xc7c <prvUnlockQueue+0x86>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
     c5e:	8e 01       	movw	r16, r28
     c60:	08 5f       	subi	r16, 0xF8	; 248
     c62:	1f 4f       	sbci	r17, 0xFF	; 255
     c64:	c8 01       	movw	r24, r16
     c66:	0e 94 a5 0d 	call	0x1b4a	; 0x1b4a <xTaskRemoveFromEventList>
     c6a:	88 23       	and	r24, r24
     c6c:	11 f0       	breq	.+4      	; 0xc72 <prvUnlockQueue+0x7c>
				{
					vTaskMissedYield();
     c6e:	0e 94 2c 0e 	call	0x1c58	; 0x1c58 <vTaskMissedYield>
				}

				--( pxQueue->xRxLock );
     c72:	8d 8d       	ldd	r24, Y+29	; 0x1d
     c74:	81 50       	subi	r24, 0x01	; 1
     c76:	8d 8f       	std	Y+29, r24	; 0x1d
	taskEXIT_CRITICAL();

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
     c78:	18 16       	cp	r1, r24
     c7a:	6c f3       	brlt	.-38     	; 0xc56 <prvUnlockQueue+0x60>
			{
				break;
			}
		}

		pxQueue->xRxLock = queueUNLOCKED;
     c7c:	8f ef       	ldi	r24, 0xFF	; 255
     c7e:	8d 8f       	std	Y+29, r24	; 0x1d
	}
	taskEXIT_CRITICAL();
     c80:	0f 90       	pop	r0
     c82:	0f be       	out	0x3f, r0	; 63
}
     c84:	df 91       	pop	r29
     c86:	cf 91       	pop	r28
     c88:	1f 91       	pop	r17
     c8a:	0f 91       	pop	r16
     c8c:	08 95       	ret

00000c8e <xQueueCreate>:
/*-----------------------------------------------------------
 * PUBLIC QUEUE MANAGEMENT API documented in queue.h
 *----------------------------------------------------------*/

xQueueHandle xQueueCreate( unsigned portBASE_TYPE uxQueueLength, unsigned portBASE_TYPE uxItemSize )
{
     c8e:	8f 92       	push	r8
     c90:	9f 92       	push	r9
     c92:	af 92       	push	r10
     c94:	bf 92       	push	r11
     c96:	cf 92       	push	r12
     c98:	df 92       	push	r13
     c9a:	ef 92       	push	r14
     c9c:	ff 92       	push	r15
     c9e:	0f 93       	push	r16
     ca0:	1f 93       	push	r17
     ca2:	cf 93       	push	r28
     ca4:	df 93       	push	r29
     ca6:	18 2f       	mov	r17, r24
     ca8:	06 2f       	mov	r16, r22
xQUEUE *pxNewQueue;
size_t xQueueSizeInBytes;
xQueueHandle xReturn = NULL;

	/* Allocate the new queue structure. */
	if( uxQueueLength > ( unsigned portBASE_TYPE ) 0 )
     caa:	88 23       	and	r24, r24
     cac:	09 f4       	brne	.+2      	; 0xcb0 <xQueueCreate+0x22>
     cae:	49 c0       	rjmp	.+146    	; 0xd42 <xQueueCreate+0xb4>
	{
		pxNewQueue = ( xQUEUE * ) pvPortMalloc( sizeof( xQUEUE ) );
     cb0:	8f e1       	ldi	r24, 0x1F	; 31
     cb2:	90 e0       	ldi	r25, 0x00	; 0
     cb4:	0e 94 80 02 	call	0x500	; 0x500 <pvPortMalloc>
     cb8:	e8 2e       	mov	r14, r24
     cba:	f9 2e       	mov	r15, r25
     cbc:	e7 01       	movw	r28, r14
		if( pxNewQueue != NULL )
     cbe:	20 97       	sbiw	r28, 0x00	; 0
     cc0:	09 f4       	brne	.+2      	; 0xcc4 <xQueueCreate+0x36>
     cc2:	42 c0       	rjmp	.+132    	; 0xd48 <xQueueCreate+0xba>
		{
			/* Create the list of pointers to queue items.  The queue is one byte
			longer than asked for to make wrap checking easier/faster. */
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ) + ( size_t ) 1;
     cc4:	a1 2e       	mov	r10, r17
     cc6:	bb 24       	eor	r11, r11
     cc8:	80 2e       	mov	r8, r16
     cca:	99 24       	eor	r9, r9
     ccc:	8a 9c       	mul	r8, r10
     cce:	60 01       	movw	r12, r0
     cd0:	8b 9c       	mul	r8, r11
     cd2:	d0 0c       	add	r13, r0
     cd4:	9a 9c       	mul	r9, r10
     cd6:	d0 0c       	add	r13, r0
     cd8:	11 24       	eor	r1, r1

			pxNewQueue->pcHead = ( signed char * ) pvPortMalloc( xQueueSizeInBytes );
     cda:	c6 01       	movw	r24, r12
     cdc:	01 96       	adiw	r24, 0x01	; 1
     cde:	0e 94 80 02 	call	0x500	; 0x500 <pvPortMalloc>
     ce2:	28 2f       	mov	r18, r24
     ce4:	39 2f       	mov	r19, r25
     ce6:	39 83       	std	Y+1, r19	; 0x01
     ce8:	28 83       	st	Y, r18
			if( pxNewQueue->pcHead != NULL )
     cea:	21 15       	cp	r18, r1
     cec:	31 05       	cpc	r19, r1
     cee:	19 f1       	breq	.+70     	; 0xd36 <xQueueCreate+0xa8>
			{
				/* Initialise the queue members as described above where the
				queue type is defined. */
				pxNewQueue->pcTail = pxNewQueue->pcHead + ( uxQueueLength * uxItemSize );
     cf0:	c2 0e       	add	r12, r18
     cf2:	d3 1e       	adc	r13, r19
     cf4:	db 82       	std	Y+3, r13	; 0x03
     cf6:	ca 82       	std	Y+2, r12	; 0x02
				pxNewQueue->uxMessagesWaiting = ( unsigned portBASE_TYPE ) 0U;
     cf8:	1a 8e       	std	Y+26, r1	; 0x1a
				pxNewQueue->pcWriteTo = pxNewQueue->pcHead;
     cfa:	3d 83       	std	Y+5, r19	; 0x05
     cfc:	2c 83       	std	Y+4, r18	; 0x04
				pxNewQueue->pcReadFrom = pxNewQueue->pcHead + ( ( uxQueueLength - ( unsigned portBASE_TYPE ) 1U ) * uxItemSize );
     cfe:	08 94       	sec
     d00:	a1 08       	sbc	r10, r1
     d02:	b1 08       	sbc	r11, r1
     d04:	a8 9c       	mul	r10, r8
     d06:	c0 01       	movw	r24, r0
     d08:	a9 9c       	mul	r10, r9
     d0a:	90 0d       	add	r25, r0
     d0c:	b8 9c       	mul	r11, r8
     d0e:	90 0d       	add	r25, r0
     d10:	11 24       	eor	r1, r1
     d12:	28 0f       	add	r18, r24
     d14:	39 1f       	adc	r19, r25
     d16:	3f 83       	std	Y+7, r19	; 0x07
     d18:	2e 83       	std	Y+6, r18	; 0x06
				pxNewQueue->uxLength = uxQueueLength;
     d1a:	1b 8f       	std	Y+27, r17	; 0x1b
				pxNewQueue->uxItemSize = uxItemSize;
     d1c:	0c 8f       	std	Y+28, r16	; 0x1c
				pxNewQueue->xRxLock = queueUNLOCKED;
     d1e:	8f ef       	ldi	r24, 0xFF	; 255
     d20:	8d 8f       	std	Y+29, r24	; 0x1d
				pxNewQueue->xTxLock = queueUNLOCKED;
     d22:	8e 8f       	std	Y+30, r24	; 0x1e

				/* Likewise ensure the event queues start with the correct state. */
				vListInitialise( &( pxNewQueue->xTasksWaitingToSend ) );
     d24:	ce 01       	movw	r24, r28
     d26:	08 96       	adiw	r24, 0x08	; 8
     d28:	0e 94 4c 03 	call	0x698	; 0x698 <vListInitialise>
				vListInitialise( &( pxNewQueue->xTasksWaitingToReceive ) );
     d2c:	ce 01       	movw	r24, r28
     d2e:	41 96       	adiw	r24, 0x11	; 17
     d30:	0e 94 4c 03 	call	0x698	; 0x698 <vListInitialise>
     d34:	0b c0       	rjmp	.+22     	; 0xd4c <xQueueCreate+0xbe>
				xReturn = pxNewQueue;
			}
			else
			{
				traceQUEUE_CREATE_FAILED();
				vPortFree( pxNewQueue );
     d36:	ce 01       	movw	r24, r28
     d38:	0e 94 ae 02 	call	0x55c	; 0x55c <vPortFree>

xQueueHandle xQueueCreate( unsigned portBASE_TYPE uxQueueLength, unsigned portBASE_TYPE uxItemSize )
{
xQUEUE *pxNewQueue;
size_t xQueueSizeInBytes;
xQueueHandle xReturn = NULL;
     d3c:	c0 e0       	ldi	r28, 0x00	; 0
     d3e:	d0 e0       	ldi	r29, 0x00	; 0
     d40:	05 c0       	rjmp	.+10     	; 0xd4c <xQueueCreate+0xbe>
     d42:	c0 e0       	ldi	r28, 0x00	; 0
     d44:	d0 e0       	ldi	r29, 0x00	; 0
     d46:	02 c0       	rjmp	.+4      	; 0xd4c <xQueueCreate+0xbe>
     d48:	c0 e0       	ldi	r28, 0x00	; 0
     d4a:	d0 e0       	ldi	r29, 0x00	; 0
	}

	configASSERT( xReturn );

	return xReturn;
}
     d4c:	7e 01       	movw	r14, r28
     d4e:	8c 2f       	mov	r24, r28
     d50:	9f 2d       	mov	r25, r15
     d52:	df 91       	pop	r29
     d54:	cf 91       	pop	r28
     d56:	1f 91       	pop	r17
     d58:	0f 91       	pop	r16
     d5a:	ff 90       	pop	r15
     d5c:	ef 90       	pop	r14
     d5e:	df 90       	pop	r13
     d60:	cf 90       	pop	r12
     d62:	bf 90       	pop	r11
     d64:	af 90       	pop	r10
     d66:	9f 90       	pop	r9
     d68:	8f 90       	pop	r8
     d6a:	08 95       	ret

00000d6c <xQueueCreateCountingSemaphore>:
/*-----------------------------------------------------------*/

#if configUSE_COUNTING_SEMAPHORES == 1

	xQueueHandle xQueueCreateCountingSemaphore( unsigned portBASE_TYPE uxCountValue, unsigned portBASE_TYPE uxInitialCount )
	{
     d6c:	1f 93       	push	r17
     d6e:	16 2f       	mov	r17, r22
	xQueueHandle pxHandle;

		pxHandle = xQueueCreate( ( unsigned portBASE_TYPE ) uxCountValue, queueSEMAPHORE_QUEUE_ITEM_LENGTH );
     d70:	60 e0       	ldi	r22, 0x00	; 0
     d72:	0e 94 47 06 	call	0xc8e	; 0xc8e <xQueueCreate>
     d76:	fc 01       	movw	r30, r24

		if( pxHandle != NULL )
     d78:	00 97       	sbiw	r24, 0x00	; 0
     d7a:	09 f0       	breq	.+2      	; 0xd7e <xQueueCreateCountingSemaphore+0x12>
		{
			pxHandle->uxMessagesWaiting = uxInitialCount;
     d7c:	12 8f       	std	Z+26, r17	; 0x1a
			traceCREATE_COUNTING_SEMAPHORE_FAILED();
		}

		configASSERT( pxHandle );
		return pxHandle;
	}
     d7e:	8e 2f       	mov	r24, r30
     d80:	9f 2f       	mov	r25, r31
     d82:	1f 91       	pop	r17
     d84:	08 95       	ret

00000d86 <xQueueGenericSend>:

#endif /* configUSE_COUNTING_SEMAPHORES */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSend( xQueueHandle pxQueue, const void * const pvItemToQueue, portTickType xTicksToWait, portBASE_TYPE xCopyPosition )
{
     d86:	5f 92       	push	r5
     d88:	6f 92       	push	r6
     d8a:	7f 92       	push	r7
     d8c:	8f 92       	push	r8
     d8e:	9f 92       	push	r9
     d90:	af 92       	push	r10
     d92:	bf 92       	push	r11
     d94:	cf 92       	push	r12
     d96:	df 92       	push	r13
     d98:	ef 92       	push	r14
     d9a:	ff 92       	push	r15
     d9c:	0f 93       	push	r16
     d9e:	1f 93       	push	r17
     da0:	df 93       	push	r29
     da2:	cf 93       	push	r28
     da4:	00 d0       	rcall	.+0      	; 0xda6 <xQueueGenericSend+0x20>
     da6:	00 d0       	rcall	.+0      	; 0xda8 <xQueueGenericSend+0x22>
     da8:	0f 92       	push	r0
     daa:	cd b7       	in	r28, 0x3d	; 61
     dac:	de b7       	in	r29, 0x3e	; 62
     dae:	8c 01       	movw	r16, r24
     db0:	3b 01       	movw	r6, r22
     db2:	5d 83       	std	Y+5, r21	; 0x05
     db4:	4c 83       	std	Y+4, r20	; 0x04
     db6:	52 2e       	mov	r5, r18
signed portBASE_TYPE xEntryTimeSet = pdFALSE;
     db8:	dd 24       	eor	r13, r13
				}
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
     dba:	7e 01       	movw	r14, r28
     dbc:	08 94       	sec
     dbe:	e1 1c       	adc	r14, r1
     dc0:	f1 1c       	adc	r15, r1
					xEntryTimeSet = pdTRUE;
     dc2:	cc 24       	eor	r12, r12
     dc4:	c3 94       	inc	r12

		vTaskSuspendAll();
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
     dc6:	aa 24       	eor	r10, r10
     dc8:	bb 24       	eor	r11, r11
     dca:	68 94       	set
     dcc:	a2 f8       	bld	r10, 2
     dce:	ac 0e       	add	r10, r28
     dd0:	bd 1e       	adc	r11, r29
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
     dd2:	88 24       	eor	r8, r8
     dd4:	99 24       	eor	r9, r9
     dd6:	68 94       	set
     dd8:	83 f8       	bld	r8, 3
     dda:	88 0e       	add	r8, r24
     ddc:	99 1e       	adc	r9, r25
	/* This function relaxes the coding standard somewhat to allow return
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
     dde:	0f b6       	in	r0, 0x3f	; 63
     de0:	f8 94       	cli
     de2:	0f 92       	push	r0
		{
			/* Is there room on the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
     de4:	f8 01       	movw	r30, r16
     de6:	92 8d       	ldd	r25, Z+26	; 0x1a
     de8:	83 8d       	ldd	r24, Z+27	; 0x1b
     dea:	98 17       	cp	r25, r24
     dec:	a8 f4       	brcc	.+42     	; 0xe18 <xQueueGenericSend+0x92>
			{
				traceQUEUE_SEND( pxQueue );
				prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
     dee:	c8 01       	movw	r24, r16
     df0:	b3 01       	movw	r22, r6
     df2:	45 2d       	mov	r20, r5
     df4:	0e 94 ba 05 	call	0xb74	; 0xb74 <prvCopyDataToQueue>

				/* If there was a task waiting for data to arrive on the
				queue then unblock it now. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
     df8:	f8 01       	movw	r30, r16
     dfa:	81 89       	ldd	r24, Z+17	; 0x11
     dfc:	88 23       	and	r24, r24
     dfe:	41 f0       	breq	.+16     	; 0xe10 <xQueueGenericSend+0x8a>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) == pdTRUE )
     e00:	c8 01       	movw	r24, r16
     e02:	41 96       	adiw	r24, 0x11	; 17
     e04:	0e 94 a5 0d 	call	0x1b4a	; 0x1b4a <xTaskRemoveFromEventList>
     e08:	81 30       	cpi	r24, 0x01	; 1
     e0a:	11 f4       	brne	.+4      	; 0xe10 <xQueueGenericSend+0x8a>
					{
						/* The unblocked task has a priority higher than
						our own so yield immediately.  Yes it is ok to do
						this from within the critical section - the kernel
						takes care of that. */
						portYIELD_WITHIN_API();
     e0c:	0e 94 e2 04 	call	0x9c4	; 0x9c4 <vPortYield>
					}
				}

				taskEXIT_CRITICAL();
     e10:	0f 90       	pop	r0
     e12:	0f be       	out	0x3f, r0	; 63

				/* Return to the original privilege level before exiting the
				function. */
				return pdPASS;
     e14:	81 e0       	ldi	r24, 0x01	; 1
     e16:	4e c0       	rjmp	.+156    	; 0xeb4 <xQueueGenericSend+0x12e>
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
     e18:	8c 81       	ldd	r24, Y+4	; 0x04
     e1a:	9d 81       	ldd	r25, Y+5	; 0x05
     e1c:	00 97       	sbiw	r24, 0x00	; 0
     e1e:	21 f4       	brne	.+8      	; 0xe28 <xQueueGenericSend+0xa2>
				{
					/* The queue was full and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
     e20:	0f 90       	pop	r0
     e22:	0f be       	out	0x3f, r0	; 63

					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED( pxQueue );
					return errQUEUE_FULL;
     e24:	80 e0       	ldi	r24, 0x00	; 0
     e26:	46 c0       	rjmp	.+140    	; 0xeb4 <xQueueGenericSend+0x12e>
				}
				else if( xEntryTimeSet == pdFALSE )
     e28:	dd 20       	and	r13, r13
     e2a:	21 f4       	brne	.+8      	; 0xe34 <xQueueGenericSend+0xae>
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
     e2c:	c7 01       	movw	r24, r14
     e2e:	0e 94 eb 0d 	call	0x1bd6	; 0x1bd6 <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
     e32:	dc 2c       	mov	r13, r12
				}
			}
		}
		taskEXIT_CRITICAL();
     e34:	0f 90       	pop	r0
     e36:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
     e38:	0e 94 ff 0a 	call	0x15fe	; 0x15fe <vTaskSuspendAll>
		prvLockQueue( pxQueue );
     e3c:	0f b6       	in	r0, 0x3f	; 63
     e3e:	f8 94       	cli
     e40:	0f 92       	push	r0
     e42:	f8 01       	movw	r30, r16
     e44:	85 8d       	ldd	r24, Z+29	; 0x1d
     e46:	8f 3f       	cpi	r24, 0xFF	; 255
     e48:	09 f4       	brne	.+2      	; 0xe4c <xQueueGenericSend+0xc6>
     e4a:	15 8e       	std	Z+29, r1	; 0x1d
     e4c:	f8 01       	movw	r30, r16
     e4e:	86 8d       	ldd	r24, Z+30	; 0x1e
     e50:	8f 3f       	cpi	r24, 0xFF	; 255
     e52:	09 f4       	brne	.+2      	; 0xe56 <xQueueGenericSend+0xd0>
     e54:	16 8e       	std	Z+30, r1	; 0x1e
     e56:	0f 90       	pop	r0
     e58:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
     e5a:	c7 01       	movw	r24, r14
     e5c:	b5 01       	movw	r22, r10
     e5e:	0e 94 f6 0d 	call	0x1bec	; 0x1bec <xTaskCheckForTimeOut>
     e62:	88 23       	and	r24, r24
     e64:	09 f5       	brne	.+66     	; 0xea8 <xQueueGenericSend+0x122>

static signed portBASE_TYPE prvIsQueueFull( const xQueueHandle pxQueue )
{
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
     e66:	0f b6       	in	r0, 0x3f	; 63
     e68:	f8 94       	cli
     e6a:	0f 92       	push	r0
		xReturn = ( pxQueue->uxMessagesWaiting == pxQueue->uxLength );
     e6c:	f8 01       	movw	r30, r16
     e6e:	92 8d       	ldd	r25, Z+26	; 0x1a
	taskEXIT_CRITICAL();
     e70:	0f 90       	pop	r0
     e72:	0f be       	out	0x3f, r0	; 63
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
     e74:	f8 01       	movw	r30, r16
     e76:	83 8d       	ldd	r24, Z+27	; 0x1b
     e78:	98 17       	cp	r25, r24
     e7a:	81 f4       	brne	.+32     	; 0xe9c <xQueueGenericSend+0x116>
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
     e7c:	6c 81       	ldd	r22, Y+4	; 0x04
     e7e:	7d 81       	ldd	r23, Y+5	; 0x05
     e80:	c4 01       	movw	r24, r8
     e82:	0e 94 88 0d 	call	0x1b10	; 0x1b10 <vTaskPlaceOnEventList>
				/* Unlocking the queue means queue events can effect the
				event list.  It is possible	that interrupts occurring now
				remove this task from the event	list again - but as the
				scheduler is suspended the task will go onto the pending
				ready last instead of the actual ready list. */
				prvUnlockQueue( pxQueue );
     e86:	c8 01       	movw	r24, r16
     e88:	0e 94 fb 05 	call	0xbf6	; 0xbf6 <prvUnlockQueue>
				/* Resuming the scheduler will move tasks from the pending
				ready list into the ready list - so it is feasible that this
				task is already in a ready list before it yields - in which
				case the yield will not cause a context switch unless there
				is also a higher priority task in the pending ready list. */
				if( xTaskResumeAll() == pdFALSE )
     e8c:	0e 94 e1 0b 	call	0x17c2	; 0x17c2 <xTaskResumeAll>
     e90:	88 23       	and	r24, r24
     e92:	09 f0       	breq	.+2      	; 0xe96 <xQueueGenericSend+0x110>
     e94:	a4 cf       	rjmp	.-184    	; 0xdde <xQueueGenericSend+0x58>
				{
					portYIELD_WITHIN_API();
     e96:	0e 94 e2 04 	call	0x9c4	; 0x9c4 <vPortYield>
     e9a:	a1 cf       	rjmp	.-190    	; 0xdde <xQueueGenericSend+0x58>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
     e9c:	c8 01       	movw	r24, r16
     e9e:	0e 94 fb 05 	call	0xbf6	; 0xbf6 <prvUnlockQueue>
				( void ) xTaskResumeAll();
     ea2:	0e 94 e1 0b 	call	0x17c2	; 0x17c2 <xTaskResumeAll>
     ea6:	9b cf       	rjmp	.-202    	; 0xdde <xQueueGenericSend+0x58>
			}
		}
		else
		{
			/* The timeout has expired. */
			prvUnlockQueue( pxQueue );
     ea8:	c8 01       	movw	r24, r16
     eaa:	0e 94 fb 05 	call	0xbf6	; 0xbf6 <prvUnlockQueue>
			( void ) xTaskResumeAll();
     eae:	0e 94 e1 0b 	call	0x17c2	; 0x17c2 <xTaskResumeAll>

			/* Return to the original privilege level before exiting the
			function. */
			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
     eb2:	80 e0       	ldi	r24, 0x00	; 0
		}
	}
}
     eb4:	0f 90       	pop	r0
     eb6:	0f 90       	pop	r0
     eb8:	0f 90       	pop	r0
     eba:	0f 90       	pop	r0
     ebc:	0f 90       	pop	r0
     ebe:	cf 91       	pop	r28
     ec0:	df 91       	pop	r29
     ec2:	1f 91       	pop	r17
     ec4:	0f 91       	pop	r16
     ec6:	ff 90       	pop	r15
     ec8:	ef 90       	pop	r14
     eca:	df 90       	pop	r13
     ecc:	cf 90       	pop	r12
     ece:	bf 90       	pop	r11
     ed0:	af 90       	pop	r10
     ed2:	9f 90       	pop	r9
     ed4:	8f 90       	pop	r8
     ed6:	7f 90       	pop	r7
     ed8:	6f 90       	pop	r6
     eda:	5f 90       	pop	r5
     edc:	08 95       	ret

00000ede <xQueueGenericSendFromISR>:

#endif /* configUSE_ALTERNATIVE_API */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSendFromISR( xQueueHandle pxQueue, const void * const pvItemToQueue, signed portBASE_TYPE *pxHigherPriorityTaskWoken, portBASE_TYPE xCopyPosition )
{
     ede:	0f 93       	push	r16
     ee0:	1f 93       	push	r17
     ee2:	cf 93       	push	r28
     ee4:	df 93       	push	r29
     ee6:	ec 01       	movw	r28, r24
     ee8:	8a 01       	movw	r16, r20
	queue read, instead we return a flag to say whether a context switch is
	required or not (i.e. has a task with a higher priority than us been woken
	by this	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
     eea:	9a 8d       	ldd	r25, Y+26	; 0x1a
     eec:	8b 8d       	ldd	r24, Y+27	; 0x1b
     eee:	98 17       	cp	r25, r24
     ef0:	c0 f4       	brcc	.+48     	; 0xf22 <xQueueGenericSendFromISR+0x44>
		{
			traceQUEUE_SEND_FROM_ISR( pxQueue );

			prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
     ef2:	ce 01       	movw	r24, r28
     ef4:	42 2f       	mov	r20, r18
     ef6:	0e 94 ba 05 	call	0xb74	; 0xb74 <prvCopyDataToQueue>

			/* If the queue is locked we do not alter the event list.  This will
			be done when the queue is unlocked later. */
			if( pxQueue->xTxLock == queueUNLOCKED )
     efa:	8e 8d       	ldd	r24, Y+30	; 0x1e
     efc:	8f 3f       	cpi	r24, 0xFF	; 255
     efe:	69 f4       	brne	.+26     	; 0xf1a <xQueueGenericSendFromISR+0x3c>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
     f00:	89 89       	ldd	r24, Y+17	; 0x11
     f02:	88 23       	and	r24, r24
     f04:	81 f0       	breq	.+32     	; 0xf26 <xQueueGenericSendFromISR+0x48>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
     f06:	ce 01       	movw	r24, r28
     f08:	41 96       	adiw	r24, 0x11	; 17
     f0a:	0e 94 a5 0d 	call	0x1b4a	; 0x1b4a <xTaskRemoveFromEventList>
     f0e:	88 23       	and	r24, r24
     f10:	61 f0       	breq	.+24     	; 0xf2a <xQueueGenericSendFromISR+0x4c>
					{
						/* The task waiting has a higher priority so record that a
						context	switch is required. */
						*pxHigherPriorityTaskWoken = pdTRUE;
     f12:	81 e0       	ldi	r24, 0x01	; 1
     f14:	f8 01       	movw	r30, r16
     f16:	80 83       	st	Z, r24
     f18:	09 c0       	rjmp	.+18     	; 0xf2c <xQueueGenericSendFromISR+0x4e>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
     f1a:	8f 5f       	subi	r24, 0xFF	; 255
     f1c:	8e 8f       	std	Y+30, r24	; 0x1e
			}

			xReturn = pdPASS;
     f1e:	81 e0       	ldi	r24, 0x01	; 1
     f20:	05 c0       	rjmp	.+10     	; 0xf2c <xQueueGenericSendFromISR+0x4e>
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
     f22:	80 e0       	ldi	r24, 0x00	; 0
     f24:	03 c0       	rjmp	.+6      	; 0xf2c <xQueueGenericSendFromISR+0x4e>
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
			}

			xReturn = pdPASS;
     f26:	81 e0       	ldi	r24, 0x01	; 1
     f28:	01 c0       	rjmp	.+2      	; 0xf2c <xQueueGenericSendFromISR+0x4e>
     f2a:	81 e0       	ldi	r24, 0x01	; 1
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
     f2c:	df 91       	pop	r29
     f2e:	cf 91       	pop	r28
     f30:	1f 91       	pop	r17
     f32:	0f 91       	pop	r16
     f34:	08 95       	ret

00000f36 <xQueueGenericReceive>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericReceive( xQueueHandle pxQueue, void * const pvBuffer, portTickType xTicksToWait, portBASE_TYPE xJustPeeking )
{
     f36:	5f 92       	push	r5
     f38:	6f 92       	push	r6
     f3a:	7f 92       	push	r7
     f3c:	8f 92       	push	r8
     f3e:	9f 92       	push	r9
     f40:	af 92       	push	r10
     f42:	bf 92       	push	r11
     f44:	cf 92       	push	r12
     f46:	df 92       	push	r13
     f48:	ef 92       	push	r14
     f4a:	ff 92       	push	r15
     f4c:	0f 93       	push	r16
     f4e:	1f 93       	push	r17
     f50:	df 93       	push	r29
     f52:	cf 93       	push	r28
     f54:	00 d0       	rcall	.+0      	; 0xf56 <xQueueGenericReceive+0x20>
     f56:	00 d0       	rcall	.+0      	; 0xf58 <xQueueGenericReceive+0x22>
     f58:	0f 92       	push	r0
     f5a:	cd b7       	in	r28, 0x3d	; 61
     f5c:	de b7       	in	r29, 0x3e	; 62
     f5e:	8c 01       	movw	r16, r24
     f60:	3b 01       	movw	r6, r22
     f62:	5d 83       	std	Y+5, r21	; 0x05
     f64:	4c 83       	std	Y+4, r20	; 0x04
     f66:	52 2e       	mov	r5, r18
signed portBASE_TYPE xEntryTimeSet = pdFALSE;
     f68:	dd 24       	eor	r13, r13
				}
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
     f6a:	7e 01       	movw	r14, r28
     f6c:	08 94       	sec
     f6e:	e1 1c       	adc	r14, r1
     f70:	f1 1c       	adc	r15, r1
					xEntryTimeSet = pdTRUE;
     f72:	cc 24       	eor	r12, r12
     f74:	c3 94       	inc	r12

		vTaskSuspendAll();
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
     f76:	aa 24       	eor	r10, r10
     f78:	bb 24       	eor	r11, r11
     f7a:	68 94       	set
     f7c:	a2 f8       	bld	r10, 2
     f7e:	ac 0e       	add	r10, r28
     f80:	bd 1e       	adc	r11, r29
						portEXIT_CRITICAL();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
     f82:	0f 2e       	mov	r0, r31
     f84:	f1 e1       	ldi	r31, 0x11	; 17
     f86:	8f 2e       	mov	r8, r31
     f88:	99 24       	eor	r9, r9
     f8a:	f0 2d       	mov	r31, r0
     f8c:	88 0e       	add	r8, r24
     f8e:	99 1e       	adc	r9, r25
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
     f90:	0f b6       	in	r0, 0x3f	; 63
     f92:	f8 94       	cli
     f94:	0f 92       	push	r0
		{
			/* Is there data in the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
     f96:	f8 01       	movw	r30, r16
     f98:	82 8d       	ldd	r24, Z+26	; 0x1a
     f9a:	88 23       	and	r24, r24
     f9c:	51 f1       	breq	.+84     	; 0xff2 <xQueueGenericReceive+0xbc>
			{
				/* Remember our read position in case we are just peeking. */
				pcOriginalReadPosition = pxQueue->pcReadFrom;
     f9e:	e6 80       	ldd	r14, Z+6	; 0x06
     fa0:	f7 80       	ldd	r15, Z+7	; 0x07

				prvCopyDataFromQueue( pxQueue, pvBuffer );
     fa2:	c8 01       	movw	r24, r16
     fa4:	b3 01       	movw	r22, r6
     fa6:	0e 94 99 05 	call	0xb32	; 0xb32 <prvCopyDataFromQueue>

				if( xJustPeeking == pdFALSE )
     faa:	55 20       	and	r5, r5
     fac:	81 f4       	brne	.+32     	; 0xfce <xQueueGenericReceive+0x98>
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* We are actually removing data. */
					--( pxQueue->uxMessagesWaiting );
     fae:	f8 01       	movw	r30, r16
     fb0:	82 8d       	ldd	r24, Z+26	; 0x1a
     fb2:	81 50       	subi	r24, 0x01	; 1
     fb4:	82 8f       	std	Z+26, r24	; 0x1a
							pxQueue->pxMutexHolder = xTaskGetCurrentTaskHandle();
						}
					}
					#endif

					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
     fb6:	80 85       	ldd	r24, Z+8	; 0x08
     fb8:	88 23       	and	r24, r24
     fba:	b9 f0       	breq	.+46     	; 0xfea <xQueueGenericReceive+0xb4>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
     fbc:	c8 01       	movw	r24, r16
     fbe:	08 96       	adiw	r24, 0x08	; 8
     fc0:	0e 94 a5 0d 	call	0x1b4a	; 0x1b4a <xTaskRemoveFromEventList>
     fc4:	81 30       	cpi	r24, 0x01	; 1
     fc6:	89 f4       	brne	.+34     	; 0xfea <xQueueGenericReceive+0xb4>
						{
							portYIELD_WITHIN_API();
     fc8:	0e 94 e2 04 	call	0x9c4	; 0x9c4 <vPortYield>
     fcc:	0e c0       	rjmp	.+28     	; 0xfea <xQueueGenericReceive+0xb4>
				{
					traceQUEUE_PEEK( pxQueue );

					/* We are not removing the data, so reset our read
					pointer. */
					pxQueue->pcReadFrom = pcOriginalReadPosition;
     fce:	f8 01       	movw	r30, r16
     fd0:	f7 82       	std	Z+7, r15	; 0x07
     fd2:	e6 82       	std	Z+6, r14	; 0x06

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
     fd4:	81 89       	ldd	r24, Z+17	; 0x11
     fd6:	88 23       	and	r24, r24
     fd8:	41 f0       	breq	.+16     	; 0xfea <xQueueGenericReceive+0xb4>
					{
						/* Tasks that are removed from the event list will get added to
						the pending ready list as the scheduler is still suspended. */
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
     fda:	c8 01       	movw	r24, r16
     fdc:	41 96       	adiw	r24, 0x11	; 17
     fde:	0e 94 a5 0d 	call	0x1b4a	; 0x1b4a <xTaskRemoveFromEventList>
     fe2:	88 23       	and	r24, r24
     fe4:	11 f0       	breq	.+4      	; 0xfea <xQueueGenericReceive+0xb4>
						{
							/* The task waiting has a higher priority than this task. */
							portYIELD_WITHIN_API();
     fe6:	0e 94 e2 04 	call	0x9c4	; 0x9c4 <vPortYield>
						}
					}

				}

				taskEXIT_CRITICAL();
     fea:	0f 90       	pop	r0
     fec:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
     fee:	81 e0       	ldi	r24, 0x01	; 1
     ff0:	4c c0       	rjmp	.+152    	; 0x108a <xQueueGenericReceive+0x154>
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
     ff2:	8c 81       	ldd	r24, Y+4	; 0x04
     ff4:	9d 81       	ldd	r25, Y+5	; 0x05
     ff6:	00 97       	sbiw	r24, 0x00	; 0
     ff8:	21 f4       	brne	.+8      	; 0x1002 <xQueueGenericReceive+0xcc>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
     ffa:	0f 90       	pop	r0
     ffc:	0f be       	out	0x3f, r0	; 63
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
     ffe:	80 e0       	ldi	r24, 0x00	; 0
    1000:	44 c0       	rjmp	.+136    	; 0x108a <xQueueGenericReceive+0x154>
				}
				else if( xEntryTimeSet == pdFALSE )
    1002:	dd 20       	and	r13, r13
    1004:	21 f4       	brne	.+8      	; 0x100e <xQueueGenericReceive+0xd8>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    1006:	c7 01       	movw	r24, r14
    1008:	0e 94 eb 0d 	call	0x1bd6	; 0x1bd6 <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    100c:	dc 2c       	mov	r13, r12
				}
			}
		}
		taskEXIT_CRITICAL();
    100e:	0f 90       	pop	r0
    1010:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    1012:	0e 94 ff 0a 	call	0x15fe	; 0x15fe <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    1016:	0f b6       	in	r0, 0x3f	; 63
    1018:	f8 94       	cli
    101a:	0f 92       	push	r0
    101c:	f8 01       	movw	r30, r16
    101e:	85 8d       	ldd	r24, Z+29	; 0x1d
    1020:	8f 3f       	cpi	r24, 0xFF	; 255
    1022:	09 f4       	brne	.+2      	; 0x1026 <xQueueGenericReceive+0xf0>
    1024:	15 8e       	std	Z+29, r1	; 0x1d
    1026:	f8 01       	movw	r30, r16
    1028:	86 8d       	ldd	r24, Z+30	; 0x1e
    102a:	8f 3f       	cpi	r24, 0xFF	; 255
    102c:	09 f4       	brne	.+2      	; 0x1030 <xQueueGenericReceive+0xfa>
    102e:	16 8e       	std	Z+30, r1	; 0x1e
    1030:	0f 90       	pop	r0
    1032:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    1034:	c7 01       	movw	r24, r14
    1036:	b5 01       	movw	r22, r10
    1038:	0e 94 f6 0d 	call	0x1bec	; 0x1bec <xTaskCheckForTimeOut>
    103c:	88 23       	and	r24, r24
    103e:	f9 f4       	brne	.+62     	; 0x107e <xQueueGenericReceive+0x148>

static signed portBASE_TYPE prvIsQueueEmpty( const xQueueHandle pxQueue )
{
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
    1040:	0f b6       	in	r0, 0x3f	; 63
    1042:	f8 94       	cli
    1044:	0f 92       	push	r0
		xReturn = ( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0 );
    1046:	f8 01       	movw	r30, r16
    1048:	82 8d       	ldd	r24, Z+26	; 0x1a
	taskEXIT_CRITICAL();
    104a:	0f 90       	pop	r0
    104c:	0f be       	out	0x3f, r0	; 63
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    104e:	88 23       	and	r24, r24
    1050:	81 f4       	brne	.+32     	; 0x1072 <xQueueGenericReceive+0x13c>
						portEXIT_CRITICAL();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    1052:	6c 81       	ldd	r22, Y+4	; 0x04
    1054:	7d 81       	ldd	r23, Y+5	; 0x05
    1056:	c4 01       	movw	r24, r8
    1058:	0e 94 88 0d 	call	0x1b10	; 0x1b10 <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
    105c:	c8 01       	movw	r24, r16
    105e:	0e 94 fb 05 	call	0xbf6	; 0xbf6 <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
    1062:	0e 94 e1 0b 	call	0x17c2	; 0x17c2 <xTaskResumeAll>
    1066:	88 23       	and	r24, r24
    1068:	09 f0       	breq	.+2      	; 0x106c <xQueueGenericReceive+0x136>
    106a:	92 cf       	rjmp	.-220    	; 0xf90 <xQueueGenericReceive+0x5a>
				{
					portYIELD_WITHIN_API();
    106c:	0e 94 e2 04 	call	0x9c4	; 0x9c4 <vPortYield>
    1070:	8f cf       	rjmp	.-226    	; 0xf90 <xQueueGenericReceive+0x5a>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    1072:	c8 01       	movw	r24, r16
    1074:	0e 94 fb 05 	call	0xbf6	; 0xbf6 <prvUnlockQueue>
				( void ) xTaskResumeAll();
    1078:	0e 94 e1 0b 	call	0x17c2	; 0x17c2 <xTaskResumeAll>
    107c:	89 cf       	rjmp	.-238    	; 0xf90 <xQueueGenericReceive+0x5a>
			}
		}
		else
		{
			prvUnlockQueue( pxQueue );
    107e:	c8 01       	movw	r24, r16
    1080:	0e 94 fb 05 	call	0xbf6	; 0xbf6 <prvUnlockQueue>
			( void ) xTaskResumeAll();
    1084:	0e 94 e1 0b 	call	0x17c2	; 0x17c2 <xTaskResumeAll>
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
    1088:	80 e0       	ldi	r24, 0x00	; 0
		}
	}
}
    108a:	0f 90       	pop	r0
    108c:	0f 90       	pop	r0
    108e:	0f 90       	pop	r0
    1090:	0f 90       	pop	r0
    1092:	0f 90       	pop	r0
    1094:	cf 91       	pop	r28
    1096:	df 91       	pop	r29
    1098:	1f 91       	pop	r17
    109a:	0f 91       	pop	r16
    109c:	ff 90       	pop	r15
    109e:	ef 90       	pop	r14
    10a0:	df 90       	pop	r13
    10a2:	cf 90       	pop	r12
    10a4:	bf 90       	pop	r11
    10a6:	af 90       	pop	r10
    10a8:	9f 90       	pop	r9
    10aa:	8f 90       	pop	r8
    10ac:	7f 90       	pop	r7
    10ae:	6f 90       	pop	r6
    10b0:	5f 90       	pop	r5
    10b2:	08 95       	ret

000010b4 <xQueueReceiveFromISR>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueReceiveFromISR( xQueueHandle pxQueue, void * const pvBuffer, signed portBASE_TYPE *pxTaskWoken )
{
    10b4:	0f 93       	push	r16
    10b6:	1f 93       	push	r17
    10b8:	cf 93       	push	r28
    10ba:	df 93       	push	r29
    10bc:	ec 01       	movw	r28, r24
    10be:	8a 01       	movw	r16, r20
	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( unsigned portBASE_TYPE ) 0U ) ) );

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		/* We cannot block from an ISR, so check there is data available. */
		if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
    10c0:	8a 8d       	ldd	r24, Y+26	; 0x1a
    10c2:	88 23       	and	r24, r24
    10c4:	d1 f0       	breq	.+52     	; 0x10fa <xQueueReceiveFromISR+0x46>
		{
			traceQUEUE_RECEIVE_FROM_ISR( pxQueue );

			prvCopyDataFromQueue( pxQueue, pvBuffer );
    10c6:	ce 01       	movw	r24, r28
    10c8:	0e 94 99 05 	call	0xb32	; 0xb32 <prvCopyDataFromQueue>
			--( pxQueue->uxMessagesWaiting );
    10cc:	8a 8d       	ldd	r24, Y+26	; 0x1a
    10ce:	81 50       	subi	r24, 0x01	; 1
    10d0:	8a 8f       	std	Y+26, r24	; 0x1a

			/* If the queue is locked we will not modify the event list.  Instead
			we update the lock count so the task that unlocks the queue will know
			that an ISR has removed data while the queue was locked. */
			if( pxQueue->xRxLock == queueUNLOCKED )
    10d2:	8d 8d       	ldd	r24, Y+29	; 0x1d
    10d4:	8f 3f       	cpi	r24, 0xFF	; 255
    10d6:	69 f4       	brne	.+26     	; 0x10f2 <xQueueReceiveFromISR+0x3e>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    10d8:	88 85       	ldd	r24, Y+8	; 0x08
    10da:	88 23       	and	r24, r24
    10dc:	81 f0       	breq	.+32     	; 0x10fe <xQueueReceiveFromISR+0x4a>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    10de:	ce 01       	movw	r24, r28
    10e0:	08 96       	adiw	r24, 0x08	; 8
    10e2:	0e 94 a5 0d 	call	0x1b4a	; 0x1b4a <xTaskRemoveFromEventList>
    10e6:	88 23       	and	r24, r24
    10e8:	61 f0       	breq	.+24     	; 0x1102 <xQueueReceiveFromISR+0x4e>
					{
						/* The task waiting has a higher priority than us so
						force a context switch. */
						*pxTaskWoken = pdTRUE;
    10ea:	81 e0       	ldi	r24, 0x01	; 1
    10ec:	f8 01       	movw	r30, r16
    10ee:	80 83       	st	Z, r24
    10f0:	09 c0       	rjmp	.+18     	; 0x1104 <xQueueReceiveFromISR+0x50>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was removed while it was locked. */
				++( pxQueue->xRxLock );
    10f2:	8f 5f       	subi	r24, 0xFF	; 255
    10f4:	8d 8f       	std	Y+29, r24	; 0x1d
			}

			xReturn = pdPASS;
    10f6:	81 e0       	ldi	r24, 0x01	; 1
    10f8:	05 c0       	rjmp	.+10     	; 0x1104 <xQueueReceiveFromISR+0x50>
		}
		else
		{
			xReturn = pdFAIL;
    10fa:	80 e0       	ldi	r24, 0x00	; 0
    10fc:	03 c0       	rjmp	.+6      	; 0x1104 <xQueueReceiveFromISR+0x50>
				/* Increment the lock count so the task that unlocks the queue
				knows that data was removed while it was locked. */
				++( pxQueue->xRxLock );
			}

			xReturn = pdPASS;
    10fe:	81 e0       	ldi	r24, 0x01	; 1
    1100:	01 c0       	rjmp	.+2      	; 0x1104 <xQueueReceiveFromISR+0x50>
    1102:	81 e0       	ldi	r24, 0x01	; 1
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    1104:	df 91       	pop	r29
    1106:	cf 91       	pop	r28
    1108:	1f 91       	pop	r17
    110a:	0f 91       	pop	r16
    110c:	08 95       	ret

0000110e <uxQueueMessagesWaiting>:
{
unsigned portBASE_TYPE uxReturn;

	configASSERT( pxQueue );

	taskENTER_CRITICAL();
    110e:	0f b6       	in	r0, 0x3f	; 63
    1110:	f8 94       	cli
    1112:	0f 92       	push	r0
		uxReturn = pxQueue->uxMessagesWaiting;
    1114:	fc 01       	movw	r30, r24
    1116:	82 8d       	ldd	r24, Z+26	; 0x1a
	taskEXIT_CRITICAL();
    1118:	0f 90       	pop	r0
    111a:	0f be       	out	0x3f, r0	; 63

	return uxReturn;
}
    111c:	08 95       	ret

0000111e <uxQueueMessagesWaitingFromISR>:
{
unsigned portBASE_TYPE uxReturn;

	configASSERT( pxQueue );

	uxReturn = pxQueue->uxMessagesWaiting;
    111e:	fc 01       	movw	r30, r24
    1120:	82 8d       	ldd	r24, Z+26	; 0x1a

	return uxReturn;
}
    1122:	08 95       	ret

00001124 <vQueueDelete>:
/*-----------------------------------------------------------*/

void vQueueDelete( xQueueHandle pxQueue )
{
    1124:	cf 93       	push	r28
    1126:	df 93       	push	r29
    1128:	ec 01       	movw	r28, r24
	configASSERT( pxQueue );

	traceQUEUE_DELETE( pxQueue );
	vQueueUnregisterQueue( pxQueue );
	vPortFree( pxQueue->pcHead );
    112a:	88 81       	ld	r24, Y
    112c:	99 81       	ldd	r25, Y+1	; 0x01
    112e:	0e 94 ae 02 	call	0x55c	; 0x55c <vPortFree>
	vPortFree( pxQueue );
    1132:	ce 01       	movw	r24, r28
    1134:	0e 94 ae 02 	call	0x55c	; 0x55c <vPortFree>
}
    1138:	df 91       	pop	r29
    113a:	cf 91       	pop	r28
    113c:	08 95       	ret

0000113e <xQueueIsQueueEmptyFromISR>:
signed portBASE_TYPE xQueueIsQueueEmptyFromISR( const xQueueHandle pxQueue )
{
signed portBASE_TYPE xReturn;

	configASSERT( pxQueue );
	xReturn = ( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0 );
    113e:	fc 01       	movw	r30, r24
    1140:	92 8d       	ldd	r25, Z+26	; 0x1a
    1142:	81 e0       	ldi	r24, 0x01	; 1
    1144:	91 11       	cpse	r25, r1
    1146:	80 e0       	ldi	r24, 0x00	; 0

	return xReturn;
}
    1148:	08 95       	ret

0000114a <xQueueIsQueueFullFromISR>:
	return xReturn;
}
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueIsQueueFullFromISR( const xQueueHandle pxQueue )
{
    114a:	fc 01       	movw	r30, r24
signed portBASE_TYPE xReturn;

	configASSERT( pxQueue );
	xReturn = ( pxQueue->uxMessagesWaiting == pxQueue->uxLength );
    114c:	22 8d       	ldd	r18, Z+26	; 0x1a
    114e:	81 e0       	ldi	r24, 0x01	; 1
    1150:	93 8d       	ldd	r25, Z+27	; 0x1b
    1152:	29 13       	cpse	r18, r25
    1154:	80 e0       	ldi	r24, 0x00	; 0

	return xReturn;
}
    1156:	08 95       	ret

00001158 <LcdTask>:
	}
}

/*LCD task function that responsible about printing buffer content*/
void LcdTask( void * pvParameters )
{
    1158:	ef 92       	push	r14
    115a:	ff 92       	push	r15
    115c:	0f 93       	push	r16
    115e:	1f 93       	push	r17
    1160:	df 93       	push	r29
    1162:	cf 93       	push	r28
    1164:	0f 92       	push	r0
    1166:	cd b7       	in	r28, 0x3d	; 61
    1168:	de b7       	in	r29, 0x3e	; 62
	unsigned char ret;
	static unsigned char counter=0;
	for (;;)
	{
		
		ret = xQueueReceive(buffer,&val,portMAX_DELAY);
    116a:	8e 01       	movw	r16, r28
    116c:	0f 5f       	subi	r16, 0xFF	; 255
    116e:	1f 4f       	sbci	r17, 0xFF	; 255
		{
			counter++;
			if (counter>6)
			{
				lcd_clrScreen();
				lcd_dispString("wait");
    1170:	0f 2e       	mov	r0, r31
    1172:	f2 e7       	ldi	r31, 0x72	; 114
    1174:	ef 2e       	mov	r14, r31
    1176:	f0 e0       	ldi	r31, 0x00	; 0
    1178:	ff 2e       	mov	r15, r31
    117a:	f0 2d       	mov	r31, r0
	unsigned char ret;
	static unsigned char counter=0;
	for (;;)
	{
		
		ret = xQueueReceive(buffer,&val,portMAX_DELAY);
    117c:	80 91 71 03 	lds	r24, 0x0371
    1180:	90 91 72 03 	lds	r25, 0x0372
    1184:	b8 01       	movw	r22, r16
    1186:	4f ef       	ldi	r20, 0xFF	; 255
    1188:	5f ef       	ldi	r21, 0xFF	; 255
    118a:	20 e0       	ldi	r18, 0x00	; 0
    118c:	0e 94 9b 07 	call	0xf36	; 0xf36 <xQueueGenericReceive>
		
		if(ret==pdTRUE)
    1190:	81 30       	cpi	r24, 0x01	; 1
    1192:	a1 f7       	brne	.-24     	; 0x117c <LcdTask+0x24>
		{
			counter++;
    1194:	80 91 26 03 	lds	r24, 0x0326
    1198:	8f 5f       	subi	r24, 0xFF	; 255
    119a:	80 93 26 03 	sts	0x0326, r24
			if (counter>6)
    119e:	87 30       	cpi	r24, 0x07	; 7
    11a0:	30 f0       	brcs	.+12     	; 0x11ae <LcdTask+0x56>
			{
				lcd_clrScreen();
    11a2:	0e 94 2c 03 	call	0x658	; 0x658 <lcd_clrScreen>
				lcd_dispString("wait");
    11a6:	c7 01       	movw	r24, r14
    11a8:	0e 94 30 03 	call	0x660	; 0x660 <lcd_dispString>
    11ac:	e7 cf       	rjmp	.-50     	; 0x117c <LcdTask+0x24>
			}
			else
		{
				lcd_displayChar(val);				
    11ae:	89 81       	ldd	r24, Y+1	; 0x01
    11b0:	0e 94 f9 02 	call	0x5f2	; 0x5f2 <lcd_displayChar>
    11b4:	e3 cf       	rjmp	.-58     	; 0x117c <LcdTask+0x24>

000011b6 <KeypadTask>:
	
}

/*keypad task function it is a periodic task with period = 50 ms  */
void KeypadTask( void * pvParameters )
{
    11b6:	0f 93       	push	r16
    11b8:	1f 93       	push	r17
    11ba:	df 93       	push	r29
    11bc:	cf 93       	push	r28
    11be:	0f 92       	push	r0
    11c0:	cd b7       	in	r28, 0x3d	; 61
    11c2:	de b7       	in	r29, 0x3e	; 62
		val=getPressed();
		/*check if no key pressed*/
		if (val != NOT_PRESSED)
		{
			/*if a key is pressed send the value to buffer" message queue"*/
			xQueueSend(buffer,&val,portMAX_DELAY);
    11c4:	8e 01       	movw	r16, r28
    11c6:	0f 5f       	subi	r16, 0xFF	; 255
    11c8:	1f 4f       	sbci	r17, 0xFF	; 255
	unsigned char val; 
	
	for (;;)
	{
		/*get pressed key value*/
		val=getPressed();
    11ca:	0e 94 ef 03 	call	0x7de	; 0x7de <getPressed>
    11ce:	89 83       	std	Y+1, r24	; 0x01
		/*check if no key pressed*/
		if (val != NOT_PRESSED)
    11d0:	8f 3f       	cpi	r24, 0xFF	; 255
    11d2:	51 f0       	breq	.+20     	; 0x11e8 <KeypadTask+0x32>
		{
			/*if a key is pressed send the value to buffer" message queue"*/
			xQueueSend(buffer,&val,portMAX_DELAY);
    11d4:	80 91 71 03 	lds	r24, 0x0371
    11d8:	90 91 72 03 	lds	r25, 0x0372
    11dc:	b8 01       	movw	r22, r16
    11de:	4f ef       	ldi	r20, 0xFF	; 255
    11e0:	5f ef       	ldi	r21, 0xFF	; 255
    11e2:	20 e0       	ldi	r18, 0x00	; 0
    11e4:	0e 94 c3 06 	call	0xd86	; 0xd86 <xQueueGenericSend>
		}
		/*delay to make task a periodic task every 50 ms */
		vTaskDelay(50);
    11e8:	82 e3       	ldi	r24, 0x32	; 50
    11ea:	90 e0       	ldi	r25, 0x00	; 0
    11ec:	0e 94 ac 0c 	call	0x1958	; 0x1958 <vTaskDelay>
	}
    11f0:	ec cf       	rjmp	.-40     	; 0x11ca <KeypadTask+0x14>

000011f2 <main>:

/*create Message Queue Handle*/
xQueueHandle buffer;

int main(void)
{
    11f2:	af 92       	push	r10
    11f4:	bf 92       	push	r11
    11f6:	cf 92       	push	r12
    11f8:	df 92       	push	r13
    11fa:	ef 92       	push	r14
    11fc:	ff 92       	push	r15
    11fe:	0f 93       	push	r16
    /*init LCD Driver*/
	lcd_init();
    1200:	0e 94 e8 02 	call	0x5d0	; 0x5d0 <lcd_init>
	
	/*init Keypad driver */
	keypad_init();
    1204:	0e 94 ea 03 	call	0x7d4	; 0x7d4 <keypad_init>
	
	/*create message queue */
	
	buffer = xQueueCreate(6,sizeof(unsigned char));
    1208:	86 e0       	ldi	r24, 0x06	; 6
    120a:	61 e0       	ldi	r22, 0x01	; 1
    120c:	0e 94 47 06 	call	0xc8e	; 0xc8e <xQueueCreate>
    1210:	90 93 72 03 	sts	0x0372, r25
    1214:	80 93 71 03 	sts	0x0371, r24
	
	/*create LCD task*/
	xTaskCreate(LcdTask,"LcdTask",configMINIMAL_STACK_SIZE,NULL,LCD_TASK_PR,NULL);	
    1218:	8c ea       	ldi	r24, 0xAC	; 172
    121a:	98 e0       	ldi	r25, 0x08	; 8
    121c:	67 e7       	ldi	r22, 0x77	; 119
    121e:	70 e0       	ldi	r23, 0x00	; 0
    1220:	45 e5       	ldi	r20, 0x55	; 85
    1222:	50 e0       	ldi	r21, 0x00	; 0
    1224:	20 e0       	ldi	r18, 0x00	; 0
    1226:	30 e0       	ldi	r19, 0x00	; 0
    1228:	01 e0       	ldi	r16, 0x01	; 1
    122a:	ee 24       	eor	r14, r14
    122c:	ff 24       	eor	r15, r15
    122e:	cc 24       	eor	r12, r12
    1230:	dd 24       	eor	r13, r13
    1232:	aa 24       	eor	r10, r10
    1234:	bb 24       	eor	r11, r11
    1236:	0e 94 6b 09 	call	0x12d6	; 0x12d6 <xTaskGenericCreate>
	
	/*create KeyPad Task*/
	xTaskCreate(KeypadTask,"KeypadTask",configMINIMAL_STACK_SIZE,NULL,KEYPAD_TASK_PR,NULL);
    123a:	8b ed       	ldi	r24, 0xDB	; 219
    123c:	98 e0       	ldi	r25, 0x08	; 8
    123e:	6f e7       	ldi	r22, 0x7F	; 127
    1240:	70 e0       	ldi	r23, 0x00	; 0
    1242:	45 e5       	ldi	r20, 0x55	; 85
    1244:	50 e0       	ldi	r21, 0x00	; 0
    1246:	20 e0       	ldi	r18, 0x00	; 0
    1248:	30 e0       	ldi	r19, 0x00	; 0
    124a:	02 e0       	ldi	r16, 0x02	; 2
    124c:	0e 94 6b 09 	call	0x12d6	; 0x12d6 <xTaskGenericCreate>
	
	/*start OS*/
	vTaskStartScheduler();
    1250:	0e 94 ce 0a 	call	0x159c	; 0x159c <vTaskStartScheduler>
	
}
    1254:	80 e0       	ldi	r24, 0x00	; 0
    1256:	90 e0       	ldi	r25, 0x00	; 0
    1258:	0f 91       	pop	r16
    125a:	ff 90       	pop	r15
    125c:	ef 90       	pop	r14
    125e:	df 90       	pop	r13
    1260:	cf 90       	pop	r12
    1262:	bf 90       	pop	r11
    1264:	af 90       	pop	r10
    1266:	08 95       	ret

00001268 <prvAddCurrentTaskToDelayedList>:
	#endif
}
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( portTickType xTimeToWake )
{
    1268:	cf 93       	push	r28
    126a:	df 93       	push	r29
    126c:	ec 01       	movw	r28, r24
	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
    126e:	e0 91 27 03 	lds	r30, 0x0327
    1272:	f0 91 28 03 	lds	r31, 0x0328
    1276:	93 83       	std	Z+3, r25	; 0x03
    1278:	82 83       	std	Z+2, r24	; 0x02

	if( xTimeToWake < xTickCount )
    127a:	80 91 2b 03 	lds	r24, 0x032B
    127e:	90 91 2c 03 	lds	r25, 0x032C
    1282:	c8 17       	cp	r28, r24
    1284:	d9 07       	cpc	r29, r25
    1286:	68 f4       	brcc	.+26     	; 0x12a2 <prvAddCurrentTaskToDelayedList+0x3a>
	{
		/* Wake time has overflowed.  Place this item in the overflow list. */
		vListInsert( ( xList * ) pxOverflowDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    1288:	80 91 4a 03 	lds	r24, 0x034A
    128c:	90 91 4b 03 	lds	r25, 0x034B
    1290:	60 91 27 03 	lds	r22, 0x0327
    1294:	70 91 28 03 	lds	r23, 0x0328
    1298:	6e 5f       	subi	r22, 0xFE	; 254
    129a:	7f 4f       	sbci	r23, 0xFF	; 255
    129c:	0e 94 85 03 	call	0x70a	; 0x70a <vListInsert>
    12a0:	17 c0       	rjmp	.+46     	; 0x12d0 <prvAddCurrentTaskToDelayedList+0x68>
	}
	else
	{
		/* The wake time has not overflowed, so we can use the current block list. */
		vListInsert( ( xList * ) pxDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    12a2:	80 91 4c 03 	lds	r24, 0x034C
    12a6:	90 91 4d 03 	lds	r25, 0x034D
    12aa:	60 91 27 03 	lds	r22, 0x0327
    12ae:	70 91 28 03 	lds	r23, 0x0328
    12b2:	6e 5f       	subi	r22, 0xFE	; 254
    12b4:	7f 4f       	sbci	r23, 0xFF	; 255
    12b6:	0e 94 85 03 	call	0x70a	; 0x70a <vListInsert>

		/* If the task entering the blocked state was placed at the head of the
		list of blocked tasks then xNextTaskUnblockTime needs to be updated
		too. */
		if( xTimeToWake < xNextTaskUnblockTime )
    12ba:	80 91 8f 00 	lds	r24, 0x008F
    12be:	90 91 90 00 	lds	r25, 0x0090
    12c2:	c8 17       	cp	r28, r24
    12c4:	d9 07       	cpc	r29, r25
    12c6:	20 f4       	brcc	.+8      	; 0x12d0 <prvAddCurrentTaskToDelayedList+0x68>
		{
			xNextTaskUnblockTime = xTimeToWake;
    12c8:	d0 93 90 00 	sts	0x0090, r29
    12cc:	c0 93 8f 00 	sts	0x008F, r28
		}
	}
}
    12d0:	df 91       	pop	r29
    12d2:	cf 91       	pop	r28
    12d4:	08 95       	ret

000012d6 <xTaskGenericCreate>:
/*-----------------------------------------------------------
 * TASK CREATION API documented in task.h
 *----------------------------------------------------------*/

signed portBASE_TYPE xTaskGenericCreate( pdTASK_CODE pxTaskCode, const signed char * const pcName, unsigned short usStackDepth, void *pvParameters, unsigned portBASE_TYPE uxPriority, xTaskHandle *pxCreatedTask, portSTACK_TYPE *puxStackBuffer, const xMemoryRegion * const xRegions )
{
    12d6:	2f 92       	push	r2
    12d8:	3f 92       	push	r3
    12da:	4f 92       	push	r4
    12dc:	5f 92       	push	r5
    12de:	6f 92       	push	r6
    12e0:	7f 92       	push	r7
    12e2:	8f 92       	push	r8
    12e4:	9f 92       	push	r9
    12e6:	bf 92       	push	r11
    12e8:	cf 92       	push	r12
    12ea:	df 92       	push	r13
    12ec:	ef 92       	push	r14
    12ee:	ff 92       	push	r15
    12f0:	0f 93       	push	r16
    12f2:	1f 93       	push	r17
    12f4:	cf 93       	push	r28
    12f6:	df 93       	push	r29
    12f8:	1c 01       	movw	r2, r24
    12fa:	3b 01       	movw	r6, r22
    12fc:	ea 01       	movw	r28, r20
    12fe:	29 01       	movw	r4, r18
    1300:	b0 2e       	mov	r11, r16
    1302:	47 01       	movw	r8, r14
{
tskTCB *pxNewTCB;

	/* Allocate space for the TCB.  Where the memory comes from depends on
	the implementation of the port malloc function. */
	pxNewTCB = ( tskTCB * ) pvPortMalloc( sizeof( tskTCB ) );
    1304:	81 e2       	ldi	r24, 0x21	; 33
    1306:	90 e0       	ldi	r25, 0x00	; 0
    1308:	0e 94 80 02 	call	0x500	; 0x500 <pvPortMalloc>
    130c:	08 2f       	mov	r16, r24
    130e:	19 2f       	mov	r17, r25

	if( pxNewTCB != NULL )
    1310:	01 15       	cp	r16, r1
    1312:	11 05       	cpc	r17, r1
    1314:	09 f4       	brne	.+2      	; 0x1318 <xTaskGenericCreate+0x42>
    1316:	d9 c0       	rjmp	.+434    	; 0x14ca <xTaskGenericCreate+0x1f4>
	{
		/* Allocate space for the stack used by the task being created.
		The base of the stack memory stored in the TCB so the task can
		be deleted later if required. */
		pxNewTCB->pxStack = ( portSTACK_TYPE * ) pvPortMallocAligned( ( ( ( size_t )usStackDepth ) * sizeof( portSTACK_TYPE ) ), puxStackBuffer );
    1318:	c1 14       	cp	r12, r1
    131a:	d1 04       	cpc	r13, r1
    131c:	09 f0       	breq	.+2      	; 0x1320 <xTaskGenericCreate+0x4a>
    131e:	ec c0       	rjmp	.+472    	; 0x14f8 <xTaskGenericCreate+0x222>
    1320:	ce 01       	movw	r24, r28
    1322:	0e 94 80 02 	call	0x500	; 0x500 <pvPortMalloc>
    1326:	c8 2e       	mov	r12, r24
    1328:	d9 2e       	mov	r13, r25
    132a:	f8 01       	movw	r30, r16
    132c:	87 8b       	std	Z+23, r24	; 0x17
    132e:	90 8f       	std	Z+24, r25	; 0x18

		if( pxNewTCB->pxStack == NULL )
    1330:	c1 14       	cp	r12, r1
    1332:	d1 04       	cpc	r13, r1
    1334:	29 f4       	brne	.+10     	; 0x1340 <xTaskGenericCreate+0x6a>
		{
			/* Could not allocate the stack.  Delete the allocated TCB. */
			vPortFree( pxNewTCB );
    1336:	c8 01       	movw	r24, r16
    1338:	0e 94 ae 02 	call	0x55c	; 0x55c <vPortFree>
		}
		taskEXIT_CRITICAL();
	}
	else
	{
		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
    133c:	8f ef       	ldi	r24, 0xFF	; 255
    133e:	ca c0       	rjmp	.+404    	; 0x14d4 <xTaskGenericCreate+0x1fe>
			pxNewTCB = NULL;
		}
		else
		{
			/* Just to help debugging. */
			memset( pxNewTCB->pxStack, ( int ) tskSTACK_FILL_BYTE, ( size_t ) usStackDepth * sizeof( portSTACK_TYPE ) );
    1340:	8c 2d       	mov	r24, r12
    1342:	9d 2d       	mov	r25, r13
    1344:	65 ea       	ldi	r22, 0xA5	; 165
    1346:	70 e0       	ldi	r23, 0x00	; 0
    1348:	7e 01       	movw	r14, r28
    134a:	4c 2f       	mov	r20, r28
    134c:	5f 2d       	mov	r21, r15
    134e:	0e 94 39 0e 	call	0x1c72	; 0x1c72 <memset>
		stack grows from high memory to low (as per the 80x86) or visa versa.
		portSTACK_GROWTH is used to make the result positive or negative as
		required by the port. */
		#if( portSTACK_GROWTH < 0 )
		{
			pxTopOfStack = pxNewTCB->pxStack + ( usStackDepth - ( unsigned short ) 1 );
    1352:	21 97       	sbiw	r28, 0x01	; 1
    1354:	f8 01       	movw	r30, r16
    1356:	87 89       	ldd	r24, Z+23	; 0x17
    1358:	90 8d       	ldd	r25, Z+24	; 0x18
    135a:	c8 0f       	add	r28, r24
    135c:	d9 1f       	adc	r29, r25
{
	/* Store the function name in the TCB. */
	#if configMAX_TASK_NAME_LEN > 1
	{
		/* Don't bring strncpy into the build unnecessarily. */
		strncpy( ( char * ) pxTCB->pcTaskName, ( const char * ) pcName, ( unsigned short ) configMAX_TASK_NAME_LEN );
    135e:	c8 01       	movw	r24, r16
    1360:	49 96       	adiw	r24, 0x19	; 25
    1362:	b3 01       	movw	r22, r6
    1364:	48 e0       	ldi	r20, 0x08	; 8
    1366:	50 e0       	ldi	r21, 0x00	; 0
    1368:	0e 94 40 0e 	call	0x1c80	; 0x1c80 <strncpy>
	}
	#endif
	pxTCB->pcTaskName[ ( unsigned short ) configMAX_TASK_NAME_LEN - ( unsigned short ) 1 ] = ( signed char ) '\0';
    136c:	f8 01       	movw	r30, r16
    136e:	10 a2       	std	Z+32, r1	; 0x20
    1370:	cb 2c       	mov	r12, r11
    1372:	bb 20       	and	r11, r11
    1374:	11 f0       	breq	.+4      	; 0x137a <xTaskGenericCreate+0xa4>
    1376:	cc 24       	eor	r12, r12
    1378:	c3 94       	inc	r12
	if( uxPriority >= configMAX_PRIORITIES )
	{
		uxPriority = configMAX_PRIORITIES - ( unsigned portBASE_TYPE ) 1U;
	}

	pxTCB->uxPriority = uxPriority;
    137a:	f8 01       	movw	r30, r16
    137c:	c6 8a       	std	Z+22, r12	; 0x16
	{
		pxTCB->uxBasePriority = uxPriority;
	}
	#endif

	vListInitialiseItem( &( pxTCB->xGenericListItem ) );
    137e:	ee 24       	eor	r14, r14
    1380:	ff 24       	eor	r15, r15
    1382:	68 94       	set
    1384:	e1 f8       	bld	r14, 1
    1386:	e0 0e       	add	r14, r16
    1388:	f1 1e       	adc	r15, r17
    138a:	c7 01       	movw	r24, r14
    138c:	0e 94 5a 03 	call	0x6b4	; 0x6b4 <vListInitialiseItem>
	vListInitialiseItem( &( pxTCB->xEventListItem ) );
    1390:	c8 01       	movw	r24, r16
    1392:	0c 96       	adiw	r24, 0x0c	; 12
    1394:	0e 94 5a 03 	call	0x6b4	; 0x6b4 <vListInitialiseItem>

	/* Set the pxTCB as a link back from the xListItem.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxTCB->xGenericListItem ), pxTCB );
    1398:	f8 01       	movw	r30, r16
    139a:	11 87       	std	Z+9, r17	; 0x09
    139c:	00 87       	std	Z+8, r16	; 0x08

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) uxPriority );
    139e:	82 e0       	ldi	r24, 0x02	; 2
    13a0:	90 e0       	ldi	r25, 0x00	; 0
    13a2:	8c 19       	sub	r24, r12
    13a4:	91 09       	sbc	r25, r1
    13a6:	95 87       	std	Z+13, r25	; 0x0d
    13a8:	84 87       	std	Z+12, r24	; 0x0c
	listSET_LIST_ITEM_OWNER( &( pxTCB->xEventListItem ), pxTCB );
    13aa:	13 8b       	std	Z+19, r17	; 0x13
    13ac:	02 8b       	std	Z+18, r16	; 0x12
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged );
		}
		#else
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
    13ae:	ce 01       	movw	r24, r28
    13b0:	b1 01       	movw	r22, r2
    13b2:	a2 01       	movw	r20, r4
    13b4:	0e 94 61 04 	call	0x8c2	; 0x8c2 <pxPortInitialiseStack>
    13b8:	f8 01       	movw	r30, r16
    13ba:	91 83       	std	Z+1, r25	; 0x01
    13bc:	80 83       	st	Z, r24
		#endif

		/* Check the alignment of the initialised stack. */
		configASSERT( ( ( ( unsigned long ) pxNewTCB->pxTopOfStack & ( unsigned long ) portBYTE_ALIGNMENT_MASK ) == 0UL ) );

		if( ( void * ) pxCreatedTask != NULL )
    13be:	81 14       	cp	r8, r1
    13c0:	91 04       	cpc	r9, r1
    13c2:	19 f0       	breq	.+6      	; 0x13ca <xTaskGenericCreate+0xf4>
		{
			/* Pass the TCB out - in an anonymous way.  The calling function/
			task can use this as a handle to delete the task later if
			required.*/
			*pxCreatedTask = ( xTaskHandle ) pxNewTCB;
    13c4:	f4 01       	movw	r30, r8
    13c6:	11 83       	std	Z+1, r17	; 0x01
    13c8:	00 83       	st	Z, r16
		}
		
		/* We are going to manipulate the task queues to add this task to a
		ready list, so must make sure no interrupts occur. */
		taskENTER_CRITICAL();
    13ca:	0f b6       	in	r0, 0x3f	; 63
    13cc:	f8 94       	cli
    13ce:	0f 92       	push	r0
		{
			uxCurrentNumberOfTasks++;
    13d0:	80 91 4f 03 	lds	r24, 0x034F
    13d4:	8f 5f       	subi	r24, 0xFF	; 255
    13d6:	80 93 4f 03 	sts	0x034F, r24
			if( pxCurrentTCB == NULL )
    13da:	80 91 27 03 	lds	r24, 0x0327
    13de:	90 91 28 03 	lds	r25, 0x0328
    13e2:	00 97       	sbiw	r24, 0x00	; 0
    13e4:	81 f5       	brne	.+96     	; 0x1446 <xTaskGenericCreate+0x170>
			{
				/* There are no other tasks, or all the other tasks are in
				the suspended state - make this the current task. */
				pxCurrentTCB =  pxNewTCB;
    13e6:	10 93 28 03 	sts	0x0328, r17
    13ea:	00 93 27 03 	sts	0x0327, r16

				if( uxCurrentNumberOfTasks == ( unsigned portBASE_TYPE ) 1 )
    13ee:	80 91 4f 03 	lds	r24, 0x034F
    13f2:	81 30       	cpi	r24, 0x01	; 1
    13f4:	b9 f5       	brne	.+110    	; 0x1464 <xTaskGenericCreate+0x18e>
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
    13f6:	cf e2       	ldi	r28, 0x2F	; 47
    13f8:	d3 e0       	ldi	r29, 0x03	; 3
    13fa:	ce 01       	movw	r24, r28
    13fc:	0e 94 4c 03 	call	0x698	; 0x698 <vListInitialise>
    1400:	ce 01       	movw	r24, r28
    1402:	09 96       	adiw	r24, 0x09	; 9
    1404:	0e 94 4c 03 	call	0x698	; 0x698 <vListInitialise>
	}

	vListInitialise( ( xList * ) &xDelayedTaskList1 );
    1408:	cd e5       	ldi	r28, 0x5D	; 93
    140a:	d3 e0       	ldi	r29, 0x03	; 3
    140c:	ce 01       	movw	r24, r28
    140e:	0e 94 4c 03 	call	0x698	; 0x698 <vListInitialise>
	vListInitialise( ( xList * ) &xDelayedTaskList2 );
    1412:	0f 2e       	mov	r0, r31
    1414:	f6 e6       	ldi	r31, 0x66	; 102
    1416:	cf 2e       	mov	r12, r31
    1418:	f3 e0       	ldi	r31, 0x03	; 3
    141a:	df 2e       	mov	r13, r31
    141c:	f0 2d       	mov	r31, r0
    141e:	c6 01       	movw	r24, r12
    1420:	0e 94 4c 03 	call	0x698	; 0x698 <vListInitialise>
	vListInitialise( ( xList * ) &xPendingReadyList );
    1424:	81 e4       	ldi	r24, 0x41	; 65
    1426:	93 e0       	ldi	r25, 0x03	; 3
    1428:	0e 94 4c 03 	call	0x698	; 0x698 <vListInitialise>

	#if ( INCLUDE_vTaskDelete == 1 )
	{
		vListInitialise( ( xList * ) &xTasksWaitingTermination );
    142c:	82 e5       	ldi	r24, 0x52	; 82
    142e:	93 e0       	ldi	r25, 0x03	; 3
    1430:	0e 94 4c 03 	call	0x698	; 0x698 <vListInitialise>
	}
	#endif

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
    1434:	d0 93 4d 03 	sts	0x034D, r29
    1438:	c0 93 4c 03 	sts	0x034C, r28
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
    143c:	d0 92 4b 03 	sts	0x034B, r13
    1440:	c0 92 4a 03 	sts	0x034A, r12
    1444:	0f c0       	rjmp	.+30     	; 0x1464 <xTaskGenericCreate+0x18e>
			else
			{
				/* If the scheduler is not already running, make this task the
				current task if it is the highest priority task to be created
				so far. */
				if( xSchedulerRunning == pdFALSE )
    1446:	80 91 50 03 	lds	r24, 0x0350
    144a:	88 23       	and	r24, r24
    144c:	59 f4       	brne	.+22     	; 0x1464 <xTaskGenericCreate+0x18e>
				{
					if( pxCurrentTCB->uxPriority <= uxPriority )
    144e:	e0 91 27 03 	lds	r30, 0x0327
    1452:	f0 91 28 03 	lds	r31, 0x0328
    1456:	86 89       	ldd	r24, Z+22	; 0x16
    1458:	b8 16       	cp	r11, r24
    145a:	20 f0       	brcs	.+8      	; 0x1464 <xTaskGenericCreate+0x18e>
					{
						pxCurrentTCB = pxNewTCB;
    145c:	10 93 28 03 	sts	0x0328, r17
    1460:	00 93 27 03 	sts	0x0327, r16
				}
			}

			/* Remember the top priority to make context switching faster.  Use
			the priority in pxNewTCB as this has been capped to a valid value. */
			if( pxNewTCB->uxPriority > uxTopUsedPriority )
    1464:	f8 01       	movw	r30, r16
    1466:	86 89       	ldd	r24, Z+22	; 0x16
    1468:	90 91 5c 03 	lds	r25, 0x035C
    146c:	98 17       	cp	r25, r24
    146e:	10 f4       	brcc	.+4      	; 0x1474 <xTaskGenericCreate+0x19e>
			{
				uxTopUsedPriority = pxNewTCB->uxPriority;
    1470:	80 93 5c 03 	sts	0x035C, r24
			{
				/* Add a counter into the TCB for tracing only. */
				pxNewTCB->uxTCBNumber = uxTaskNumber;
			}
			#endif
			uxTaskNumber++;
    1474:	90 91 5b 03 	lds	r25, 0x035B
    1478:	9f 5f       	subi	r25, 0xFF	; 255
    147a:	90 93 5b 03 	sts	0x035B, r25

			prvAddTaskToReadyQueue( pxNewTCB );
    147e:	90 91 2e 03 	lds	r25, 0x032E
    1482:	98 17       	cp	r25, r24
    1484:	10 f4       	brcc	.+4      	; 0x148a <xTaskGenericCreate+0x1b4>
    1486:	80 93 2e 03 	sts	0x032E, r24
    148a:	90 e0       	ldi	r25, 0x00	; 0
    148c:	9c 01       	movw	r18, r24
    148e:	22 0f       	add	r18, r18
    1490:	33 1f       	adc	r19, r19
    1492:	22 0f       	add	r18, r18
    1494:	33 1f       	adc	r19, r19
    1496:	22 0f       	add	r18, r18
    1498:	33 1f       	adc	r19, r19
    149a:	82 0f       	add	r24, r18
    149c:	93 1f       	adc	r25, r19
    149e:	81 5d       	subi	r24, 0xD1	; 209
    14a0:	9c 4f       	sbci	r25, 0xFC	; 252
    14a2:	b7 01       	movw	r22, r14
    14a4:	0e 94 5e 03 	call	0x6bc	; 0x6bc <vListInsertEnd>

			xReturn = pdPASS;
			traceTASK_CREATE( pxNewTCB );
		}
		taskEXIT_CRITICAL();
    14a8:	0f 90       	pop	r0
    14aa:	0f be       	out	0x3f, r0	; 63
		traceTASK_CREATE_FAILED();
	}

	if( xReturn == pdPASS )
	{
		if( xSchedulerRunning != pdFALSE )
    14ac:	80 91 50 03 	lds	r24, 0x0350
    14b0:	88 23       	and	r24, r24
    14b2:	69 f0       	breq	.+26     	; 0x14ce <xTaskGenericCreate+0x1f8>
		{
			/* If the created task is of a higher priority than the current task
			then it should run now. */
			if( pxCurrentTCB->uxPriority < uxPriority )
    14b4:	e0 91 27 03 	lds	r30, 0x0327
    14b8:	f0 91 28 03 	lds	r31, 0x0328
    14bc:	86 89       	ldd	r24, Z+22	; 0x16
    14be:	8b 15       	cp	r24, r11
    14c0:	40 f4       	brcc	.+16     	; 0x14d2 <xTaskGenericCreate+0x1fc>
			{
				portYIELD_WITHIN_API();
    14c2:	0e 94 e2 04 	call	0x9c4	; 0x9c4 <vPortYield>
			#endif
			uxTaskNumber++;

			prvAddTaskToReadyQueue( pxNewTCB );

			xReturn = pdPASS;
    14c6:	81 e0       	ldi	r24, 0x01	; 1
    14c8:	05 c0       	rjmp	.+10     	; 0x14d4 <xTaskGenericCreate+0x1fe>
		}
		taskEXIT_CRITICAL();
	}
	else
	{
		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
    14ca:	8f ef       	ldi	r24, 0xFF	; 255
    14cc:	03 c0       	rjmp	.+6      	; 0x14d4 <xTaskGenericCreate+0x1fe>
			#endif
			uxTaskNumber++;

			prvAddTaskToReadyQueue( pxNewTCB );

			xReturn = pdPASS;
    14ce:	81 e0       	ldi	r24, 0x01	; 1
    14d0:	01 c0       	rjmp	.+2      	; 0x14d4 <xTaskGenericCreate+0x1fe>
    14d2:	81 e0       	ldi	r24, 0x01	; 1
			}
		}
	}

	return xReturn;
}
    14d4:	df 91       	pop	r29
    14d6:	cf 91       	pop	r28
    14d8:	1f 91       	pop	r17
    14da:	0f 91       	pop	r16
    14dc:	ff 90       	pop	r15
    14de:	ef 90       	pop	r14
    14e0:	df 90       	pop	r13
    14e2:	cf 90       	pop	r12
    14e4:	bf 90       	pop	r11
    14e6:	9f 90       	pop	r9
    14e8:	8f 90       	pop	r8
    14ea:	7f 90       	pop	r7
    14ec:	6f 90       	pop	r6
    14ee:	5f 90       	pop	r5
    14f0:	4f 90       	pop	r4
    14f2:	3f 90       	pop	r3
    14f4:	2f 90       	pop	r2
    14f6:	08 95       	ret
	if( pxNewTCB != NULL )
	{
		/* Allocate space for the stack used by the task being created.
		The base of the stack memory stored in the TCB so the task can
		be deleted later if required. */
		pxNewTCB->pxStack = ( portSTACK_TYPE * ) pvPortMallocAligned( ( ( ( size_t )usStackDepth ) * sizeof( portSTACK_TYPE ) ), puxStackBuffer );
    14f8:	f8 01       	movw	r30, r16
    14fa:	d0 8e       	std	Z+24, r13	; 0x18
    14fc:	c7 8a       	std	Z+23, r12	; 0x17
    14fe:	20 cf       	rjmp	.-448    	; 0x1340 <xTaskGenericCreate+0x6a>

00001500 <vTaskDelete>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

	void vTaskDelete( xTaskHandle pxTaskToDelete )
	{
    1500:	ef 92       	push	r14
    1502:	ff 92       	push	r15
    1504:	0f 93       	push	r16
    1506:	1f 93       	push	r17
    1508:	cf 93       	push	r28
    150a:	df 93       	push	r29
    150c:	ec 01       	movw	r28, r24
	tskTCB *pxTCB;

		taskENTER_CRITICAL();
    150e:	0f b6       	in	r0, 0x3f	; 63
    1510:	f8 94       	cli
    1512:	0f 92       	push	r0
		{
			/* Ensure a yield is performed if the current task is being
			deleted. */
			if( pxTaskToDelete == pxCurrentTCB )
    1514:	80 91 27 03 	lds	r24, 0x0327
    1518:	90 91 28 03 	lds	r25, 0x0328
    151c:	c8 17       	cp	r28, r24
    151e:	d9 07       	cpc	r29, r25
    1520:	19 f0       	breq	.+6      	; 0x1528 <vTaskDelete+0x28>
			{
				pxTaskToDelete = NULL;
			}

			/* If null is passed in here then we are deleting ourselves. */
			pxTCB = prvGetTCBFromHandle( pxTaskToDelete );
    1522:	20 97       	sbiw	r28, 0x00	; 0
    1524:	41 f4       	brne	.+16     	; 0x1536 <vTaskDelete+0x36>
    1526:	02 c0       	rjmp	.+4      	; 0x152c <vTaskDelete+0x2c>
		{
			/* Ensure a yield is performed if the current task is being
			deleted. */
			if( pxTaskToDelete == pxCurrentTCB )
			{
				pxTaskToDelete = NULL;
    1528:	c0 e0       	ldi	r28, 0x00	; 0
    152a:	d0 e0       	ldi	r29, 0x00	; 0
			}

			/* If null is passed in here then we are deleting ourselves. */
			pxTCB = prvGetTCBFromHandle( pxTaskToDelete );
    152c:	00 91 27 03 	lds	r16, 0x0327
    1530:	10 91 28 03 	lds	r17, 0x0328
    1534:	01 c0       	rjmp	.+2      	; 0x1538 <vTaskDelete+0x38>
    1536:	8e 01       	movw	r16, r28

			/* Remove task from the ready list and place in the	termination list.
			This will stop the task from be scheduled.  The idle task will check
			the termination list and free up any memory allocated by the
			scheduler for the TCB and stack. */
			vListRemove( &( pxTCB->xGenericListItem ) );
    1538:	ee 24       	eor	r14, r14
    153a:	ff 24       	eor	r15, r15
    153c:	68 94       	set
    153e:	e1 f8       	bld	r14, 1
    1540:	e0 0e       	add	r14, r16
    1542:	f1 1e       	adc	r15, r17
    1544:	c7 01       	movw	r24, r14
    1546:	0e 94 c4 03 	call	0x788	; 0x788 <vListRemove>

			/* Is the task waiting on an event also? */
			if( pxTCB->xEventListItem.pvContainer != NULL )
    154a:	f8 01       	movw	r30, r16
    154c:	84 89       	ldd	r24, Z+20	; 0x14
    154e:	95 89       	ldd	r25, Z+21	; 0x15
    1550:	00 97       	sbiw	r24, 0x00	; 0
    1552:	21 f0       	breq	.+8      	; 0x155c <vTaskDelete+0x5c>
			{
				vListRemove( &( pxTCB->xEventListItem ) );
    1554:	c8 01       	movw	r24, r16
    1556:	0c 96       	adiw	r24, 0x0c	; 12
    1558:	0e 94 c4 03 	call	0x788	; 0x788 <vListRemove>
			}

			vListInsertEnd( ( xList * ) &xTasksWaitingTermination, &( pxTCB->xGenericListItem ) );
    155c:	82 e5       	ldi	r24, 0x52	; 82
    155e:	93 e0       	ldi	r25, 0x03	; 3
    1560:	b7 01       	movw	r22, r14
    1562:	0e 94 5e 03 	call	0x6bc	; 0x6bc <vListInsertEnd>

			/* Increment the ucTasksDeleted variable so the idle task knows
			there is a task that has been deleted and that it should therefore
			check the xTasksWaitingTermination list. */
			++uxTasksDeleted;
    1566:	80 91 51 03 	lds	r24, 0x0351
    156a:	8f 5f       	subi	r24, 0xFF	; 255
    156c:	80 93 51 03 	sts	0x0351, r24

			/* Increment the uxTaskNumberVariable also so kernel aware debuggers
			can detect that the task lists need re-generating. */
			uxTaskNumber++;
    1570:	80 91 5b 03 	lds	r24, 0x035B
    1574:	8f 5f       	subi	r24, 0xFF	; 255
    1576:	80 93 5b 03 	sts	0x035B, r24

			traceTASK_DELETE( pxTCB );
		}
		taskEXIT_CRITICAL();
    157a:	0f 90       	pop	r0
    157c:	0f be       	out	0x3f, r0	; 63

		/* Force a reschedule if we have just deleted the current task. */
		if( xSchedulerRunning != pdFALSE )
    157e:	80 91 50 03 	lds	r24, 0x0350
    1582:	88 23       	and	r24, r24
    1584:	21 f0       	breq	.+8      	; 0x158e <vTaskDelete+0x8e>
		{
			if( ( void * ) pxTaskToDelete == NULL )
    1586:	20 97       	sbiw	r28, 0x00	; 0
    1588:	11 f4       	brne	.+4      	; 0x158e <vTaskDelete+0x8e>
			{
				portYIELD_WITHIN_API();
    158a:	0e 94 e2 04 	call	0x9c4	; 0x9c4 <vPortYield>
			}
		}
	}
    158e:	df 91       	pop	r29
    1590:	cf 91       	pop	r28
    1592:	1f 91       	pop	r17
    1594:	0f 91       	pop	r16
    1596:	ff 90       	pop	r15
    1598:	ef 90       	pop	r14
    159a:	08 95       	ret

0000159c <vTaskStartScheduler>:
 * PUBLIC SCHEDULER CONTROL documented in task.h
 *----------------------------------------------------------*/


void vTaskStartScheduler( void )
{
    159c:	af 92       	push	r10
    159e:	bf 92       	push	r11
    15a0:	cf 92       	push	r12
    15a2:	df 92       	push	r13
    15a4:	ef 92       	push	r14
    15a6:	ff 92       	push	r15
    15a8:	0f 93       	push	r16
		xReturn = xTaskCreate( prvIdleTask, ( signed char * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), &xIdleTaskHandle );
	}
	#else
	{
		/* Create the idle task without storing its handle. */
		xReturn = xTaskCreate( prvIdleTask, ( signed char * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), NULL );
    15aa:	81 e7       	ldi	r24, 0x71	; 113
    15ac:	9c e0       	ldi	r25, 0x0C	; 12
    15ae:	6a e8       	ldi	r22, 0x8A	; 138
    15b0:	70 e0       	ldi	r23, 0x00	; 0
    15b2:	45 e5       	ldi	r20, 0x55	; 85
    15b4:	50 e0       	ldi	r21, 0x00	; 0
    15b6:	20 e0       	ldi	r18, 0x00	; 0
    15b8:	30 e0       	ldi	r19, 0x00	; 0
    15ba:	00 e0       	ldi	r16, 0x00	; 0
    15bc:	ee 24       	eor	r14, r14
    15be:	ff 24       	eor	r15, r15
    15c0:	cc 24       	eor	r12, r12
    15c2:	dd 24       	eor	r13, r13
    15c4:	aa 24       	eor	r10, r10
    15c6:	bb 24       	eor	r11, r11
    15c8:	0e 94 6b 09 	call	0x12d6	; 0x12d6 <xTaskGenericCreate>
			xReturn = xTimerCreateTimerTask();
		}
	}
	#endif

	if( xReturn == pdPASS )
    15cc:	81 30       	cpi	r24, 0x01	; 1
    15ce:	49 f4       	brne	.+18     	; 0x15e2 <vTaskStartScheduler+0x46>
		so interrupts will automatically get re-enabled when the first task
		starts to run.

		STEPPING THROUGH HERE USING A DEBUGGER CAN CAUSE BIG PROBLEMS IF THE
		DEBUGGER ALLOWS INTERRUPTS TO BE PROCESSED. */
		portDISABLE_INTERRUPTS();
    15d0:	f8 94       	cli

		xSchedulerRunning = pdTRUE;
    15d2:	80 93 50 03 	sts	0x0350, r24
		xTickCount = ( portTickType ) 0U;
    15d6:	10 92 2c 03 	sts	0x032C, r1
    15da:	10 92 2b 03 	sts	0x032B, r1
		the run time counter time base. */
		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();
		
		/* Setting up the timer tick is hardware specific and thus in the
		portable interface. */
		if( xPortStartScheduler() != pdFALSE )
    15de:	0e 94 ac 04 	call	0x958	; 0x958 <xPortStartScheduler>
		}
	}

	/* This line will only be reached if the kernel could not be started. */
	configASSERT( xReturn );
}
    15e2:	0f 91       	pop	r16
    15e4:	ff 90       	pop	r15
    15e6:	ef 90       	pop	r14
    15e8:	df 90       	pop	r13
    15ea:	cf 90       	pop	r12
    15ec:	bf 90       	pop	r11
    15ee:	af 90       	pop	r10
    15f0:	08 95       	ret

000015f2 <vTaskEndScheduler>:
void vTaskEndScheduler( void )
{
	/* Stop the scheduler interrupts and call the portable scheduler end
	routine so the original ISRs can be restored if necessary.  The port
	layer must ensure interrupts enable	bit is left in the correct state. */
	portDISABLE_INTERRUPTS();
    15f2:	f8 94       	cli
	xSchedulerRunning = pdFALSE;
    15f4:	10 92 50 03 	sts	0x0350, r1
	vPortEndScheduler();
    15f8:	0e 94 e1 04 	call	0x9c2	; 0x9c2 <vPortEndScheduler>
}
    15fc:	08 95       	ret

000015fe <vTaskSuspendAll>:

void vTaskSuspendAll( void )
{
	/* A critical section is not required as the variable is of type
	portBASE_TYPE. */
	++uxSchedulerSuspended;
    15fe:	80 91 2d 03 	lds	r24, 0x032D
    1602:	8f 5f       	subi	r24, 0xFF	; 255
    1604:	80 93 2d 03 	sts	0x032D, r24
}
    1608:	08 95       	ret

0000160a <xTaskGetTickCount>:
portTickType xTaskGetTickCount( void )
{
portTickType xTicks;

	/* Critical section required if running on a 16 bit processor. */
	taskENTER_CRITICAL();
    160a:	0f b6       	in	r0, 0x3f	; 63
    160c:	f8 94       	cli
    160e:	0f 92       	push	r0
	{
		xTicks = xTickCount;
    1610:	20 91 2b 03 	lds	r18, 0x032B
    1614:	30 91 2c 03 	lds	r19, 0x032C
	}
	taskEXIT_CRITICAL();
    1618:	0f 90       	pop	r0
    161a:	0f be       	out	0x3f, r0	; 63

	return xTicks;
}
    161c:	82 2f       	mov	r24, r18
    161e:	93 2f       	mov	r25, r19
    1620:	08 95       	ret

00001622 <xTaskGetTickCountFromISR>:
{
portTickType xReturn;
unsigned portBASE_TYPE uxSavedInterruptStatus;

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	xReturn = xTickCount;
    1622:	20 91 2b 03 	lds	r18, 0x032B
    1626:	30 91 2c 03 	lds	r19, 0x032C
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    162a:	82 2f       	mov	r24, r18
    162c:	93 2f       	mov	r25, r19
    162e:	08 95       	ret

00001630 <uxTaskGetNumberOfTasks>:

unsigned portBASE_TYPE uxTaskGetNumberOfTasks( void )
{
	/* A critical section is not required because the variables are of type
	portBASE_TYPE. */
	return uxCurrentNumberOfTasks;
    1630:	80 91 4f 03 	lds	r24, 0x034F
}
    1634:	08 95       	ret

00001636 <vTaskIncrementTick>:
 * SCHEDULER INTERNALS AVAILABLE FOR PORTING PURPOSES
 * documented in task.h
 *----------------------------------------------------------*/

void vTaskIncrementTick( void )
{
    1636:	0f 93       	push	r16
    1638:	1f 93       	push	r17
    163a:	cf 93       	push	r28
    163c:	df 93       	push	r29
tskTCB * pxTCB;

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    163e:	80 91 2d 03 	lds	r24, 0x032D
    1642:	88 23       	and	r24, r24
    1644:	09 f0       	breq	.+2      	; 0x1648 <vTaskIncrementTick+0x12>
    1646:	b3 c0       	rjmp	.+358    	; 0x17ae <vTaskIncrementTick+0x178>
	{
		++xTickCount;
    1648:	80 91 2b 03 	lds	r24, 0x032B
    164c:	90 91 2c 03 	lds	r25, 0x032C
    1650:	01 96       	adiw	r24, 0x01	; 1
    1652:	90 93 2c 03 	sts	0x032C, r25
    1656:	80 93 2b 03 	sts	0x032B, r24
		if( xTickCount == ( portTickType ) 0U )
    165a:	80 91 2b 03 	lds	r24, 0x032B
    165e:	90 91 2c 03 	lds	r25, 0x032C
    1662:	00 97       	sbiw	r24, 0x00	; 0
    1664:	99 f5       	brne	.+102    	; 0x16cc <vTaskIncrementTick+0x96>
			/* Tick count has overflowed so we need to swap the delay lists.
			If there are any items in pxDelayedTaskList here then there is
			an error! */
			configASSERT( ( listLIST_IS_EMPTY( pxDelayedTaskList ) ) );
			
			pxTemp = pxDelayedTaskList;
    1666:	80 91 4c 03 	lds	r24, 0x034C
    166a:	90 91 4d 03 	lds	r25, 0x034D
			pxDelayedTaskList = pxOverflowDelayedTaskList;
    166e:	20 91 4a 03 	lds	r18, 0x034A
    1672:	30 91 4b 03 	lds	r19, 0x034B
    1676:	30 93 4d 03 	sts	0x034D, r19
    167a:	20 93 4c 03 	sts	0x034C, r18
			pxOverflowDelayedTaskList = pxTemp;
    167e:	90 93 4b 03 	sts	0x034B, r25
    1682:	80 93 4a 03 	sts	0x034A, r24
			xNumOfOverflows++;
    1686:	80 91 2a 03 	lds	r24, 0x032A
    168a:	8f 5f       	subi	r24, 0xFF	; 255
    168c:	80 93 2a 03 	sts	0x032A, r24
	
			if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    1690:	e0 91 4c 03 	lds	r30, 0x034C
    1694:	f0 91 4d 03 	lds	r31, 0x034D
    1698:	80 81       	ld	r24, Z
    169a:	88 23       	and	r24, r24
    169c:	39 f4       	brne	.+14     	; 0x16ac <vTaskIncrementTick+0x76>
				/* The new current delayed list is empty.  Set
				xNextTaskUnblockTime to the maximum possible value so it is
				extremely unlikely that the	
				if( xTickCount >= xNextTaskUnblockTime ) test will pass until
				there is an item in the delayed list. */
				xNextTaskUnblockTime = portMAX_DELAY;
    169e:	8f ef       	ldi	r24, 0xFF	; 255
    16a0:	9f ef       	ldi	r25, 0xFF	; 255
    16a2:	90 93 90 00 	sts	0x0090, r25
    16a6:	80 93 8f 00 	sts	0x008F, r24
    16aa:	10 c0       	rjmp	.+32     	; 0x16cc <vTaskIncrementTick+0x96>
			{
				/* The new current delayed list is not empty, get the value of
				the item at the head of the delayed list.  This is the time at
				which the task at the head of the delayed list should be removed
				from the Blocked state. */
				pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
    16ac:	e0 91 4c 03 	lds	r30, 0x034C
    16b0:	f0 91 4d 03 	lds	r31, 0x034D
    16b4:	05 80       	ldd	r0, Z+5	; 0x05
    16b6:	f6 81       	ldd	r31, Z+6	; 0x06
    16b8:	e0 2d       	mov	r30, r0
    16ba:	06 80       	ldd	r0, Z+6	; 0x06
    16bc:	f7 81       	ldd	r31, Z+7	; 0x07
    16be:	e0 2d       	mov	r30, r0
				xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( pxTCB->xGenericListItem ) );
    16c0:	82 81       	ldd	r24, Z+2	; 0x02
    16c2:	93 81       	ldd	r25, Z+3	; 0x03
    16c4:	90 93 90 00 	sts	0x0090, r25
    16c8:	80 93 8f 00 	sts	0x008F, r24
			}
		}

		/* See if this tick has made a timeout expire. */
		prvCheckDelayedTasks();
    16cc:	20 91 2b 03 	lds	r18, 0x032B
    16d0:	30 91 2c 03 	lds	r19, 0x032C
    16d4:	80 91 8f 00 	lds	r24, 0x008F
    16d8:	90 91 90 00 	lds	r25, 0x0090
    16dc:	28 17       	cp	r18, r24
    16de:	39 07       	cpc	r19, r25
    16e0:	08 f4       	brcc	.+2      	; 0x16e4 <vTaskIncrementTick+0xae>
    16e2:	6a c0       	rjmp	.+212    	; 0x17b8 <vTaskIncrementTick+0x182>
    16e4:	e0 91 4c 03 	lds	r30, 0x034C
    16e8:	f0 91 4d 03 	lds	r31, 0x034D
    16ec:	80 81       	ld	r24, Z
    16ee:	88 23       	and	r24, r24
    16f0:	99 f0       	breq	.+38     	; 0x1718 <vTaskIncrementTick+0xe2>
    16f2:	e0 91 4c 03 	lds	r30, 0x034C
    16f6:	f0 91 4d 03 	lds	r31, 0x034D
    16fa:	05 80       	ldd	r0, Z+5	; 0x05
    16fc:	f6 81       	ldd	r31, Z+6	; 0x06
    16fe:	e0 2d       	mov	r30, r0
    1700:	c6 81       	ldd	r28, Z+6	; 0x06
    1702:	d7 81       	ldd	r29, Z+7	; 0x07
    1704:	8a 81       	ldd	r24, Y+2	; 0x02
    1706:	9b 81       	ldd	r25, Y+3	; 0x03
    1708:	20 91 2b 03 	lds	r18, 0x032B
    170c:	30 91 2c 03 	lds	r19, 0x032C
    1710:	28 17       	cp	r18, r24
    1712:	39 07       	cpc	r19, r25
    1714:	f8 f4       	brcc	.+62     	; 0x1754 <vTaskIncrementTick+0x11e>
    1716:	19 c0       	rjmp	.+50     	; 0x174a <vTaskIncrementTick+0x114>
    1718:	8f ef       	ldi	r24, 0xFF	; 255
    171a:	9f ef       	ldi	r25, 0xFF	; 255
    171c:	90 93 90 00 	sts	0x0090, r25
    1720:	80 93 8f 00 	sts	0x008F, r24
    1724:	49 c0       	rjmp	.+146    	; 0x17b8 <vTaskIncrementTick+0x182>
    1726:	e0 91 4c 03 	lds	r30, 0x034C
    172a:	f0 91 4d 03 	lds	r31, 0x034D
    172e:	05 80       	ldd	r0, Z+5	; 0x05
    1730:	f6 81       	ldd	r31, Z+6	; 0x06
    1732:	e0 2d       	mov	r30, r0
    1734:	c6 81       	ldd	r28, Z+6	; 0x06
    1736:	d7 81       	ldd	r29, Z+7	; 0x07
    1738:	8a 81       	ldd	r24, Y+2	; 0x02
    173a:	9b 81       	ldd	r25, Y+3	; 0x03
    173c:	20 91 2b 03 	lds	r18, 0x032B
    1740:	30 91 2c 03 	lds	r19, 0x032C
    1744:	28 17       	cp	r18, r24
    1746:	39 07       	cpc	r19, r25
    1748:	28 f4       	brcc	.+10     	; 0x1754 <vTaskIncrementTick+0x11e>
    174a:	90 93 90 00 	sts	0x0090, r25
    174e:	80 93 8f 00 	sts	0x008F, r24
    1752:	32 c0       	rjmp	.+100    	; 0x17b8 <vTaskIncrementTick+0x182>
    1754:	8e 01       	movw	r16, r28
    1756:	0e 5f       	subi	r16, 0xFE	; 254
    1758:	1f 4f       	sbci	r17, 0xFF	; 255
    175a:	c8 01       	movw	r24, r16
    175c:	0e 94 c4 03 	call	0x788	; 0x788 <vListRemove>
    1760:	8c 89       	ldd	r24, Y+20	; 0x14
    1762:	9d 89       	ldd	r25, Y+21	; 0x15
    1764:	00 97       	sbiw	r24, 0x00	; 0
    1766:	21 f0       	breq	.+8      	; 0x1770 <vTaskIncrementTick+0x13a>
    1768:	ce 01       	movw	r24, r28
    176a:	0c 96       	adiw	r24, 0x0c	; 12
    176c:	0e 94 c4 03 	call	0x788	; 0x788 <vListRemove>
    1770:	8e 89       	ldd	r24, Y+22	; 0x16
    1772:	90 91 2e 03 	lds	r25, 0x032E
    1776:	98 17       	cp	r25, r24
    1778:	10 f4       	brcc	.+4      	; 0x177e <vTaskIncrementTick+0x148>
    177a:	80 93 2e 03 	sts	0x032E, r24
    177e:	90 e0       	ldi	r25, 0x00	; 0
    1780:	9c 01       	movw	r18, r24
    1782:	22 0f       	add	r18, r18
    1784:	33 1f       	adc	r19, r19
    1786:	22 0f       	add	r18, r18
    1788:	33 1f       	adc	r19, r19
    178a:	22 0f       	add	r18, r18
    178c:	33 1f       	adc	r19, r19
    178e:	82 0f       	add	r24, r18
    1790:	93 1f       	adc	r25, r19
    1792:	81 5d       	subi	r24, 0xD1	; 209
    1794:	9c 4f       	sbci	r25, 0xFC	; 252
    1796:	b8 01       	movw	r22, r16
    1798:	0e 94 5e 03 	call	0x6bc	; 0x6bc <vListInsertEnd>
    179c:	e0 91 4c 03 	lds	r30, 0x034C
    17a0:	f0 91 4d 03 	lds	r31, 0x034D
    17a4:	80 81       	ld	r24, Z
    17a6:	88 23       	and	r24, r24
    17a8:	09 f0       	breq	.+2      	; 0x17ac <vTaskIncrementTick+0x176>
    17aa:	bd cf       	rjmp	.-134    	; 0x1726 <vTaskIncrementTick+0xf0>
    17ac:	b5 cf       	rjmp	.-150    	; 0x1718 <vTaskIncrementTick+0xe2>
	}
	else
	{
		++uxMissedTicks;
    17ae:	80 91 4e 03 	lds	r24, 0x034E
    17b2:	8f 5f       	subi	r24, 0xFF	; 255
    17b4:	80 93 4e 03 	sts	0x034E, r24
		}
	}
	#endif

	traceTASK_INCREMENT_TICK( xTickCount );
}
    17b8:	df 91       	pop	r29
    17ba:	cf 91       	pop	r28
    17bc:	1f 91       	pop	r17
    17be:	0f 91       	pop	r16
    17c0:	08 95       	ret

000017c2 <xTaskResumeAll>:
	++uxSchedulerSuspended;
}
/*----------------------------------------------------------*/

signed portBASE_TYPE xTaskResumeAll( void )
{
    17c2:	af 92       	push	r10
    17c4:	bf 92       	push	r11
    17c6:	cf 92       	push	r12
    17c8:	df 92       	push	r13
    17ca:	ef 92       	push	r14
    17cc:	ff 92       	push	r15
    17ce:	0f 93       	push	r16
    17d0:	1f 93       	push	r17
    17d2:	cf 93       	push	r28
    17d4:	df 93       	push	r29
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
    17d6:	0f b6       	in	r0, 0x3f	; 63
    17d8:	f8 94       	cli
    17da:	0f 92       	push	r0
	{
		--uxSchedulerSuspended;
    17dc:	80 91 2d 03 	lds	r24, 0x032D
    17e0:	81 50       	subi	r24, 0x01	; 1
    17e2:	80 93 2d 03 	sts	0x032D, r24

		if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    17e6:	80 91 2d 03 	lds	r24, 0x032D
    17ea:	88 23       	and	r24, r24
    17ec:	09 f0       	breq	.+2      	; 0x17f0 <xTaskResumeAll+0x2e>
    17ee:	69 c0       	rjmp	.+210    	; 0x18c2 <xTaskResumeAll+0x100>
		{
			if( uxCurrentNumberOfTasks > ( unsigned portBASE_TYPE ) 0U )
    17f0:	80 91 4f 03 	lds	r24, 0x034F
    17f4:	88 23       	and	r24, r24
    17f6:	81 f5       	brne	.+96     	; 0x1858 <xTaskResumeAll+0x96>
    17f8:	67 c0       	rjmp	.+206    	; 0x18c8 <xTaskResumeAll+0x106>

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) );
    17fa:	d6 01       	movw	r26, r12
    17fc:	ed 91       	ld	r30, X+
    17fe:	fc 91       	ld	r31, X
    1800:	c6 81       	ldd	r28, Z+6	; 0x06
    1802:	d7 81       	ldd	r29, Z+7	; 0x07
					vListRemove( &( pxTCB->xEventListItem ) );
    1804:	ce 01       	movw	r24, r28
    1806:	0c 96       	adiw	r24, 0x0c	; 12
    1808:	0e 94 c4 03 	call	0x788	; 0x788 <vListRemove>
					vListRemove( &( pxTCB->xGenericListItem ) );
    180c:	8e 01       	movw	r16, r28
    180e:	0e 5f       	subi	r16, 0xFE	; 254
    1810:	1f 4f       	sbci	r17, 0xFF	; 255
    1812:	c8 01       	movw	r24, r16
    1814:	0e 94 c4 03 	call	0x788	; 0x788 <vListRemove>
					prvAddTaskToReadyQueue( pxTCB );
    1818:	8e 89       	ldd	r24, Y+22	; 0x16
    181a:	90 91 2e 03 	lds	r25, 0x032E
    181e:	98 17       	cp	r25, r24
    1820:	10 f4       	brcc	.+4      	; 0x1826 <xTaskResumeAll+0x64>
    1822:	80 93 2e 03 	sts	0x032E, r24
    1826:	90 e0       	ldi	r25, 0x00	; 0
    1828:	9c 01       	movw	r18, r24
    182a:	22 0f       	add	r18, r18
    182c:	33 1f       	adc	r19, r19
    182e:	22 0f       	add	r18, r18
    1830:	33 1f       	adc	r19, r19
    1832:	22 0f       	add	r18, r18
    1834:	33 1f       	adc	r19, r19
    1836:	82 0f       	add	r24, r18
    1838:	93 1f       	adc	r25, r19
    183a:	81 5d       	subi	r24, 0xD1	; 209
    183c:	9c 4f       	sbci	r25, 0xFC	; 252
    183e:	b8 01       	movw	r22, r16
    1840:	0e 94 5e 03 	call	0x6bc	; 0x6bc <vListInsertEnd>

					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    1844:	e0 91 27 03 	lds	r30, 0x0327
    1848:	f0 91 28 03 	lds	r31, 0x0328
    184c:	9e 89       	ldd	r25, Y+22	; 0x16
    184e:	86 89       	ldd	r24, Z+22	; 0x16
    1850:	98 17       	cp	r25, r24
    1852:	88 f0       	brcs	.+34     	; 0x1876 <xTaskResumeAll+0xb4>
					{
						xYieldRequired = pdTRUE;
    1854:	ba 2c       	mov	r11, r10
    1856:	0f c0       	rjmp	.+30     	; 0x1876 <xTaskResumeAll+0xb4>
	{
		--uxSchedulerSuspended;

		if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
		{
			if( uxCurrentNumberOfTasks > ( unsigned portBASE_TYPE ) 0U )
    1858:	bb 24       	eor	r11, r11
			{
				portBASE_TYPE xYieldRequired = pdFALSE;

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
    185a:	0f 2e       	mov	r0, r31
    185c:	f1 e4       	ldi	r31, 0x41	; 65
    185e:	ef 2e       	mov	r14, r31
    1860:	f3 e0       	ldi	r31, 0x03	; 3
    1862:	ff 2e       	mov	r15, r31
    1864:	f0 2d       	mov	r31, r0
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) );
    1866:	0f 2e       	mov	r0, r31
    1868:	f6 e4       	ldi	r31, 0x46	; 70
    186a:	cf 2e       	mov	r12, r31
    186c:	f3 e0       	ldi	r31, 0x03	; 3
    186e:	df 2e       	mov	r13, r31
    1870:	f0 2d       	mov	r31, r0

					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
					{
						xYieldRequired = pdTRUE;
    1872:	aa 24       	eor	r10, r10
    1874:	a3 94       	inc	r10
			{
				portBASE_TYPE xYieldRequired = pdFALSE;

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
    1876:	f7 01       	movw	r30, r14
    1878:	80 81       	ld	r24, Z
    187a:	88 23       	and	r24, r24
    187c:	09 f0       	breq	.+2      	; 0x1880 <xTaskResumeAll+0xbe>
    187e:	bd cf       	rjmp	.-134    	; 0x17fa <xTaskResumeAll+0x38>
				}

				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
    1880:	80 91 4e 03 	lds	r24, 0x034E
    1884:	88 23       	and	r24, r24
    1886:	81 f0       	breq	.+32     	; 0x18a8 <xTaskResumeAll+0xe6>
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
    1888:	80 91 4e 03 	lds	r24, 0x034E
    188c:	88 23       	and	r24, r24
    188e:	99 f0       	breq	.+38     	; 0x18b6 <xTaskResumeAll+0xf4>
					{
						vTaskIncrementTick();
    1890:	0e 94 1b 0b 	call	0x1636	; 0x1636 <vTaskIncrementTick>
						--uxMissedTicks;
    1894:	80 91 4e 03 	lds	r24, 0x034E
    1898:	81 50       	subi	r24, 0x01	; 1
    189a:	80 93 4e 03 	sts	0x034E, r24
				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
    189e:	80 91 4e 03 	lds	r24, 0x034E
    18a2:	88 23       	and	r24, r24
    18a4:	a9 f7       	brne	.-22     	; 0x1890 <xTaskResumeAll+0xce>
    18a6:	07 c0       	rjmp	.+14     	; 0x18b6 <xTaskResumeAll+0xf4>
						xYieldRequired = pdTRUE;
					}
					#endif
				}

				if( ( xYieldRequired == pdTRUE ) || ( xMissedYield == pdTRUE ) )
    18a8:	fb 2d       	mov	r31, r11
    18aa:	f1 30       	cpi	r31, 0x01	; 1
    18ac:	21 f0       	breq	.+8      	; 0x18b6 <xTaskResumeAll+0xf4>
    18ae:	80 91 29 03 	lds	r24, 0x0329
    18b2:	81 30       	cpi	r24, 0x01	; 1
    18b4:	41 f4       	brne	.+16     	; 0x18c6 <xTaskResumeAll+0x104>
				{
					xAlreadyYielded = pdTRUE;
					xMissedYield = pdFALSE;
    18b6:	10 92 29 03 	sts	0x0329, r1
					portYIELD_WITHIN_API();
    18ba:	0e 94 e2 04 	call	0x9c4	; 0x9c4 <vPortYield>
					#endif
				}

				if( ( xYieldRequired == pdTRUE ) || ( xMissedYield == pdTRUE ) )
				{
					xAlreadyYielded = pdTRUE;
    18be:	81 e0       	ldi	r24, 0x01	; 1
    18c0:	03 c0       	rjmp	.+6      	; 0x18c8 <xTaskResumeAll+0x106>
/*----------------------------------------------------------*/

signed portBASE_TYPE xTaskResumeAll( void )
{
register tskTCB *pxTCB;
signed portBASE_TYPE xAlreadyYielded = pdFALSE;
    18c2:	80 e0       	ldi	r24, 0x00	; 0
    18c4:	01 c0       	rjmp	.+2      	; 0x18c8 <xTaskResumeAll+0x106>
    18c6:	80 e0       	ldi	r24, 0x00	; 0
					portYIELD_WITHIN_API();
				}
			}
		}
	}
	taskEXIT_CRITICAL();
    18c8:	0f 90       	pop	r0
    18ca:	0f be       	out	0x3f, r0	; 63

	return xAlreadyYielded;
}
    18cc:	df 91       	pop	r29
    18ce:	cf 91       	pop	r28
    18d0:	1f 91       	pop	r17
    18d2:	0f 91       	pop	r16
    18d4:	ff 90       	pop	r15
    18d6:	ef 90       	pop	r14
    18d8:	df 90       	pop	r13
    18da:	cf 90       	pop	r12
    18dc:	bf 90       	pop	r11
    18de:	af 90       	pop	r10
    18e0:	08 95       	ret

000018e2 <prvIdleTask>:
 *
 * void prvIdleTask( void *pvParameters );
 *
 */
static portTASK_FUNCTION( prvIdleTask, pvParameters )
{
    18e2:	cf 92       	push	r12
    18e4:	df 92       	push	r13
    18e6:	ff 92       	push	r15
    18e8:	0f 93       	push	r16
    18ea:	1f 93       	push	r17
    18ec:	cf 93       	push	r28
    18ee:	df 93       	push	r29
		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		if( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0U )
		{
			vTaskSuspendAll();
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
    18f0:	02 e5       	ldi	r16, 0x52	; 82
    18f2:	13 e0       	ldi	r17, 0x03	; 3
			{
				tskTCB *pxTCB;

				taskENTER_CRITICAL();
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( ( ( xList * ) &xTasksWaitingTermination ) );
    18f4:	0f 2e       	mov	r0, r31
    18f6:	f7 e5       	ldi	r31, 0x57	; 87
    18f8:	cf 2e       	mov	r12, r31
    18fa:	f3 e0       	ldi	r31, 0x03	; 3
    18fc:	df 2e       	mov	r13, r31
    18fe:	f0 2d       	mov	r31, r0
	{
		portBASE_TYPE xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		if( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0U )
    1900:	80 91 51 03 	lds	r24, 0x0351
    1904:	88 23       	and	r24, r24
    1906:	e1 f3       	breq	.-8      	; 0x1900 <prvIdleTask+0x1e>
		{
			vTaskSuspendAll();
    1908:	0e 94 ff 0a 	call	0x15fe	; 0x15fe <vTaskSuspendAll>
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
    190c:	d8 01       	movw	r26, r16
    190e:	fc 90       	ld	r15, X
			xTaskResumeAll();
    1910:	0e 94 e1 0b 	call	0x17c2	; 0x17c2 <xTaskResumeAll>

			if( xListIsEmpty == pdFALSE )
    1914:	ff 20       	and	r15, r15
    1916:	a1 f3       	breq	.-24     	; 0x1900 <prvIdleTask+0x1e>
			{
				tskTCB *pxTCB;

				taskENTER_CRITICAL();
    1918:	0f b6       	in	r0, 0x3f	; 63
    191a:	f8 94       	cli
    191c:	0f 92       	push	r0
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( ( ( xList * ) &xTasksWaitingTermination ) );
    191e:	d6 01       	movw	r26, r12
    1920:	ed 91       	ld	r30, X+
    1922:	fc 91       	ld	r31, X
    1924:	c6 81       	ldd	r28, Z+6	; 0x06
    1926:	d7 81       	ldd	r29, Z+7	; 0x07
					vListRemove( &( pxTCB->xGenericListItem ) );
    1928:	ce 01       	movw	r24, r28
    192a:	02 96       	adiw	r24, 0x02	; 2
    192c:	0e 94 c4 03 	call	0x788	; 0x788 <vListRemove>
					--uxCurrentNumberOfTasks;
    1930:	80 91 4f 03 	lds	r24, 0x034F
    1934:	81 50       	subi	r24, 0x01	; 1
    1936:	80 93 4f 03 	sts	0x034F, r24
					--uxTasksDeleted;
    193a:	80 91 51 03 	lds	r24, 0x0351
    193e:	81 50       	subi	r24, 0x01	; 1
    1940:	80 93 51 03 	sts	0x0351, r24
				}
				taskEXIT_CRITICAL();
    1944:	0f 90       	pop	r0
    1946:	0f be       	out	0x3f, r0	; 63

	static void prvDeleteTCB( tskTCB *pxTCB )
	{
		/* Free up the memory allocated by the scheduler for the task.  It is up to
		the task to free any memory allocated at the application level. */
		vPortFreeAligned( pxTCB->pxStack );
    1948:	8f 89       	ldd	r24, Y+23	; 0x17
    194a:	98 8d       	ldd	r25, Y+24	; 0x18
    194c:	0e 94 ae 02 	call	0x55c	; 0x55c <vPortFree>
		vPortFree( pxTCB );
    1950:	ce 01       	movw	r24, r28
    1952:	0e 94 ae 02 	call	0x55c	; 0x55c <vPortFree>
    1956:	d4 cf       	rjmp	.-88     	; 0x1900 <prvIdleTask+0x1e>

00001958 <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( portTickType xTicksToDelay )
	{
    1958:	0f 93       	push	r16
    195a:	1f 93       	push	r17
    195c:	cf 93       	push	r28
    195e:	df 93       	push	r29
    1960:	ec 01       	movw	r28, r24
	portTickType xTimeToWake;
	signed portBASE_TYPE xAlreadyYielded = pdFALSE;

		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( portTickType ) 0U )
    1962:	00 97       	sbiw	r24, 0x00	; 0
    1964:	b1 f0       	breq	.+44     	; 0x1992 <vTaskDelay+0x3a>
		{
			vTaskSuspendAll();
    1966:	0e 94 ff 0a 	call	0x15fe	; 0x15fe <vTaskSuspendAll>
				This task cannot be in an event list as it is the currently
				executing task. */

				/* Calculate the time to wake - this may overflow but this is
				not a problem. */
				xTimeToWake = xTickCount + xTicksToDelay;
    196a:	00 91 2b 03 	lds	r16, 0x032B
    196e:	10 91 2c 03 	lds	r17, 0x032C

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    1972:	80 91 27 03 	lds	r24, 0x0327
    1976:	90 91 28 03 	lds	r25, 0x0328
    197a:	02 96       	adiw	r24, 0x02	; 2
    197c:	0e 94 c4 03 	call	0x788	; 0x788 <vListRemove>
				prvAddCurrentTaskToDelayedList( xTimeToWake );
    1980:	ce 01       	movw	r24, r28
    1982:	80 0f       	add	r24, r16
    1984:	91 1f       	adc	r25, r17
    1986:	0e 94 34 09 	call	0x1268	; 0x1268 <prvAddCurrentTaskToDelayedList>
			}
			xAlreadyYielded = xTaskResumeAll();
    198a:	0e 94 e1 0b 	call	0x17c2	; 0x17c2 <xTaskResumeAll>
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    198e:	88 23       	and	r24, r24
    1990:	11 f4       	brne	.+4      	; 0x1996 <vTaskDelay+0x3e>
		{
			portYIELD_WITHIN_API();
    1992:	0e 94 e2 04 	call	0x9c4	; 0x9c4 <vPortYield>
		}
	}
    1996:	df 91       	pop	r29
    1998:	cf 91       	pop	r28
    199a:	1f 91       	pop	r17
    199c:	0f 91       	pop	r16
    199e:	08 95       	ret

000019a0 <vTaskDelayUntil>:
 *----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelayUntil == 1 )

	void vTaskDelayUntil( portTickType * const pxPreviousWakeTime, portTickType xTimeIncrement )
	{
    19a0:	0f 93       	push	r16
    19a2:	1f 93       	push	r17
    19a4:	cf 93       	push	r28
    19a6:	df 93       	push	r29
    19a8:	8c 01       	movw	r16, r24
    19aa:	eb 01       	movw	r28, r22
	portBASE_TYPE xAlreadyYielded, xShouldDelay = pdFALSE;

		configASSERT( pxPreviousWakeTime );
		configASSERT( ( xTimeIncrement > 0U ) );

		vTaskSuspendAll();
    19ac:	0e 94 ff 0a 	call	0x15fe	; 0x15fe <vTaskSuspendAll>
		{
			/* Generate the tick time at which the task wants to wake. */
			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
    19b0:	f8 01       	movw	r30, r16
    19b2:	80 81       	ld	r24, Z
    19b4:	91 81       	ldd	r25, Z+1	; 0x01
    19b6:	c8 0f       	add	r28, r24
    19b8:	d9 1f       	adc	r29, r25

			if( xTickCount < *pxPreviousWakeTime )
    19ba:	20 91 2b 03 	lds	r18, 0x032B
    19be:	30 91 2c 03 	lds	r19, 0x032C
    19c2:	28 17       	cp	r18, r24
    19c4:	39 07       	cpc	r19, r25
    19c6:	68 f4       	brcc	.+26     	; 0x19e2 <vTaskDelayUntil+0x42>
				/* The tick count has overflowed since this function was
				lasted called.  In this case the only time we should ever
				actually delay is if the wake time has also	overflowed,
				and the wake time is greater than the tick time.  When this
				is the case it is as if neither time had overflowed. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xTickCount ) )
    19c8:	c8 17       	cp	r28, r24
    19ca:	d9 07       	cpc	r29, r25
    19cc:	50 f5       	brcc	.+84     	; 0x1a22 <vTaskDelayUntil+0x82>
    19ce:	80 91 2b 03 	lds	r24, 0x032B
    19d2:	90 91 2c 03 	lds	r25, 0x032C
					xShouldDelay = pdTRUE;
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
    19d6:	d1 83       	std	Z+1, r29	; 0x01
    19d8:	c0 83       	st	Z, r28

			if( xShouldDelay != pdFALSE )
    19da:	8c 17       	cp	r24, r28
    19dc:	9d 07       	cpc	r25, r29
    19de:	b0 f4       	brcc	.+44     	; 0x1a0c <vTaskDelayUntil+0x6c>
    19e0:	0b c0       	rjmp	.+22     	; 0x19f8 <vTaskDelayUntil+0x58>
			else
			{
				/* The tick time has not overflowed.  In this case we will
				delay if either the wake time has overflowed, and/or the
				tick time is less than the wake time. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xTickCount ) )
    19e2:	c8 17       	cp	r28, r24
    19e4:	d9 07       	cpc	r29, r25
    19e6:	c8 f0       	brcs	.+50     	; 0x1a1a <vTaskDelayUntil+0x7a>
    19e8:	80 91 2b 03 	lds	r24, 0x032B
    19ec:	90 91 2c 03 	lds	r25, 0x032C
    19f0:	8c 17       	cp	r24, r28
    19f2:	9d 07       	cpc	r25, r29
    19f4:	90 f0       	brcs	.+36     	; 0x1a1a <vTaskDelayUntil+0x7a>
    19f6:	15 c0       	rjmp	.+42     	; 0x1a22 <vTaskDelayUntil+0x82>
				traceTASK_DELAY_UNTIL();

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    19f8:	80 91 27 03 	lds	r24, 0x0327
    19fc:	90 91 28 03 	lds	r25, 0x0328
    1a00:	02 96       	adiw	r24, 0x02	; 2
    1a02:	0e 94 c4 03 	call	0x788	; 0x788 <vListRemove>
				prvAddCurrentTaskToDelayedList( xTimeToWake );
    1a06:	ce 01       	movw	r24, r28
    1a08:	0e 94 34 09 	call	0x1268	; 0x1268 <prvAddCurrentTaskToDelayedList>
			}
		}
		xAlreadyYielded = xTaskResumeAll();
    1a0c:	0e 94 e1 0b 	call	0x17c2	; 0x17c2 <xTaskResumeAll>

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    1a10:	88 23       	and	r24, r24
    1a12:	59 f4       	brne	.+22     	; 0x1a2a <vTaskDelayUntil+0x8a>
		{
			portYIELD_WITHIN_API();
    1a14:	0e 94 e2 04 	call	0x9c4	; 0x9c4 <vPortYield>
    1a18:	08 c0       	rjmp	.+16     	; 0x1a2a <vTaskDelayUntil+0x8a>
					xShouldDelay = pdTRUE;
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
    1a1a:	f8 01       	movw	r30, r16
    1a1c:	d1 83       	std	Z+1, r29	; 0x01
    1a1e:	c0 83       	st	Z, r28
    1a20:	eb cf       	rjmp	.-42     	; 0x19f8 <vTaskDelayUntil+0x58>
    1a22:	f8 01       	movw	r30, r16
    1a24:	d1 83       	std	Z+1, r29	; 0x01
    1a26:	c0 83       	st	Z, r28
    1a28:	f1 cf       	rjmp	.-30     	; 0x1a0c <vTaskDelayUntil+0x6c>
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
		{
			portYIELD_WITHIN_API();
		}
	}
    1a2a:	df 91       	pop	r29
    1a2c:	cf 91       	pop	r28
    1a2e:	1f 91       	pop	r17
    1a30:	0f 91       	pop	r16
    1a32:	08 95       	ret

00001a34 <vTaskSwitchContext>:
#endif
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
    1a34:	80 91 2d 03 	lds	r24, 0x032D
    1a38:	88 23       	and	r24, r24
    1a3a:	99 f4       	brne	.+38     	; 0x1a62 <vTaskSwitchContext+0x2e>
	
		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();
	
		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
    1a3c:	80 91 2e 03 	lds	r24, 0x032E
    1a40:	90 e0       	ldi	r25, 0x00	; 0
    1a42:	fc 01       	movw	r30, r24
    1a44:	ee 0f       	add	r30, r30
    1a46:	ff 1f       	adc	r31, r31
    1a48:	ee 0f       	add	r30, r30
    1a4a:	ff 1f       	adc	r31, r31
    1a4c:	ee 0f       	add	r30, r30
    1a4e:	ff 1f       	adc	r31, r31
    1a50:	8e 0f       	add	r24, r30
    1a52:	9f 1f       	adc	r25, r31
    1a54:	fc 01       	movw	r30, r24
    1a56:	e1 5d       	subi	r30, 0xD1	; 209
    1a58:	fc 4f       	sbci	r31, 0xFC	; 252
    1a5a:	80 81       	ld	r24, Z
    1a5c:	88 23       	and	r24, r24
    1a5e:	29 f0       	breq	.+10     	; 0x1a6a <vTaskSwitchContext+0x36>
    1a60:	1d c0       	rjmp	.+58     	; 0x1a9c <vTaskSwitchContext+0x68>
{
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xMissedYield = pdTRUE;
    1a62:	81 e0       	ldi	r24, 0x01	; 1
    1a64:	80 93 29 03 	sts	0x0329, r24
    1a68:	08 95       	ret
	
		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();
	
		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
    1a6a:	2f e2       	ldi	r18, 0x2F	; 47
    1a6c:	33 e0       	ldi	r19, 0x03	; 3
		{
			configASSERT( uxTopReadyPriority );
			--uxTopReadyPriority;
    1a6e:	80 91 2e 03 	lds	r24, 0x032E
    1a72:	81 50       	subi	r24, 0x01	; 1
    1a74:	80 93 2e 03 	sts	0x032E, r24
	
		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();
	
		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
    1a78:	80 91 2e 03 	lds	r24, 0x032E
    1a7c:	90 e0       	ldi	r25, 0x00	; 0
    1a7e:	fc 01       	movw	r30, r24
    1a80:	ee 0f       	add	r30, r30
    1a82:	ff 1f       	adc	r31, r31
    1a84:	ee 0f       	add	r30, r30
    1a86:	ff 1f       	adc	r31, r31
    1a88:	ee 0f       	add	r30, r30
    1a8a:	ff 1f       	adc	r31, r31
    1a8c:	8e 0f       	add	r24, r30
    1a8e:	9f 1f       	adc	r25, r31
    1a90:	f9 01       	movw	r30, r18
    1a92:	e8 0f       	add	r30, r24
    1a94:	f9 1f       	adc	r31, r25
    1a96:	80 81       	ld	r24, Z
    1a98:	88 23       	and	r24, r24
    1a9a:	49 f3       	breq	.-46     	; 0x1a6e <vTaskSwitchContext+0x3a>
			--uxTopReadyPriority;
		}
	
		/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the tasks of the
		same priority get an equal share of the processor time. */
		listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopReadyPriority ] ) );
    1a9c:	80 91 2e 03 	lds	r24, 0x032E
    1aa0:	90 e0       	ldi	r25, 0x00	; 0
    1aa2:	9c 01       	movw	r18, r24
    1aa4:	22 0f       	add	r18, r18
    1aa6:	33 1f       	adc	r19, r19
    1aa8:	22 0f       	add	r18, r18
    1aaa:	33 1f       	adc	r19, r19
    1aac:	22 0f       	add	r18, r18
    1aae:	33 1f       	adc	r19, r19
    1ab0:	28 0f       	add	r18, r24
    1ab2:	39 1f       	adc	r19, r25
    1ab4:	d9 01       	movw	r26, r18
    1ab6:	a1 5d       	subi	r26, 0xD1	; 209
    1ab8:	bc 4f       	sbci	r27, 0xFC	; 252
    1aba:	11 96       	adiw	r26, 0x01	; 1
    1abc:	ed 91       	ld	r30, X+
    1abe:	fc 91       	ld	r31, X
    1ac0:	12 97       	sbiw	r26, 0x02	; 2
    1ac2:	02 80       	ldd	r0, Z+2	; 0x02
    1ac4:	f3 81       	ldd	r31, Z+3	; 0x03
    1ac6:	e0 2d       	mov	r30, r0
    1ac8:	12 96       	adiw	r26, 0x02	; 2
    1aca:	fc 93       	st	X, r31
    1acc:	ee 93       	st	-X, r30
    1ace:	11 97       	sbiw	r26, 0x01	; 1
    1ad0:	2e 5c       	subi	r18, 0xCE	; 206
    1ad2:	3c 4f       	sbci	r19, 0xFC	; 252
    1ad4:	e2 17       	cp	r30, r18
    1ad6:	f3 07       	cpc	r31, r19
    1ad8:	29 f4       	brne	.+10     	; 0x1ae4 <vTaskSwitchContext+0xb0>
    1ada:	22 81       	ldd	r18, Z+2	; 0x02
    1adc:	33 81       	ldd	r19, Z+3	; 0x03
    1ade:	fd 01       	movw	r30, r26
    1ae0:	32 83       	std	Z+2, r19	; 0x02
    1ae2:	21 83       	std	Z+1, r18	; 0x01
    1ae4:	fc 01       	movw	r30, r24
    1ae6:	ee 0f       	add	r30, r30
    1ae8:	ff 1f       	adc	r31, r31
    1aea:	ee 0f       	add	r30, r30
    1aec:	ff 1f       	adc	r31, r31
    1aee:	ee 0f       	add	r30, r30
    1af0:	ff 1f       	adc	r31, r31
    1af2:	8e 0f       	add	r24, r30
    1af4:	9f 1f       	adc	r25, r31
    1af6:	fc 01       	movw	r30, r24
    1af8:	e1 5d       	subi	r30, 0xD1	; 209
    1afa:	fc 4f       	sbci	r31, 0xFC	; 252
    1afc:	01 80       	ldd	r0, Z+1	; 0x01
    1afe:	f2 81       	ldd	r31, Z+2	; 0x02
    1b00:	e0 2d       	mov	r30, r0
    1b02:	86 81       	ldd	r24, Z+6	; 0x06
    1b04:	97 81       	ldd	r25, Z+7	; 0x07
    1b06:	90 93 28 03 	sts	0x0328, r25
    1b0a:	80 93 27 03 	sts	0x0327, r24
    1b0e:	08 95       	ret

00001b10 <vTaskPlaceOnEventList>:
	}
}
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( const xList * const pxEventList, portTickType xTicksToWait )
{
    1b10:	cf 93       	push	r28
    1b12:	df 93       	push	r29
    1b14:	eb 01       	movw	r28, r22
	SCHEDULER SUSPENDED. */

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event. */
	vListInsert( ( xList * ) pxEventList, ( xListItem * ) &( pxCurrentTCB->xEventListItem ) );
    1b16:	60 91 27 03 	lds	r22, 0x0327
    1b1a:	70 91 28 03 	lds	r23, 0x0328
    1b1e:	64 5f       	subi	r22, 0xF4	; 244
    1b20:	7f 4f       	sbci	r23, 0xFF	; 255
    1b22:	0e 94 85 03 	call	0x70a	; 0x70a <vListInsert>

	/* We must remove ourselves from the ready list before adding ourselves
	to the blocked list as the same list item is used for both lists.  We have
	exclusive access to the ready lists as the scheduler is locked. */
	vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    1b26:	80 91 27 03 	lds	r24, 0x0327
    1b2a:	90 91 28 03 	lds	r25, 0x0328
    1b2e:	02 96       	adiw	r24, 0x02	; 2
    1b30:	0e 94 c4 03 	call	0x788	; 0x788 <vListRemove>
	}
	#else
	{
			/* Calculate the time at which the task should be woken if the event does
			not occur.  This may overflow but this doesn't matter. */
			xTimeToWake = xTickCount + xTicksToWait;
    1b34:	80 91 2b 03 	lds	r24, 0x032B
    1b38:	90 91 2c 03 	lds	r25, 0x032C
			prvAddCurrentTaskToDelayedList( xTimeToWake );
    1b3c:	8c 0f       	add	r24, r28
    1b3e:	9d 1f       	adc	r25, r29
    1b40:	0e 94 34 09 	call	0x1268	; 0x1268 <prvAddCurrentTaskToDelayedList>
	}
	#endif
}
    1b44:	df 91       	pop	r29
    1b46:	cf 91       	pop	r28
    1b48:	08 95       	ret

00001b4a <xTaskRemoveFromEventList>:
	
#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xTaskRemoveFromEventList( const xList * const pxEventList )
{
    1b4a:	0f 93       	push	r16
    1b4c:	1f 93       	push	r17
    1b4e:	cf 93       	push	r28
    1b50:	df 93       	push	r29
	get called - the lock count on the queue will get modified instead.  This
	means we can always expect exclusive access to the event list here.
	
	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
    1b52:	dc 01       	movw	r26, r24
    1b54:	15 96       	adiw	r26, 0x05	; 5
    1b56:	ed 91       	ld	r30, X+
    1b58:	fc 91       	ld	r31, X
    1b5a:	16 97       	sbiw	r26, 0x06	; 6
    1b5c:	c6 81       	ldd	r28, Z+6	; 0x06
    1b5e:	d7 81       	ldd	r29, Z+7	; 0x07
	configASSERT( pxUnblockedTCB );
	vListRemove( &( pxUnblockedTCB->xEventListItem ) );
    1b60:	8e 01       	movw	r16, r28
    1b62:	04 5f       	subi	r16, 0xF4	; 244
    1b64:	1f 4f       	sbci	r17, 0xFF	; 255
    1b66:	c8 01       	movw	r24, r16
    1b68:	0e 94 c4 03 	call	0x788	; 0x788 <vListRemove>

	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    1b6c:	80 91 2d 03 	lds	r24, 0x032D
    1b70:	88 23       	and	r24, r24
    1b72:	e9 f4       	brne	.+58     	; 0x1bae <xTaskRemoveFromEventList+0x64>
	{
		vListRemove( &( pxUnblockedTCB->xGenericListItem ) );
    1b74:	8e 01       	movw	r16, r28
    1b76:	0e 5f       	subi	r16, 0xFE	; 254
    1b78:	1f 4f       	sbci	r17, 0xFF	; 255
    1b7a:	c8 01       	movw	r24, r16
    1b7c:	0e 94 c4 03 	call	0x788	; 0x788 <vListRemove>
		prvAddTaskToReadyQueue( pxUnblockedTCB );
    1b80:	8e 89       	ldd	r24, Y+22	; 0x16
    1b82:	90 91 2e 03 	lds	r25, 0x032E
    1b86:	98 17       	cp	r25, r24
    1b88:	10 f4       	brcc	.+4      	; 0x1b8e <xTaskRemoveFromEventList+0x44>
    1b8a:	80 93 2e 03 	sts	0x032E, r24
    1b8e:	90 e0       	ldi	r25, 0x00	; 0
    1b90:	9c 01       	movw	r18, r24
    1b92:	22 0f       	add	r18, r18
    1b94:	33 1f       	adc	r19, r19
    1b96:	22 0f       	add	r18, r18
    1b98:	33 1f       	adc	r19, r19
    1b9a:	22 0f       	add	r18, r18
    1b9c:	33 1f       	adc	r19, r19
    1b9e:	82 0f       	add	r24, r18
    1ba0:	93 1f       	adc	r25, r19
    1ba2:	81 5d       	subi	r24, 0xD1	; 209
    1ba4:	9c 4f       	sbci	r25, 0xFC	; 252
    1ba6:	b8 01       	movw	r22, r16
    1ba8:	0e 94 5e 03 	call	0x6bc	; 0x6bc <vListInsertEnd>
    1bac:	05 c0       	rjmp	.+10     	; 0x1bb8 <xTaskRemoveFromEventList+0x6e>
	}
	else
	{
		/* We cannot access the delayed or ready lists, so will hold this
		task pending until the scheduler is resumed. */
		vListInsertEnd( ( xList * ) &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
    1bae:	81 e4       	ldi	r24, 0x41	; 65
    1bb0:	93 e0       	ldi	r25, 0x03	; 3
    1bb2:	b8 01       	movw	r22, r16
    1bb4:	0e 94 5e 03 	call	0x6bc	; 0x6bc <vListInsertEnd>
	}

	if( pxUnblockedTCB->uxPriority >= pxCurrentTCB->uxPriority )
    1bb8:	e0 91 27 03 	lds	r30, 0x0327
    1bbc:	f0 91 28 03 	lds	r31, 0x0328
	else
	{
		xReturn = pdFALSE;
	}

	return xReturn;
    1bc0:	81 e0       	ldi	r24, 0x01	; 1
    1bc2:	2e 89       	ldd	r18, Y+22	; 0x16
    1bc4:	96 89       	ldd	r25, Z+22	; 0x16
    1bc6:	29 17       	cp	r18, r25
    1bc8:	08 f4       	brcc	.+2      	; 0x1bcc <xTaskRemoveFromEventList+0x82>
    1bca:	80 e0       	ldi	r24, 0x00	; 0
}
    1bcc:	df 91       	pop	r29
    1bce:	cf 91       	pop	r28
    1bd0:	1f 91       	pop	r17
    1bd2:	0f 91       	pop	r16
    1bd4:	08 95       	ret

00001bd6 <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( xTimeOutType * const pxTimeOut )
{
    1bd6:	fc 01       	movw	r30, r24
	configASSERT( pxTimeOut );
	pxTimeOut->xOverflowCount = xNumOfOverflows;
    1bd8:	80 91 2a 03 	lds	r24, 0x032A
    1bdc:	80 83       	st	Z, r24
	pxTimeOut->xTimeOnEntering = xTickCount;
    1bde:	80 91 2b 03 	lds	r24, 0x032B
    1be2:	90 91 2c 03 	lds	r25, 0x032C
    1be6:	92 83       	std	Z+2, r25	; 0x02
    1be8:	81 83       	std	Z+1, r24	; 0x01
}
    1bea:	08 95       	ret

00001bec <xTaskCheckForTimeOut>:
/*-----------------------------------------------------------*/

portBASE_TYPE xTaskCheckForTimeOut( xTimeOutType * const pxTimeOut, portTickType * const pxTicksToWait )
{
    1bec:	fc 01       	movw	r30, r24
portBASE_TYPE xReturn;

	configASSERT( pxTimeOut );
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
    1bee:	0f b6       	in	r0, 0x3f	; 63
    1bf0:	f8 94       	cli
    1bf2:	0f 92       	push	r0
				xReturn = pdFALSE;
			}
			else /* We are not blocking indefinitely, perform the checks below. */
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( ( portTickType ) xTickCount >= ( portTickType ) pxTimeOut->xTimeOnEntering ) )
    1bf4:	80 91 2a 03 	lds	r24, 0x032A
    1bf8:	90 81       	ld	r25, Z
    1bfa:	98 17       	cp	r25, r24
    1bfc:	49 f0       	breq	.+18     	; 0x1c10 <xTaskCheckForTimeOut+0x24>
    1bfe:	80 91 2b 03 	lds	r24, 0x032B
    1c02:	90 91 2c 03 	lds	r25, 0x032C
    1c06:	21 81       	ldd	r18, Z+1	; 0x01
    1c08:	32 81       	ldd	r19, Z+2	; 0x02
    1c0a:	82 17       	cp	r24, r18
    1c0c:	93 07       	cpc	r25, r19
    1c0e:	f0 f4       	brcc	.+60     	; 0x1c4c <xTaskCheckForTimeOut+0x60>
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
		}
		else if( ( ( portTickType ) ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering ) ) < ( portTickType ) *pxTicksToWait )
    1c10:	40 91 2b 03 	lds	r20, 0x032B
    1c14:	50 91 2c 03 	lds	r21, 0x032C
    1c18:	21 81       	ldd	r18, Z+1	; 0x01
    1c1a:	32 81       	ldd	r19, Z+2	; 0x02
    1c1c:	db 01       	movw	r26, r22
    1c1e:	8d 91       	ld	r24, X+
    1c20:	9c 91       	ld	r25, X
    1c22:	11 97       	sbiw	r26, 0x01	; 1
    1c24:	42 1b       	sub	r20, r18
    1c26:	53 0b       	sbc	r21, r19
    1c28:	48 17       	cp	r20, r24
    1c2a:	59 07       	cpc	r21, r25
    1c2c:	88 f4       	brcc	.+34     	; 0x1c50 <xTaskCheckForTimeOut+0x64>
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering );
    1c2e:	40 91 2b 03 	lds	r20, 0x032B
    1c32:	50 91 2c 03 	lds	r21, 0x032C
    1c36:	24 1b       	sub	r18, r20
    1c38:	35 0b       	sbc	r19, r21
    1c3a:	82 0f       	add	r24, r18
    1c3c:	93 1f       	adc	r25, r19
    1c3e:	8d 93       	st	X+, r24
    1c40:	9c 93       	st	X, r25
			vTaskSetTimeOutState( pxTimeOut );
    1c42:	cf 01       	movw	r24, r30
    1c44:	0e 94 eb 0d 	call	0x1bd6	; 0x1bd6 <vTaskSetTimeOutState>
			xReturn = pdFALSE;
    1c48:	80 e0       	ldi	r24, 0x00	; 0
    1c4a:	03 c0       	rjmp	.+6      	; 0x1c52 <xTaskCheckForTimeOut+0x66>
		{
			/* The tick count is greater than the time at which vTaskSetTimeout()
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
    1c4c:	81 e0       	ldi	r24, 0x01	; 1
    1c4e:	01 c0       	rjmp	.+2      	; 0x1c52 <xTaskCheckForTimeOut+0x66>
			vTaskSetTimeOutState( pxTimeOut );
			xReturn = pdFALSE;
		}
		else
		{
			xReturn = pdTRUE;
    1c50:	81 e0       	ldi	r24, 0x01	; 1
		}
	}
	taskEXIT_CRITICAL();
    1c52:	0f 90       	pop	r0
    1c54:	0f be       	out	0x3f, r0	; 63

	return xReturn;
}
    1c56:	08 95       	ret

00001c58 <vTaskMissedYield>:
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
	xMissedYield = pdTRUE;
    1c58:	81 e0       	ldi	r24, 0x01	; 1
    1c5a:	80 93 29 03 	sts	0x0329, r24
}
    1c5e:	08 95       	ret

00001c60 <memcpy>:
    1c60:	fb 01       	movw	r30, r22
    1c62:	dc 01       	movw	r26, r24
    1c64:	02 c0       	rjmp	.+4      	; 0x1c6a <memcpy+0xa>
    1c66:	01 90       	ld	r0, Z+
    1c68:	0d 92       	st	X+, r0
    1c6a:	41 50       	subi	r20, 0x01	; 1
    1c6c:	50 40       	sbci	r21, 0x00	; 0
    1c6e:	d8 f7       	brcc	.-10     	; 0x1c66 <memcpy+0x6>
    1c70:	08 95       	ret

00001c72 <memset>:
    1c72:	dc 01       	movw	r26, r24
    1c74:	01 c0       	rjmp	.+2      	; 0x1c78 <memset+0x6>
    1c76:	6d 93       	st	X+, r22
    1c78:	41 50       	subi	r20, 0x01	; 1
    1c7a:	50 40       	sbci	r21, 0x00	; 0
    1c7c:	e0 f7       	brcc	.-8      	; 0x1c76 <memset+0x4>
    1c7e:	08 95       	ret

00001c80 <strncpy>:
    1c80:	fb 01       	movw	r30, r22
    1c82:	dc 01       	movw	r26, r24
    1c84:	41 50       	subi	r20, 0x01	; 1
    1c86:	50 40       	sbci	r21, 0x00	; 0
    1c88:	48 f0       	brcs	.+18     	; 0x1c9c <strncpy+0x1c>
    1c8a:	01 90       	ld	r0, Z+
    1c8c:	0d 92       	st	X+, r0
    1c8e:	00 20       	and	r0, r0
    1c90:	c9 f7       	brne	.-14     	; 0x1c84 <strncpy+0x4>
    1c92:	01 c0       	rjmp	.+2      	; 0x1c96 <strncpy+0x16>
    1c94:	1d 92       	st	X+, r1
    1c96:	41 50       	subi	r20, 0x01	; 1
    1c98:	50 40       	sbci	r21, 0x00	; 0
    1c9a:	e0 f7       	brcc	.-8      	; 0x1c94 <strncpy+0x14>
    1c9c:	08 95       	ret

00001c9e <_exit>:
    1c9e:	f8 94       	cli

00001ca0 <__stop_program>:
    1ca0:	ff cf       	rjmp	.-2      	; 0x1ca0 <__stop_program>
